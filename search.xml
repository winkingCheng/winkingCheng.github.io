<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>分布式缓存分区算法——Hash与一致性Hash</title>
      <link href="/blog/2021/07/10/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E5%88%86%E5%8C%BA%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94Hash%E4%B8%8E%E4%B8%80%E8%87%B4%E6%80%A7Hash/"/>
      <url>/blog/2021/07/10/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E5%88%86%E5%8C%BA%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94Hash%E4%B8%8E%E4%B8%80%E8%87%B4%E6%80%A7Hash/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式缓存分区算法——Hash与一致性Hash"><a href="#分布式缓存分区算法——Hash与一致性Hash" class="headerlink" title="分布式缓存分区算法——Hash与一致性Hash"></a>分布式缓存分区算法——Hash与一致性Hash</h1><h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>&emsp;&emsp;假设我们有三台缓存服务器，用于缓存图片，我们为这三台缓存服务器编号为0号、1号、2号，现在，有3万张图片需要缓存，我们希望这些图片被均匀的缓存到这3台服务器上，以便它们能够分摊缓存的压力。也就是说，我们希望每台服务器能够缓存1万张左右的图片，那我们应该怎样做呢？如果我们没有任何规律的将3万张图片平均的缓存在3台服务器上，可以满足我们的要求吗？可以！但是如果这样做，当我们需要访问某张图片时，由于我们不清楚该图片被缓存到哪台服务器上，所以需要遍历3台缓存服务器，从3万个缓存项中找到我们需要访问的缓存，遍历的过程效率太低，时间太长。当我们找到该图片时，时长可能是不能被接受的，也就失去了缓存的意义。我们做缓存的目的就是提高速度，改善用户体验，减轻后端服务器压力，如果每次访问一个缓存项都需要遍历所有缓存服务器的所有缓存项，想想就觉得很累，那么，我们该怎么办呢？</p><h2 id="二、普通Hash算法"><a href="#二、普通Hash算法" class="headerlink" title="二、普通Hash算法"></a>二、普通Hash算法</h2><p>&emsp;&emsp;对于上面的问题，我们原始的做法是对缓存项的键进行哈希，将Hash后的结果对缓存服务器的数量进行取模操作，通过取模后的结果，决定缓存项将会缓存在哪一台服务器上。我们仍然以刚才描述的场景为例，假设我们使用图片名称作为访问图片的key（假设图片名称是不重复的），那么，我们可以使用如下公式，计算出图片应该存放在哪台服务器上。</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>服务器数 = Hash（图片名称）% N（N为服务器总台数）</strong></p><p>&emsp;&emsp;当我们访问任意一个图片的时候，只要再次对图片名称进行上述运算，即可得出对应的图片应该存放在哪一台缓存服务器上，我们只要在这一台服务器上查找图片即可，如果图片在对应的服务器上不存在，则证明对应的图片没有被缓存，也不用再去遍历其他缓存服务器了，通过这样的方法，即可将3万张图片随机的分布到3台缓存服务器上了，而且下次访问某张图片时，直接能够判断出该图片应该存在于哪台缓存服务器上，这样就能满足我们的需求了。</p><p>&emsp;&emsp;但是，使用上述Hash算法进行缓存时，会出现一些缺陷，试想一下，如果3台缓存服务器已经不能满足我们的缓存需求，那么我们应该怎么做呢？没错，很简单，多增加两台缓存服务器不就行了。假设，我们增加了一台缓存服务器，那么缓存服务器的数量就由3台变成了4台。此时，如果仍然使用上述方法对同一张图片进行缓存，那么这张图片所在的服务器编号必定与原来3台服务器时所在的服务器编号不同，因为除数由3变为了4，这种情况带来的结果就是当服务器数量变动时，所有缓存的位置都要发生改变。换句话说，当服务器数量发生改变时，所有缓存在一定时间内是失效的，当应用无法从缓存中获取数据时，则会向后端服务器请求数据。同理，假设3台缓存中突然有一台缓存服务器出现了故障，无法进行缓存，那么我们则需要将故障机器移除，但是如果移除了一台缓存服务器，那么缓存服务器数量从3台变为2台，如果想要访问一张图片，这张图片的缓存位置必定会发生改变，以前缓存的图片也会失去缓存的作用与意义，由于大量缓存在同一时间失效，造成了缓存的雪崩。此时前端缓存已经无法起到承担部分压力的作用，后端服务器将会承受巨大的压力，整个系统很有可能被压垮。所以，我们应该想办法不让这种情况发生，但是由于上述Hash算法本身的缘故，使用取模法进行缓存时，这种情况是无法避免的。</p><p><strong>总结</strong></p><p>&emsp;&emsp;Hash算法能够有效解决分布式数据的存储问题，但由于其算法的缘故，可能会出现以下问题：</p><p>a、当缓存服务器数量发生变化时，会引起缓存的雪崩，可能会引起整体系统压力过大而崩溃（大量缓存同一时间失效）。</p><p>b、当缓存服务器数量发生变化时，几乎所有缓存的位置都会发生改变，怎样才能尽量减少受影响的缓存呢？</p><h2 id="三、一致性Hash算法"><a href="#三、一致性Hash算法" class="headerlink" title="三、一致性Hash算法"></a>三、一致性Hash算法</h2><p>&emsp;&emsp;对于上面的问题，一致性Hash可以解决，那么它是怎么解决的呢？其实，一致性Hash算法也是使用取模的方法。只是普通的Hash算法是对服务器数量进行取模，而一致性Hash算法则是对2^32取模。然后我们把从0~2^32-1这一串数字想象为一个圆环。我们将这个圆环称之为一致性Hash环（如下图）。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210712154644049.png" alt="image-20210712154644049"></p><p>&emsp;&emsp;接下来，我们先将我们的服务器IP地址进行Hash计算，使用Hash后的结果对2^32取模，获取其在上述Hash环上的位置。然后我们就可以将服务器映射到Hash环上，如下图所示（理想状态），而对于这些节点，我们称之为<strong>物理节点</strong>。</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;**Hash环位置 = Hash（服务器IP地址）% 2^32 **</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210712161304263.png" alt="image-20210712161304263"></p><p>&emsp;&emsp;同理，我们将我们的图片名称进行Hash，然后%2^32，获取其在Hash环上的位置。如下图左，那么我们的数据应该放在哪个服务器呢？应该是放在C服务器上，因为按照该数据沿着Hash环顺时针旋转，第一个接触到的服务器就是C（如下图右）。</p><p>&emsp;&emsp;一致性哈希算法就是通过这种方法，判断一个对象应该被缓存到哪台服务器上的，将缓存服务器与被缓存对象都映射到Hash环上以后，从被缓存对象的位置出发，沿顺时针方向遇到的第一个服务器，就是当前对象将要缓存的服务器。由于被缓存对象与服务器Hash后的值是固定的，所以，在服务器不变的情况下，一张图片必定会被缓存到固定的服务器上，那么，当下次想要访问这张图片时，只要再次使用相同的算法进行计算，即可算出这个图片被缓存在哪个服务器上，直接去对应的服务器查找对应的图片即可。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210712162414899.png" alt="image-20210712162414899"></p><p>&emsp;&emsp;说到这里，我们还没有说清楚，一致性Hash是如何解决上面Hash算法的问题。我们举个例子，如下图，假设当前我们所有的数据均匀的分布在这个Hash环上，当节点B挂掉了之后，就只有从C到B这一段的数据会查询不到，从而到数据库进行查询，而不会影响到B到A和A到C这两段，尽可能减少了缓存雪崩的情况。同理，当我们增加了一台服务器，那么就只能加在这三段中间的某一段，从而影响的数据就只有1/6（理想状态下）。所以在使用一致性Hash算法后，服务器的数量如果发生改变，<strong>并不是所有缓存都会失效，而是只有部分缓存会失效</strong>，前端的缓存仍然能分担整个系统的压力，而不至于所有压力都在同一时间集中到后端服务器上。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210712165801564.png" alt="image-20210712165801564"></p><h2 id="四、一致性Hash的优化"><a href="#四、一致性Hash的优化" class="headerlink" title="四、一致性Hash的优化"></a>四、一致性Hash的优化</h2><p>&emsp;&emsp;虽然使用一致性Hash之后，我们新增或删除节点不会造成全局洗牌，所有的数据也不需要<em>rehash</em>，但是确实是有一部分数据不能命中，会直接穿透到数据库进行查询，那么如果这部分数据是<strong>热点数据或者数据基数很大的情况下</strong>，还是会给DB造成一定压力，此时我们可以考虑每次查询的时候，<strong>不再查询最近的一个节点，而是两个节点</strong>，这样子就可以进一步减少DB的压力。当然，并不是查询的节点越多越好，当查询越多的情况下，可能这个速度就还不如去数据库进行查询了。</p><p><strong>数据倾斜</strong></p><p>&emsp;&emsp;虽然一致性Hash能够解决我们在使用Hash算法上面的问题。但是你们有没有发现，我在上面一些地方都标注了理想状态。这就说明，在真实情况下可能并不是这个样子的。如下图：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210712171151402.png" alt="image-20210712171151402"></p><p>&emsp;&emsp;真实情况下，我们的物理节点可能会很集中的映射到Hash环的一侧，这种情况就会导致所有的数据都保存在其中一个节点（如上图就是节点A），这种情况也被称为<strong>数据倾斜</strong>。</p><p>&emsp;&emsp;当出现数据倾斜时，如果我们没有进行处理，那么首先，各个服务器的数据量相差巨大，有的可能包揽了大部分的数据，有的可能一个数据都没有。那么此时如果存在大量数据的服务器发生异常时，那么就会出现大量缓存数据失效，从而发生缓存雪崩的情况。那么，怎么解决呢？</p><p><strong>虚拟节点</strong></p><p>&emsp;&emsp;我们发现节点数越少，越容易出现节点在哈希环上的分布不均匀，导致各节点映射的对象数量严重不均衡(数据倾斜)的情况；相反，节点数越多越密集，数据在哈希环上的分布就越均匀。但实际部署的物理节点有限，此时我们可以用有限的物理节点，虚拟出足够多的虚拟节点(Virtual Node)，最终达到数据在哈希环上均匀分布的效果（如下图）。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210712172810596.png" alt="image-20210712172810596"></p><h2 id="五、一致性Hash算法的Java实现"><a href="#五、一致性Hash算法的Java实现" class="headerlink" title="五、一致性Hash算法的Java实现"></a>五、一致性Hash算法的Java实现</h2><p>&emsp;&emsp;在我们日常使用中，有一些组件已经实现一致性Hash算法，我们直接使用即可。例如Twitter研发的Twemproxy、codis等。下面是使用Java对一致性Hash算法的实现。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">package <span class="built_in">hash</span>;</span><br><span class="line"> </span><br><span class="line">import java.util.SortedMap;</span><br><span class="line">import java.util.TreeMap;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * 不带虚拟节点的一致性Hash算法</span><br><span class="line"> */</span><br><span class="line">public class ConsistentHashingWithoutVirtualNode &#123;</span><br><span class="line"> </span><br><span class="line">//待添加入Hash环的服务器列表</span><br><span class="line">private static String[] servers = &#123; <span class="string">&quot;192.168.0.0:111&quot;</span>, <span class="string">&quot;192.168.0.1:111&quot;</span>,</span><br><span class="line"><span class="string">&quot;192.168.0.2:111&quot;</span>, <span class="string">&quot;192.168.0.3:111&quot;</span>, <span class="string">&quot;192.168.0.4:111&quot;</span> &#125;;</span><br><span class="line"> </span><br><span class="line">//key表示服务器的<span class="built_in">hash</span>值，value表示服务器</span><br><span class="line">private static SortedMap&lt;Integer, String&gt; sortedMap = new TreeMap&lt;Integer, String&gt;();</span><br><span class="line"> </span><br><span class="line">//程序初始化，将所有的服务器放入sortedMap中</span><br><span class="line">static &#123;</span><br><span class="line"><span class="keyword">for</span> (int i=0; i&lt;servers.length; i++) &#123;</span><br><span class="line">int <span class="built_in">hash</span> = getHash(servers[i]);</span><br><span class="line">System.out.println(<span class="string">&quot;[&quot;</span> + servers[i] + <span class="string">&quot;]加入集合中, 其Hash值为&quot;</span> + <span class="built_in">hash</span>);</span><br><span class="line">sortedMap.put(<span class="built_in">hash</span>, servers[i]);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//得到应当路由到的结点</span><br><span class="line">private static String getServer(String key) &#123;</span><br><span class="line">//得到该key的<span class="built_in">hash</span>值</span><br><span class="line">int <span class="built_in">hash</span> = getHash(key);</span><br><span class="line">//得到大于该Hash值的所有Map</span><br><span class="line">SortedMap&lt;Integer, String&gt; subMap = sortedMap.tailMap(<span class="built_in">hash</span>);</span><br><span class="line"><span class="keyword">if</span>(subMap.isEmpty())&#123;</span><br><span class="line">//如果没有比该key的<span class="built_in">hash</span>值大的，则从第一个node开始</span><br><span class="line">Integer i = sortedMap.firstKey();</span><br><span class="line">//返回对应的服务器</span><br><span class="line"><span class="built_in">return</span> sortedMap.get(i);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">//第一个Key就是顺时针过去离node最近的那个结点</span><br><span class="line">Integer i = subMap.firstKey();</span><br><span class="line">//返回对应的服务器</span><br><span class="line"><span class="built_in">return</span> subMap.get(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//使用FNV1_32_HASH算法计算服务器的Hash值,这里不使用重写hashCode的方法，最终效果没区别</span><br><span class="line">private static int getHash(String str) &#123;</span><br><span class="line">final int p = 16777619;</span><br><span class="line">int <span class="built_in">hash</span> = (int) 2166136261L;</span><br><span class="line"><span class="keyword">for</span> (int i = 0; i &lt; str.length(); i++)</span><br><span class="line"><span class="built_in">hash</span> = (<span class="built_in">hash</span> ^ str.charAt(i)) * p;</span><br><span class="line"><span class="built_in">hash</span> += <span class="built_in">hash</span> &lt;&lt; <span class="string">13;</span></span><br><span class="line"><span class="string">hash ^= hash &gt;&gt; 7;</span></span><br><span class="line"><span class="string">hash += hash &lt;&lt; 3;</span></span><br><span class="line"><span class="string">hash ^= hash &gt;&gt; 17;</span></span><br><span class="line"><span class="string">hash += hash &lt;&lt; 5;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">// 如果算出来的值为负数则取其绝对值</span></span><br><span class="line"><span class="string">if (hash &lt; 0)</span></span><br><span class="line"><span class="string">hash = Math.abs(hash);</span></span><br><span class="line"><span class="string">return hash;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="string">String[] keys = &#123;&quot;太阳&quot;, &quot;月亮&quot;, &quot;星星&quot;&#125;;</span></span><br><span class="line"><span class="string">for(int i=0; i&lt;keys.length; i++)</span></span><br><span class="line"><span class="string">System.out.println(&quot;[&quot; + keys[i] + &quot;]的hash值为&quot; + getHash(keys[i])</span></span><br><span class="line"><span class="string">+ &quot;, 被路由到结点[&quot; + getServer(keys[i]) + &quot;]&quot;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>执行结果：<br>[192.168.0.0:111]加入集合中, 其Hash值为575774686<br>[192.168.0.1:111]加入集合中, 其Hash值为8518713<br>[192.168.0.2:111]加入集合中, 其Hash值为1361847097<br>[192.168.0.3:111]加入集合中, 其Hash值为1171828661<br>[192.168.0.4:111]加入集合中, 其Hash值为1764547046</p><p>[太阳]的hash值为1977106057, 被路由到结点[192.168.0.1:111]<br>[月亮]的hash值为1132637661, 被路由到结点[192.168.0.3:111]<br>[星星]的hash值为880019273, 被路由到结点[192.168.0.3:111]</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">package <span class="built_in">hash</span>;</span><br><span class="line"> </span><br><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.SortedMap;</span><br><span class="line">import java.util.TreeMap;</span><br><span class="line"> </span><br><span class="line">import org.apache.commons.lang.StringUtils;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line">  * 带虚拟节点的一致性Hash算法</span><br><span class="line">  */</span><br><span class="line"> public class ConsistentHashingWithoutVirtualNode &#123;</span><br><span class="line"> </span><br><span class="line">     //待添加入Hash环的服务器列表</span><br><span class="line">     private static String[] servers = &#123;<span class="string">&quot;192.168.0.0:111&quot;</span>, <span class="string">&quot;192.168.0.1:111&quot;</span>, <span class="string">&quot;192.168.0.2:111&quot;</span>,</span><br><span class="line">             <span class="string">&quot;192.168.0.3:111&quot;</span>, <span class="string">&quot;192.168.0.4:111&quot;</span>&#125;;</span><br><span class="line">     </span><br><span class="line">     //真实结点列表,考虑到服务器上线、下线的场景，即添加、删除的场景会比较频繁，这里使用LinkedList会更好</span><br><span class="line">     private static List&lt;String&gt; realNodes = new LinkedList&lt;String&gt;();</span><br><span class="line">     </span><br><span class="line">     //虚拟节点，key表示虚拟节点的<span class="built_in">hash</span>值，value表示虚拟节点的名称</span><br><span class="line">     private static SortedMap&lt;Integer, String&gt; virtualNodes = new TreeMap&lt;Integer, String&gt;();</span><br><span class="line">             </span><br><span class="line">     //虚拟节点的数目，这里写死，为了演示需要，一个真实结点对应5个虚拟节点</span><br><span class="line">     private static final int VIRTUAL_NODES = 5;</span><br><span class="line">     </span><br><span class="line">     static&#123;</span><br><span class="line">         //先把原始的服务器添加到真实结点列表中</span><br><span class="line">         <span class="keyword">for</span>(int i=0; i&lt;servers.length; i++)</span><br><span class="line">             realNodes.add(servers[i]);</span><br><span class="line">         </span><br><span class="line">         //再添加虚拟节点，遍历LinkedList使用foreach循环效率会比较高</span><br><span class="line">         <span class="keyword">for</span> (String str : realNodes)&#123;</span><br><span class="line">             <span class="keyword">for</span>(int i=0; i&lt;VIRTUAL_NODES; i++)&#123;</span><br><span class="line">                 String virtualNodeName = str + <span class="string">&quot;&amp;&amp;VN&quot;</span> + String.valueOf(i);</span><br><span class="line">                 int <span class="built_in">hash</span> = getHash(virtualNodeName);</span><br><span class="line">                 System.out.println(<span class="string">&quot;虚拟节点[&quot;</span> + virtualNodeName + <span class="string">&quot;]被添加, hash值为&quot;</span> + <span class="built_in">hash</span>);</span><br><span class="line">                 virtualNodes.put(<span class="built_in">hash</span>, virtualNodeName);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         System.out.println();</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     //使用FNV1_32_HASH算法计算服务器的Hash值,这里不使用重写hashCode的方法，最终效果没区别</span><br><span class="line">     private static int getHash(String str)&#123;</span><br><span class="line">         final int p = 16777619;</span><br><span class="line">         int <span class="built_in">hash</span> = (int)2166136261L;</span><br><span class="line">         <span class="keyword">for</span> (int i = 0; i &lt; str.length(); i++)</span><br><span class="line">             <span class="built_in">hash</span> = (<span class="built_in">hash</span> ^ str.charAt(i)) * p;</span><br><span class="line">         <span class="built_in">hash</span> += <span class="built_in">hash</span> &lt;&lt; <span class="string">13;</span></span><br><span class="line"><span class="string">         hash ^= hash &gt;&gt; 7;</span></span><br><span class="line"><span class="string">         hash += hash &lt;&lt; 3;</span></span><br><span class="line"><span class="string">         hash ^= hash &gt;&gt; 17;</span></span><br><span class="line"><span class="string">         hash += hash &lt;&lt; 5;</span></span><br><span class="line"><span class="string">         </span></span><br><span class="line"><span class="string">         // 如果算出来的值为负数则取其绝对值</span></span><br><span class="line"><span class="string">         if (hash &lt; 0)</span></span><br><span class="line"><span class="string">             hash = Math.abs(hash);</span></span><br><span class="line"><span class="string">         return hash;</span></span><br><span class="line"><span class="string">     &#125;</span></span><br><span class="line"><span class="string">     </span></span><br><span class="line"><span class="string">     //得到应当路由到的结点</span></span><br><span class="line"><span class="string">     private static String getServer(String key)&#123;</span></span><br><span class="line"><span class="string">        //得到该key的hash值</span></span><br><span class="line"><span class="string">         int hash = getHash(key);</span></span><br><span class="line"><span class="string">         // 得到大于该Hash值的所有Map</span></span><br><span class="line"><span class="string">         SortedMap&lt;Integer, String&gt; subMap = virtualNodes.tailMap(hash);</span></span><br><span class="line"><span class="string">         String virtualNode;</span></span><br><span class="line"><span class="string">         if(subMap.isEmpty())&#123;</span></span><br><span class="line"><span class="string">            //如果没有比该key的hash值大的，则从第一个node开始</span></span><br><span class="line"><span class="string">            Integer i = virtualNodes.firstKey();</span></span><br><span class="line"><span class="string">            //返回对应的服务器</span></span><br><span class="line"><span class="string">            virtualNode = virtualNodes.get(i);</span></span><br><span class="line"><span class="string">         &#125;else&#123;</span></span><br><span class="line"><span class="string">            //第一个Key就是顺时针过去离node最近的那个结点</span></span><br><span class="line"><span class="string">            Integer i = subMap.firstKey();</span></span><br><span class="line"><span class="string">            //返回对应的服务器</span></span><br><span class="line"><span class="string">            virtualNode = subMap.get(i);</span></span><br><span class="line"><span class="string">         &#125;</span></span><br><span class="line"><span class="string">         //virtualNode虚拟节点名称要截取一下</span></span><br><span class="line"><span class="string">         if(StringUtils.isNotBlank(virtualNode))&#123;</span></span><br><span class="line"><span class="string">             return virtualNode.substring(0, virtualNode.indexOf(&quot;&amp;&amp;&quot;));</span></span><br><span class="line"><span class="string">         &#125;</span></span><br><span class="line"><span class="string">         return null;</span></span><br><span class="line"><span class="string">     &#125;</span></span><br><span class="line"><span class="string">     </span></span><br><span class="line"><span class="string">     public static void main(String[] args)&#123;</span></span><br><span class="line"><span class="string">         String[] keys = &#123;&quot;太阳&quot;, &quot;月亮&quot;, &quot;星星&quot;&#125;;</span></span><br><span class="line"><span class="string">         for(int i=0; i&lt;keys.length; i++)</span></span><br><span class="line"><span class="string">             System.out.println(&quot;[&quot; + keys[i] + &quot;]的hash值为&quot; +</span></span><br><span class="line"><span class="string">                     getHash(keys[i]) + &quot;, 被路由到结点[&quot; + getServer(keys[i]) + &quot;]&quot;);</span></span><br><span class="line"><span class="string">     &#125;</span></span><br><span class="line"><span class="string"> &#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>执行结果：<br>虚拟节点[192.168.0.0:111&amp;&amp;VN0]被添加, hash值为1686427075<br>虚拟节点[192.168.0.0:111&amp;&amp;VN1]被添加, hash值为354859081<br>虚拟节点[192.168.0.0:111&amp;&amp;VN2]被添加, hash值为1306497370<br>虚拟节点[192.168.0.0:111&amp;&amp;VN3]被添加, hash值为817889914<br>虚拟节点[192.168.0.0:111&amp;&amp;VN4]被添加, hash值为396663629<br>虚拟节点[192.168.0.1:111&amp;&amp;VN0]被添加, hash值为1032739288<br>虚拟节点[192.168.0.1:111&amp;&amp;VN1]被添加, hash值为707592309<br>虚拟节点[192.168.0.1:111&amp;&amp;VN2]被添加, hash值为302114528<br>虚拟节点[192.168.0.1:111&amp;&amp;VN3]被添加, hash值为36526861<br>虚拟节点[192.168.0.1:111&amp;&amp;VN4]被添加, hash值为848442551<br>虚拟节点[192.168.0.2:111&amp;&amp;VN0]被添加, hash值为1452694222<br>虚拟节点[192.168.0.2:111&amp;&amp;VN1]被添加, hash值为2023612840<br>虚拟节点[192.168.0.2:111&amp;&amp;VN2]被添加, hash值为697907480<br>虚拟节点[192.168.0.2:111&amp;&amp;VN3]被添加, hash值为790847074<br>虚拟节点[192.168.0.2:111&amp;&amp;VN4]被添加, hash值为2010506136<br>虚拟节点[192.168.0.3:111&amp;&amp;VN0]被添加, hash值为891084251<br>虚拟节点[192.168.0.3:111&amp;&amp;VN1]被添加, hash值为1725031739<br>虚拟节点[192.168.0.3:111&amp;&amp;VN2]被添加, hash值为1127720370<br>虚拟节点[192.168.0.3:111&amp;&amp;VN3]被添加, hash值为676720500<br>虚拟节点[192.168.0.3:111&amp;&amp;VN4]被添加, hash值为2050578780<br>虚拟节点[192.168.0.4:111&amp;&amp;VN0]被添加, hash值为586921010<br>虚拟节点[192.168.0.4:111&amp;&amp;VN1]被添加, hash值为184078390<br>虚拟节点[192.168.0.4:111&amp;&amp;VN2]被添加, hash值为1331645117<br>虚拟节点[192.168.0.4:111&amp;&amp;VN3]被添加, hash值为918790803<br>虚拟节点[192.168.0.4:111&amp;&amp;VN4]被添加, hash值为1232193678</p><p>[太阳]的hash值为1977106057, 被路由到结点[192.168.0.2:111]<br>[月亮]的hash值为1132637661, 被路由到结点[192.168.0.4:111]<br>[星星]的hash值为880019273, 被路由到结点[192.168.0.3:111]</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 一致性Hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis集群与分区</title>
      <link href="/blog/2021/06/30/Redis%E9%9B%86%E7%BE%A4%E5%92%8C%E5%88%86%E5%8C%BA/"/>
      <url>/blog/2021/06/30/Redis%E9%9B%86%E7%BE%A4%E5%92%8C%E5%88%86%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis集群与分区"><a href="#Redis集群与分区" class="headerlink" title="Redis集群与分区"></a>Redis集群与分区</h1><h1 id="一、为什么需要引入Redis集群与分区"><a href="#一、为什么需要引入Redis集群与分区" class="headerlink" title="一、为什么需要引入Redis集群与分区"></a>一、为什么需要引入Redis集群与分区</h1><p>&emsp;&emsp;我们之前讲了很多Redis的内容，但是都是从单体的维度上讲的，从本篇开始，我们开始了解Redis集群以及相关的一些内容。那么首先有一个问题：Redis单体的QPS就已经非常高了，那为什么还需要集群化部署呢？</p><p>&emsp;&emsp;a、集群化部署是出于安全性考虑，如果仅仅存在单个Redis服务，那么当Redis服务发生宕机的时候，那么所有客户端直接无法访问，对业务会造成很大影响。同时，如果硬件方面发生损坏，那么数据直接无法恢复，会对系统造成灾难性的损伤。</p><p>&emsp;&emsp;b、虽然Redis单体的QPS就已经非常高，但是如果遇到高并发甚至超高并发的情况下，性能还是会受到影响。此时，多个Redis服务就能有效缓解单体Redis的压力。</p><p>&emsp;&emsp;c、此外出于存储的考虑，由于 Redis 所有的数据都放在内存中，如果数据量大，很容易受到硬件的限制。升级硬件收效和成本比太低，所以我们需要有一种横向扩展的方法，使用分片技术，把数据分配到一个个集群Redis组中。</p><h1 id="二、Redis的主从复制"><a href="#二、Redis的主从复制" class="headerlink" title="二、Redis的主从复制"></a>二、Redis的主从复制</h1><p>&emsp;&emsp;主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)。数据的复制是单向的，只能由主节点到从节点。主节点负责写操作，从节点负责读操作。主从复制把数据复制多个副本部署到其他节点上，从而实现Redis的高可用性，实现对数据的冗余备份，保证数据和服务的高度可靠性。</p><h2 id="1、主从复制的优缺点"><a href="#1、主从复制的优缺点" class="headerlink" title="1、主从复制的优缺点"></a>1、主从复制的优缺点</h2><h3 id="1-1、优点"><a href="#1-1、优点" class="headerlink" title="1.1、优点"></a>1.1、优点</h3><blockquote><ul><li>避免Redis单点故障；</li><li>构建读写分离架构，满足读多写少的应用场景。</li></ul></blockquote><h3 id="1-2、缺点"><a href="#1-2、缺点" class="headerlink" title="1.2、缺点"></a>1.2、缺点</h3><blockquote><ul><li>RDB文件过大时，同步耗时；</li><li>在一主一从或者一主多从情况下，如果主节点挂了，对外提供的写服务就是不可用了（从节点仍然可以对外提供读服务），单点问题没有解决，需要手动进行主从的切换才行，但是这样比较费事费力，还会导致服务一段时间不可用。所以可以使用哨兵模式来实现自动的主从切换和故障转移。</li></ul></blockquote><h2 id="2、主从复制相关概念"><a href="#2、主从复制相关概念" class="headerlink" title="2、主从复制相关概念"></a>2、主从复制相关概念</h2><blockquote><ol><li>每个Redis单体默认都是一个master，一个master订阅了其他master就会转换为slave，一个master可以拥有多个slave；</li><li>master的复制是<strong>异步非阻塞</strong>的，一个slave可以接受另外的slave的连接，组成主从从的形态；</li><li>客户端可以使用 wait 命令请求同步复制某些特定数据；</li><li>正常连接情况下，master通过命令流来保持对slave的数据更新；</li><li>当master与slave之间得到连接断开，slave在尝试与master重连后，会尝试获取与master断开期间丢失的命令流；</li><li>在断开期间的数据无法重新同步时，slave会请求全量更新，master将以rdb快照方式将全量数据推送给slave，之后再进行增量更新。</li></ol></blockquote><h2 id="3、主从复制原理"><a href="#3、主从复制原理" class="headerlink" title="3、主从复制原理"></a>3、主从复制原理</h2><p>&emsp;&emsp;在slave节点第一次与master连接时和断线重连时（ master 判断 runid 是否一致）会执行全量复制，此时master节点通过bgsave命令在本地生成一个RDB数据快照文件，然后将RDB文件通过Socket连接传送给从节点，然后从节点先清空自身数据，然后使用接收到的RDB文件加载数据。</p><p>&emsp;&emsp;而对于其他时候，slave节点会采取一种增量复制的方式进行主从复制。每个master都有一个replicationId（runid）用来表示与slave处于同一个主从复制中；同时存在一个偏移量，用来记录上次发送给slave的数据，每次复制数据后该偏移量都会增加，即使没有slave链接master ，它的offset也会增加。一对Replication ID, offset表示一个版本的数据。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/202009151648211.png" alt="202009151648211"></p><blockquote><p>主从复制的详细流程（了解）:</p><ol><li><p>从节点发送指令psync ? -1 psync runid offset找对应的runid的节点索取数据，但是这里有一个问题，当从节点第一次连接的时候根本就不知道主节点的runid 和offset 。所以第一次发送的指令是psync ？-1，意思就是主节点的数据需要全部同步过来。</p></li><li><p>主节点开始执行bgsave生成RDB文件，记录当前的复制偏移量offset。</p></li><li><p>主节点把自己的runid和offset通过+FULLRESYNC runid offset指令发送给从节点，然后通过socket发送RDB文件也发送给从节点。在这个阶段内可能主节点会收到客户端的指令，offset发生了变化。</p></li><li><p>从节点接收到主节点的runid和offset并将其保存下来，然后清空数据库当前所有数据，通过socket接收RDB文件，开始恢复RDB数据（全量复制）。</p></li><li><p>在全量复制后，从节点已经获取到了主节点的runid和offset，开始发送指令psync runid offset。</p></li><li><p>主节点接收指令，判断runid是否匹配，同时判断offset是否在复制缓冲区中。</p></li><li><p>主节点判断runid和offset，若有一个不满足，就会在返回到步骤2继续执行全量复制。这里runid不匹配的原因可能是从节点意外重启，offset（偏移量）不匹配的原因是复制缓冲区溢出了。如果runid或offset校验通过，从节点的offset和主节点的offset相同时则忽略，如果从节点的offset与主节点的offset不相同，则主节点会发送+CONTINUE offset（这个offset为主节点的）命令，通过socket发送复制缓冲区中以从节点offset开始到主节点offset结束的操作（实际上就是从节点与主节点相比少执行的操作）。</p></li><li><p>从节点收到主节点发送的offset并且通过socket接收到信息后，执行bgrewriteaof，恢复数据。</p></li></ol><p>   参考【<a href="https://blog.csdn.net/weixin_43907422/article/details/105835347">链接</a>】</p></blockquote><h2 id="4、主从复制的操作流程"><a href="#4、主从复制的操作流程" class="headerlink" title="4、主从复制的操作流程"></a>4、主从复制的操作流程</h2><h3 id="4-1、准备操作"><a href="#4-1、准备操作" class="headerlink" title="4.1、准备操作"></a>4.1、准备操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建redis-cluster文件夹，用来存放集群测试的配置文件</span></span><br><span class="line">mkdir redis-cluster &amp;&amp; cp ./redis.conf ./redis-cluster/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改配置文件名称</span></span><br><span class="line">mv redis.conf redis_6379.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改配置，这里修改结束后以同样的方式拷贝6380和6381的配置文件，并修改端口和pid</span></span><br><span class="line">vim redis_6379.conf</span><br><span class="line">------------------ redis_6379.conf 开始---------------------</span><br><span class="line"><span class="comment"># Redis使用控制台模式（方便观察日志）</span></span><br><span class="line">daemonize no</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭保护模式</span></span><br><span class="line">protected-mode no</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注释以下内容开启远程访问</span></span><br><span class="line"><span class="comment"># bind 127.0.0.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改启动端口为6379</span></span><br><span class="line">port 6379</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改pidfile指向路径</span></span><br><span class="line">pidfile /opt/redis/6379/redis_6379.pid</span><br><span class="line">------------------ redis_6379.conf 结束---------------------</span><br></pre></td></tr></table></figure><p>三个配置文件修改完成后如图：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210713164341234.png" alt="image-20210713164341234"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-server ./redis-cluster/redis_6379.conf</span><br><span class="line">redis-server ./redis-cluster/redis_6380.conf</span><br><span class="line">redis-server ./redis-cluster/redis_6381.conf</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210713165032921.png" alt="image-20210713165032921"></p><h3 id="4-2、执行主从复制"><a href="#4-2、执行主从复制" class="headerlink" title="4.2、执行主从复制"></a>4.2、执行主从复制</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 查看当前主从状态，可以连接redis-cli，执行命令</span></span><br><span class="line">info replication</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210713165402905.png" alt="image-20210713165402905"></p><p>我们会发现，当前我们是主节点，从节点的个数为0。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从机执行连接主机命令（5.0之前命令为 slaveof &lt;host&gt; &lt;port&gt;）</span></span><br><span class="line">replicaof &lt;host&gt; &lt;port&gt;</span><br></pre></td></tr></table></figure><p>这里我们使用6380和6381连接6379为主机，此时查看主机和从机的效果如下：</p><table><thead><tr><th align="center">ip</th><th align="center">节点角色/端口</th></tr></thead><tbody><tr><td align="center">127.0.0.1</td><td align="center">master/6379</td></tr><tr><td align="center">127.0.0.1</td><td align="center">salve/6380</td></tr><tr><td align="center">127.0.0.1</td><td align="center">slave/6381</td></tr></tbody></table><p>主机效果：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210713170319198.png" alt="image-20210713170319198"></p><p>从机效果：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210713170412376.png" alt="image-20210713170412376"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210713170612788.png" alt="image-20210713170612788"></p><p>&emsp;&emsp;此时，我们在主机添加值，在从机也可以获取到，而如果我们在从机上面添加或修改值，则会返回异常说明该服务是从机，仅限于读。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210713172028816.png" alt="image-20210713172028816"></p><h3 id="4-3、slave升级为master"><a href="#4-3、slave升级为master" class="headerlink" title="4.3、slave升级为master"></a>4.3、slave升级为master</h3><p>&emsp;&emsp;如果我们的主机发生宕机，那么会发生上面情况？我们来试一下，首先，我们关闭主机，则从机会连接master失败。此时我们查看一下从机的状态和操作。发现此时从机中对主机的状态标识DOWN，但是，我们依然无法对从机进行写操作，但是读操作正常。那么如果我们希望从机能够继续服务，那么此时我们就需要将其中一台从机切换为主机，并让另一台从机去跟随它。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210713172958219.png" alt="image-20210713172958219"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210713173142785.png" alt="image-20210713173142785"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换从机为主机的命令</span></span><br><span class="line">replicaof no one</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210713173555329.png" alt="image-20210713173555329"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210713173630966.png" alt="image-20210713173630966"></p><p><strong>附：主从复制的一些相关配置</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># slave在首次接收master数据时，可以在slave中配置同步期间是否接收旧数据的访问，在首次同步之后，旧数据会被删除，然后再主线程加载新数据，此时slave会阻塞</span></span><br><span class="line">replica-serve-stale-data yes  </span><br><span class="line"></span><br><span class="line"><span class="comment">#从节点是否开启只读模式</span></span><br><span class="line">replica-read-only yes </span><br><span class="line"></span><br><span class="line"><span class="comment">#是否采用无磁盘模式传输，no表示走磁盘，yes走网络传输</span></span><br><span class="line">repl-diskless-sync no </span><br><span class="line"></span><br><span class="line"><span class="comment">#增量复制，当redis挂掉之后又恢复，主节点可以增量传输数据过来，但是增量的数据与当前的数据存在偏差，从节点可以通过传送offset从主节点再次拉回数据，此配置大小会关系到redis内存维护的队列大小，此操作的成功与否，数据量大于这个值会造成溢出</span></span><br><span class="line"><span class="comment"># repl-backlog-size 1mb </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果至少有 3 个 slave ，并且滞后小于 10 秒，则写入将被接受,如果条件不满足master的写操作将被拒绝。</span></span><br><span class="line"><span class="comment"># min-replicas-to-write 3</span></span><br><span class="line"><span class="comment"># min-replicas-max-lag 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果master节点设置了密码，需要在此处进行配置对应表的访问密码</span></span><br><span class="line"><span class="comment"># masterauth &lt;master-password&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置追随的master节点</span></span><br><span class="line"><span class="comment"># replicaof &lt;masterip&gt; &lt;masterport&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-4、总结"><a href="#4-4、总结" class="headerlink" title="4.4、总结"></a>4.4、总结</h3><p><strong>4.4.1、Redis配置主从复制的方式</strong></p><blockquote><ul><li><p>在进入6380、6381客户端，使用<code>replicaof host port</code>命令（5.0之前命令为<code>slaveof host port</code>），让从节点追随主节点；</p></li><li><p>在启动服务端时，使用<code>redis-server ./6380.conf --replicaof host port</code>命令，让从节点追随主节点；</p></li><li><p>在配置文件指定  replicaof <masterip> <masterport>。</p></li></ul></blockquote><p><strong>4.4.2、从节点追随主节点之后，旧数据会被删除，同时非阻塞方式同步主节点数据；</strong></p><p><strong>4.4.3、从节点只能读，不能写（可通过修改配置改变）；</strong></p><p><strong>4.4.4、主节点出现故障时，需要人工维护升级新的主节点。</strong></p><h1 id="三、哨兵模式"><a href="#三、哨兵模式" class="headerlink" title="三、哨兵模式"></a>三、哨兵模式</h1><p>&emsp;&emsp;我们上面讲到，虽然主从复制能够帮助我们解决单点故障和读写分离的问题。但与此同时，他也存在一个明显的问题，当主节点发生故障时，需要人工维护升级新的主节点才能恢复写的操作。这在正式环境下是不太可取的，如果需要等待人工维护的时间，以及需要维护的节点数量，都可能会导致服务的不可用。所以此时需要有一个服务，来帮我们监控主从节点的状态，并及时切换异常的节点，那么哨兵模式诞生了。</p><h2 id="1、为什么需要哨兵模式"><a href="#1、为什么需要哨兵模式" class="headerlink" title="1、为什么需要哨兵模式"></a>1、为什么需要哨兵模式</h2><blockquote><p>哨兵(Sentinel)主要是为了解决在主从复制架构中出现宕机的情况,主要分为两种情况：</p><p>1、Redis Slave宕机：</p><ul><li>这个相对而言比较简单，在Redis中从库重新启动后会自动加入到主从架构中,自动完成同步数据；</li><li>在Redis2.8版本后，主从断线后恢复 的情况下实现增量复制。 </li></ul><p>2、Redis Master宕机： </p><ul><li>第一步,在从数据库中执行SLAVEOF NO ONE命令，断开主从关系并且提升为主库继续服务；</li><li>第二步,将主库重新启动后，执行SLAVEOF命令,将其设置为其他库的从库,这时数据就能更新回来 。</li></ul><p>由于这个手动完成恢复的过程其实是比较麻烦的并且容易出错,所以Redis提供的哨兵(sentinel)的功能来解决。</p></blockquote><h2 id="2、什么是Redis-哨兵模式"><a href="#2、什么是Redis-哨兵模式" class="headerlink" title="2、什么是Redis 哨兵模式"></a>2、什么是Redis 哨兵模式</h2><p>&emsp;&emsp;Redis哨兵模式是用于管理Redis集群，它<strong>本质上也是Redis，一个特殊的Redis</strong>。它主要执行以下三个任务：</p><blockquote><ol><li>监控(Monitoring):Sentinel会不断地检查你的主服务器和从服务器是否运作正常；</li><li>提醒(Notification):当被监控的某个Redis服务器出现问题时,Sentinel可以通过API向管理员或者其他应用程序发送通知；</li><li>自动故障迁移(Automatic failover):当一个主服务器不能正常工作时,Sentinel 会开始一次自动故障迁移操作,它会将失效的主服务器的其中一个从服务器升级为新的主服务器,并让失效主服务器的其他从服务器改为复制新的主服务器;当客户端试图连接失效的主服务器时,集群也会向客户端返回新主服务器的地址,使得集群可以使用新主服务器代替失效服务器。</li></ol></blockquote><h2 id="3、Sentinel集群与相互发现"><a href="#3、Sentinel集群与相互发现" class="headerlink" title="3、Sentinel集群与相互发现"></a>3、Sentinel集群与相互发现</h2><p>&emsp;&emsp;我们在日常使用中，为了实现Sentinel的高可用，一般情况下也会部署Sentinel集群，如下图。那么Sentinel之间是如何相互发现呢？</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210714113733821.png" alt="image-20210714113733821"></p><blockquote><ul><li>每个Sentinel会以每两秒一次的频率，通过发布与订阅功能，向被它监视的所有master和slave的 sentinel:hello 频道发送一条信息。信息中包含了该Sentinel的IP 地址、端口号和运行ID （runid）。</li><li>每个Sentinel都订阅了被它监视的所有master和slave的sentinel:hello 频道,查找之前未出现过的sentinel（looking for unknown sentinels）。当一个Sentinel 发现一个新的Sentinel时，它会将新的Sentinel添加到一个列表中，这个列表保存了Sentinel已知的，监视同一个主服务器的所有其他Sentinel。</li><li>Sentinel 发送的信息中还包括完整的主服务器当前配置（configuration）。 如果一个 Sentinel 包含的主服务器配置比另一个 Sentinel 发送的配置要旧， 那么这个 Sentinel 会立即升级到新配置上。</li><li>将一个新Sentinel添加到监视主服务器的列表上面之前，Sentinel会先检查列表中是否已经包含了和要添加的Sentinel拥有相同运行ID或者相同地址（包括IP地址和端口号）的 Sentinel ，如果是的话，Sentinel会先移除列表中已有的那些拥有相同运行ID或者相同地址的Sentinel， 然后再添加新Sentinel。</li></ul></blockquote><h2 id="4、Sentinel对master的故障判定与master的选举"><a href="#4、Sentinel对master的故障判定与master的选举" class="headerlink" title="4、Sentinel对master的故障判定与master的选举"></a>4、Sentinel对master的故障判定与master的选举</h2><blockquote><p><strong>故障判定：</strong></p><p>&emsp;&emsp;Sentinel会以每秒钟一次的频率向它所知的master、slave以及其他 Sentinel 实例发送一个 PING 命令,如果距离最后一次有效回复 PING 命令的时间超过 <code>down-after-milliseconds</code> 选项所指定的值，那么这个实例会被 Sentinel 标记为主观下线。一个有效回复可以是：+PONG 、-LOADING 或者 -MASTERDOWN ，其它回复或者没有回复都算是无效回复。</p><p>&emsp;&emsp;当master标记为ODOWN(主观下线)后，会通过向另一个 Sentinel 发送 SENTINEL is-master-down-by-addr 命令来询问对方是否认为给定的服务器已下线。此时会有以下两种情况：</p><ul><li>当有足够数量的 Sentinel（至少要达到配置文件指定的数量quorum）在指定的时间范围内同意这一判断， 那么这个主服务器被标记为客观下线。</li><li>当没有足够数量的 Sentinel 同意主服务器已经下线， 主服务器的客观下线状态就会被移除。 当主服务器重新向 Sentinel 的 PING 命令返回有效回复时， 主服务器的主观下线状态就会被移除。</li></ul><p>&emsp;&emsp;在一般情况下， 每个 Sentinel 会以每 10 秒一次的频率向它已知的所有master和slave发送 INFO 命令。 当一个master被 Sentinel 标记为客观下线时， Sentinel 向下线master的所有slave发送 INFO 命令的频率会从 10 秒一次改为每秒一次。</p></blockquote><blockquote><p><strong>Master的选举：</strong></p><ol><li><p>筛选合适的从节点；</p><p>● 被标记为主观下线、已断线、或者最后一次回复 PING 命令的时间大于五秒钟的从服务器都会被淘汰；</p><p>● 与失效主服务器连接断开的时长超过 down-after-milliseconds 选项指定的时长十倍的从服务器都会被淘汰。</p></li><li><p>从筛选合格的从节点中选出复制偏移量（replication offset）最大的那个从服务器作为新的主服务器；</p></li><li><p>如果复制偏移量不可用， 或者从服务器的复制偏移量相同， 那么带有最小运行 ID 的那个从服务器成为新的主服务器。</p></li></ol></blockquote><h2 id="5、Sentinel哨兵模式的操作流程"><a href="#5、Sentinel哨兵模式的操作流程" class="headerlink" title="5、Sentinel哨兵模式的操作流程"></a>5、Sentinel哨兵模式的操作流程</h2><h3 id="5-1、配置Sentinel相关配置文件"><a href="#5-1、配置Sentinel相关配置文件" class="headerlink" title="5.1、配置Sentinel相关配置文件"></a>5.1、配置Sentinel相关配置文件</h3><p>&emsp;&emsp;在redis安装包下有一个<code>sentinel.conf</code>文件用来配置，可以根据该配置文件来配置Redis-Sentinel。以下截取几个重要的配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加守护进程模式(后台启动)</span></span><br><span class="line">daemonize yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加指明日志文件名</span></span><br><span class="line">logfile <span class="string">&quot;/usr/local/bin/redis-cluster/26379/sentinel_26379.log&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sentinel的pid文件</span></span><br><span class="line">pidfile /var/run/redis-sentinel-26379.pid</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改工作目录</span></span><br><span class="line">dir <span class="string">&quot;/usr/local/bin/redis-cluster/26379&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改启动端口</span></span><br><span class="line">port 26379</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭保护模式</span></span><br><span class="line">protected-mode no</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改sentinel需要监控的主机</span></span><br><span class="line"><span class="comment">#                监控主机的名称(自定义)  监控主机IP 监控主机端口  投票最低通过票数</span></span><br><span class="line"><span class="comment">#sentinel monitor &lt;master-name&gt;      &lt;host&gt;    &lt;port&gt;     &lt;number&gt;</span></span><br><span class="line">sentinel monitor  myMaster           127.0.0.1 6379        2</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果需要监控监控的master设置了密码，需要在此处设置</span></span><br><span class="line"><span class="comment">#sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span></span><br><span class="line">sentinel auth-pass myMaster 123456</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;本次我们创建三台sentinel哨兵来进行测试，所以需要配置三份文件。ip和端口配置如下：</p><table><thead><tr><th align="center">ip</th><th align="center">端口</th></tr></thead><tbody><tr><td align="center">127.0.0.1</td><td align="center">26379</td></tr><tr><td align="center">127.0.0.1</td><td align="center">26380</td></tr><tr><td align="center">127.0.0.1</td><td align="center">26381</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在redis-cluster创建文件夹并创建sentinel配置文件</span></span><br><span class="line">mkdir 26379 &amp;&amp; vim sentinel_26379.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加配置，并以相同的操作创建另外两台sentinel，这里为了展示日志，所以暂时注释掉守护进程和日志的配置</span></span><br><span class="line"><span class="comment"># 添加守护进程模式(后台启动)</span></span><br><span class="line"><span class="comment">#daemonize yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加指明日志文件名</span></span><br><span class="line"><span class="comment">#logfile &quot;/usr/local/bin/redis-cluster/26379/sentinel_26379.log&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sentinel的pid文件</span></span><br><span class="line">pidfile /var/run/redis-sentinel-26379.pid</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改工作目录</span></span><br><span class="line">dir <span class="string">&quot;/usr/local/bin/redis-cluster/26379&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改启动端口</span></span><br><span class="line">port 26379</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭保护模式</span></span><br><span class="line">protected-mode no</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改sentinel需要监控的主机</span></span><br><span class="line"><span class="comment">#                监控主机的名称(自定义)  监控主机IP 监控主机端口  投票最低通过票数</span></span><br><span class="line"><span class="comment">#sentinel monitor &lt;master-name&gt;      &lt;host&gt;    &lt;port&gt;     &lt;number&gt;</span></span><br><span class="line">sentinel monitor myMaster 127.0.0.1 6379 2</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210714150026381.png" alt="image-20210714150026381"></p><h3 id="5-2、启动Redis-Master和Slave"><a href="#5-2、启动Redis-Master和Slave" class="headerlink" title="5.2、启动Redis-Master和Slave"></a>5.2、启动Redis-Master和Slave</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动主机Master</span></span><br><span class="line">redis-server ./redis-cluster/redis_6379.conf</span><br><span class="line"><span class="comment"># 启动主机Slave</span></span><br><span class="line">redis-server ./redis-cluster/redis_6380.conf --replicaof 127.0.0.1 6379</span><br><span class="line">redis-server ./redis-cluster/redis_6381.conf --replicaof 127.0.0.1 6379</span><br></pre></td></tr></table></figure><h3 id="5-3、启动Redis-Sentinel集群"><a href="#5-3、启动Redis-Sentinel集群" class="headerlink" title="5.3、启动Redis-Sentinel集群"></a>5.3、启动Redis-Sentinel集群</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动方式一，使用Redis提供的redis-sentinel启动</span></span><br><span class="line">redis-sentinel ./redis-cluster/26379/sentinel_26379.conf</span><br><span class="line">redis-sentinel ./redis-cluster/26380/sentinel_26380.conf</span><br><span class="line">redis-sentinel ./redis-cluster/26381/sentinel_26381.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动方式二，使用Redis提供的redis-server启动（上面说过哨兵其实也是一种特殊的Redis）</span></span><br><span class="line">redis-server ./redis-cluster/26379/sentinel_26379.conf --sentinel</span><br><span class="line">redis-server ./redis-cluster/26380/sentinel_26380.conf --sentinel</span><br><span class="line">redis-server ./redis-cluster/26381/sentinel_26381.conf --sentinel</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210714155040815.png" alt="image-20210714155040815"></p><p>&emsp;&emsp;启动成功后，我们可以从日志中发现某一台哨兵会同时检测Master、Master对应的Slave和同时监控这个Master的其他哨兵。</p><h2 id="6、测试重新选举Master"><a href="#6、测试重新选举Master" class="headerlink" title="6、测试重新选举Master"></a>6、测试重新选举Master</h2><p>&emsp;&emsp;上面操作完成后，我们搭建的Sentinel集群就已经完成，此时我们来测试一下Master宕机的情况，看看Sentinel集群有什么操作。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210714160208921.png" alt="image-20210714160208921"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210714160352435.png" alt="image-20210714160352435"></p><p>&emsp;&emsp;我们发现，当主机宕机之后，Sentinel重新投票，选举了6381作为新的Master，并将6380和6379设置为6381的Slave。</p><h2 id="7、问题"><a href="#7、问题" class="headerlink" title="7、问题"></a>7、问题</h2><p>&emsp;&emsp;<strong>Master节点存在已经过期的key，复制到了slave，那当Master的“访问过期”和“定期过期”机制没有被触发时，该key没有被删除，客户端链接Slave查询该key时出现什么情况？</strong></p><p>&emsp;&emsp;答：Slave不会过期key，只会等待Master过期key。如果Master过期了一个key，或者通过LRU淘汰了一个key，那么会模拟一条del命令发送给Slave。</p><h1 id="四、Redis的分区"><a href="#四、Redis的分区" class="headerlink" title="四、Redis的分区"></a>四、Redis的分区</h1><p>&emsp;&emsp;分区是分割数据到多个 Redis 实例的处理过程，因此每个实例只保存key的一个子集。</p><h2 id="1、Redis分区的优点与缺点"><a href="#1、Redis分区的优点与缺点" class="headerlink" title="1、Redis分区的优点与缺点"></a>1、Redis分区的优点与缺点</h2><h3 id="1-1、优点-1"><a href="#1-1、优点-1" class="headerlink" title="1.1、优点"></a>1.1、优点</h3><p>&emsp;&emsp;上面我们讲主从复制，它解决的是Redis单体服务的安全性，而对于分区，他解决的内容有：</p><blockquote><ol><li>性能的提升，单机Redis的网络I/O能力和计算资源是有限的，将请求分散到多台机器，充分利用多台机器的计算能力可网络带宽，有助于提高Redis总体的服务能力。</li><li>存储的横向扩展，即使Redis的服务能力能够满足应用需求，但是随着存储数据的增加，单台机器受限于机器本身的存储容量，将数据分散到多台机器上存储使得Redis服务可以横向扩展。</li></ol></blockquote><h3 id="1-2、缺点-1"><a href="#1-2、缺点-1" class="headerlink" title="1.2、缺点"></a>1.2、缺点</h3><blockquote><ol><li>由于多个key不在统一的分区，所以无法使用聚合和事务操作；</li><li>动态扩容和收缩需要对数据进行再平衡（可以使用预分片解决）。</li></ol></blockquote><h2 id="2、Redis分区的相关概念"><a href="#2、Redis分区的相关概念" class="headerlink" title="2、Redis分区的相关概念"></a>2、Redis分区的相关概念</h2><h3 id="2-1、三种分区方案"><a href="#2-1、三种分区方案" class="headerlink" title="2.1、三种分区方案"></a>2.1、三种分区方案</h3><p>分区可以在程序的不同层次实现，主要的实现方案有以下三个：</p><h4 id="2-1-1、客户端分区"><a href="#2-1-1、客户端分区" class="headerlink" title="2.1.1、客户端分区"></a>2.1.1、客户端分区</h4><p>&emsp;&emsp;客户端分区就是在客户端根据一定算法或逻辑决定数据会被存储到哪个Redis节点或从哪个Redis节点读取。由客户端自己实现逻辑。</p><h4 id="2-1-2、代理分区"><a href="#2-1-2、代理分区" class="headerlink" title="2.1.2、代理分区"></a>2.1.2、代理分区</h4><p>&emsp;&emsp;客户端不需要理会如何进行分区，而是将请求发送给代理，由代理决定去哪个节点写数据或者读数据。代理根据分区规则决定请求哪些Redis实例，然后根据Redis的响应结果返回给客户端。</p><p>&emsp;&emsp;Redis的代理实现有 <strong>twemproxy、predixy 等。</strong></p><h4 id="2-1-3、查询路由-Query-routing"><a href="#2-1-3、查询路由-Query-routing" class="headerlink" title="2.1.3、查询路由(Query routing)"></a>2.1.3、查询路由(Query routing)</h4><p>&emsp;&emsp;查询路由是客户端随机地请求任意一个Redis实例，然后由Redis将请求转发给正确的Redis节点。<strong>Redis Cluster</strong>实现了一种混合形式的查询路由，但并不是直接将请求从一个Redis节点转发到另一个Redis节点，而是在客户端的帮助下直接<em>redirected</em>到正确的Redis节点。</p><h3 id="2-2、预分区"><a href="#2-2、预分区" class="headerlink" title="2.2、预分区"></a>2.2、预分区</h3><p>&emsp;&emsp;在正常运营环境中，一般所存储的数据会逐渐增加，可能今天只要10个Redis实例就能应付，但是到了一年以后就需要50个Redis实例才能支撑，因此，Redis的扩容是经常用到的功能，在Redis的分布式部署中，预分区技术是非常好用的方法之一。</p><p>&emsp;&emsp;预分区技术是指在开始时就启动足够多的Redis实例（例如32或64个，估计一下够以后扩展用就行了），等到后续需要扩容的时候，只需要将其中一部分的Redis实例转移到新增加的机子上即可，在Redis实例迁移过程中使用Redis的复制功能可以最大限度的降低Redis的停工时间甚至可以做到没有停工时间。</p><blockquote><p>预分片的操作流程：</p><ol><li>新的服务器启动新的Redis实例；</li><li>配置为需要迁移的旧Redis的slave（此操作可以同步数据）；</li><li>更新分片映射的旧实例ip为新实例ip；</li><li>客户端连接新的Redis实例执行SLAVEOF NO ONE命令，将新实例升级为master；</li><li>停止旧的Redis实例。</li></ol></blockquote><h2 id="3、数据分治"><a href="#3、数据分治" class="headerlink" title="3、数据分治"></a>3、数据分治</h2><p>&emsp;&emsp;数据分治既可以在客户端下手，也可以在Redis下手，下面将介绍几种做法：</p><h3 id="3-1、Client端处理"><a href="#3-1、Client端处理" class="headerlink" title="3.1、Client端处理"></a>3.1、Client端处理</h3><h4 id="3-1-1、逻辑处理"><a href="#3-1-1、逻辑处理" class="headerlink" title="3.1.1、逻辑处理"></a>3.1.1、逻辑处理</h4><p>&emsp;&emsp;我们可以根据我们的业务逻辑，将不同逻辑的数据存储到不同的Redis实例中。但由于业务的复杂性，在很多场景下并不能简单的根据逻辑进行拆分。所以这种方案对数据特征有很大的要求，限制性较大。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/2020100319465922.jpg" alt="2020100319465922"></p><h4 id="3-1-2、Hash算法与一致性Hash"><a href="#3-1-2、Hash算法与一致性Hash" class="headerlink" title="3.1.2、Hash算法与一致性Hash"></a>3.1.2、Hash算法与一致性Hash</h4><p>&emsp;&emsp;如果数据不可以简单的根据逻辑拆分，我们可以使用各种<strong>映射算法</strong>，让数据按照一定的规则映射、保存在不同的 Redis 服务实例上。映射算法中我们最常用的就是 Hash 算法。但是，Hash算法有一个天生的缺陷，如果增加或减少机器，由于取模改变导致所有的数据会发生偏移，导致大部分数据都会查询不到，如果出现高并发，则会发生缓存雪崩的情况。所以此时就需要引入一致性Hash，一致性Hash会将数据和机器映射到一个Hash环中，通过数据在Hash环中顺时针寻找最近的节点获取存储的物理节点，这样做就不用担心增加或减少节点导致的数据雪崩情况。Hash算法和一致性Hash具体内容查看【<a href="http://cheng_qiwei.gitee.io/blog/2021/07/10/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E5%88%86%E5%8C%BA%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94Hash%E4%B8%8E%E4%B8%80%E8%87%B4%E6%80%A7Hash/">链接</a>】。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/20201003194726380.jpg" alt="在这里插入图片描述"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/20201003194811710.jpg" alt="在这里插入图片描述"></p><h3 id="3-2、Server端处理"><a href="#3-2、Server端处理" class="headerlink" title="3.2、Server端处理"></a>3.2、Server端处理</h3><p>&emsp;&emsp;我们上面讲到的几种操作，都是直接通过客户端的逻辑代码实现，那么，此时就会出现下面的问题：如图，我们的客户端服务一般都不会只有一个，可能会有多个，而且每个客户端根据实际情况可能还会出现集群，那么就会有大量的客户端与Redis实例进行连接，此时server端就需要处理大量的socket请求，造成server端的压力。所以此时我们可以考虑<strong>引入代理</strong>来解决这个问题。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/20201003194906655.jpg" alt="在这里插入图片描述"></p><h4 id="3-2-1、代理与负载均衡"><a href="#3-2-1、代理与负载均衡" class="headerlink" title="3.2.1、代理与负载均衡"></a>3.2.1、代理与负载均衡</h4><p>&emsp;&emsp;既然由server端直接处理连接时压力过大，那么我们就可以考虑引入代理端来处理。server端代理层能够保证 server 端压力不要过大，此时需要关注的点就是代理层如何保证高性能，以及保证可用性，那我们就可以引入负载均衡来保证高性能，并使用主备关系来保证可用性。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/20201003194921341.jpg" alt="在这里插入图片描述"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/202010031949420.jpg" alt="在这里插入图片描述"></p><h3 id="3-3、哈希槽"><a href="#3-3、哈希槽" class="headerlink" title="3.3、哈希槽"></a>3.3、哈希槽</h3><p>&emsp;&emsp;对于以上的所有方案，Redis都是适合当作缓存来用，而不能当作数据库使用。这是因为这些方式对于数据分布、节点位置的控制并不是很友好。为了将 Redis用作分布式数据库，所以就需要使用我们上面说的预分区。而Redis集群（cluster）使用哈希槽（slot），就能够解决数据分布和节点控制的问题。</p><p>&emsp;&emsp;其实哈希槽的本质和一致性哈希算法非常相似，不同点就是对于哈希空间的定义。一致性哈希的空间是一个圆环，节点分布是基于圆环的，无法很好的控制数据分布。而 Redis cluster 的槽位空间是自定义分配的，类似于 windows 盘分区的概念。这种分区是可以自定义大小，自定义位置的。</p><p>&emsp;&emsp;Redis cluster 包含了<strong>16384个哈希槽</strong>，每个 key 通过计算后都会落在具体一个槽位上，而这个槽位是属于哪个存储节点的，则由用户自己定义分配。如果机器硬盘小的，可以分配少一点槽位，硬盘大的可以分配多一点。如果节点硬盘都差不多则可以平均分配。<strong>所以哈希槽这种概念很好地解决了一致性哈希的弊端</strong>。</p><p><strong>&emsp;&emsp;每当有新节点加入时，它不再需要像一致性Hash算法那样把每个 key 取出来重新计算 Hash 值，只需要从旧节点中将新节点应该缓存的槽位数据拷贝到新节点中即可。</strong></p><p>&emsp;&emsp;而在容错性和扩展性上，表象与一致性哈希一样，都是对受影响的数据进行转移。而哈希槽本质上是对槽位的转移，把故障节点负责的槽位转移到其他正常的节点上。扩展节点也是一样，把其他节点上的槽位转移到新的节点上。</p><p>&emsp;&emsp;而对于<strong>弊端是聚合操作很难实现，并且不支持跨机器事务</strong>，但是提供了Hash Tag让用户控制需要计算的Key都集中在一个Redis中。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/20201003195043513.jpg" alt="在这里插入图片描述"></p><h2 id="4、分区的实现方式"><a href="#4、分区的实现方式" class="headerlink" title="4、分区的实现方式"></a>4、分区的实现方式</h2><h3 id="4-1、代理分区——TwemProxy"><a href="#4-1、代理分区——TwemProxy" class="headerlink" title="4.1、代理分区——TwemProxy"></a>4.1、代理分区——TwemProxy</h3><blockquote><p>TwemProxy官方地址： <a href="https://github.com/twitter/twemproxy">https://github.com/twitter/twemproxy</a></p></blockquote><h4 id="4-1-1、安装"><a href="#4-1-1、安装" class="headerlink" title="4.1.1、安装"></a>4.1.1、安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载安装包</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/twitter/twemproxy.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成configure文件</span></span><br><span class="line"><span class="built_in">cd</span> twemproxy &amp;&amp; autoreconf -fvi</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装或更新插件(centOS7自带有，可忽略)</span></span><br><span class="line">yum install automake libtool -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">./configure --enable-debug=full &amp;&amp; make</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;到上面为止，我们的安装已经结束。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面的操作是为了之后可以使用service twemproxy start/stop等命令操作</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/twemproxy/scripts &amp;&amp; cp nutcracker.init /etc/init.d/twemproxy</span><br><span class="line"><span class="built_in">cd</span> /etc/init.d/ &amp;&amp; chmod +x twemproxy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据脚本准备对应配置文件 OPTIONS=&quot;-d -c /etc/nutcracker/nutcracker.yml&quot;</span></span><br><span class="line">mkdir /etc/nutcracker &amp;&amp; cp /usr/<span class="built_in">local</span>/twemproxy/conf/* /etc/nutcracker/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置操作系统任意地方可以使用nutcracker命令。</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/twemproxy/src &amp;&amp; cp nutcracker /usr/bin</span><br></pre></td></tr></table></figure><h4 id="4-1-2、配置TwemProxy"><a href="#4-1-2、配置TwemProxy" class="headerlink" title="4.1.2、配置TwemProxy"></a>4.1.2、配置TwemProxy</h4><p>&emsp;&emsp;配·置<code>nutcracker.yml</code>文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 复制配置文件</span></span><br><span class="line"><span class="built_in">cd</span> /etc/nutcracker/ &amp;&amp; cp nutcracker.yml nutcracker.yml.bak</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改配置</span></span><br><span class="line">vim nutcracker.yml</span><br><span class="line"></span><br><span class="line">alpha:</span><br><span class="line">  listen: 127.0.0.1:22121</span><br><span class="line">  Hash: fnv1a_64</span><br><span class="line">  distribution: ketama</span><br><span class="line">  auto_eject_hosts: <span class="literal">true</span></span><br><span class="line">  redis: <span class="literal">true</span></span><br><span class="line">  server_retry_timeout: 2000</span><br><span class="line">  server_failure_limit: 1</span><br><span class="line">  servers:</span><br><span class="line">   - 127.0.0.1:6379:1 <span class="comment">#1指的是权重</span></span><br><span class="line">   - 127.0.0.1:9380:1</span><br><span class="line">   - 127.0.0.1:9381:1</span><br></pre></td></tr></table></figure><h4 id="4-1-3、使用TwemProxy"><a href="#4-1-3、使用TwemProxy" class="headerlink" title="4.1.3、使用TwemProxy"></a>4.1.3、使用TwemProxy</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先启动Redis实例</span></span><br><span class="line"><span class="comment"># 启动 TwemProxy</span></span><br><span class="line">service twemproxy start</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210718163444299.png" alt="image-20210718163444299"></p><h4 id="4-1-4、通过代理TwemProxy连接Redis"><a href="#4-1-4、通过代理TwemProxy连接Redis" class="headerlink" title="4.1.4、通过代理TwemProxy连接Redis"></a>4.1.4、通过代理TwemProxy连接Redis</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#数据分区，不支持keys、watch、MULTI等命令</span></span><br><span class="line">redis-cli -p 22121</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210718163919115.png" alt="image-20210718163919115"></p><h3 id="4-2、代理分区——Predixy"><a href="#4-2、代理分区——Predixy" class="headerlink" title="4.2、代理分区——Predixy"></a>4.2、代理分区——Predixy</h3><blockquote><p>中文文档：<a href="https://github.com/joyieldInc/predixy/blob/master/README_CN.md">https://github.com/joyieldInc/predixy/blob/master/README_CN.md</a></p></blockquote><h4 id="4-2-1、安装Predixy"><a href="#4-2-1、安装Predixy" class="headerlink" title="4.2.1、安装Predixy"></a>4.2.1、安装Predixy</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载安装包</span></span><br><span class="line">wget https://github.com/joyieldInc/predixy/releases/download/1.0.5/predixy-1.0.5-bin-amd64-linux.tar.gz</span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar xf predixy-1.0.5-bin-amd64-linux.tar.gz -C /usr/<span class="built_in">local</span></span><br></pre></td></tr></table></figure><h4 id="4-2-2、配置Predixy"><a href="#4-2-2、配置Predixy" class="headerlink" title="4.2.2、配置Predixy"></a>4.2.2、配置Predixy</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改配置文件</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/predixy-1.0.5/conf &amp;&amp; vim predixy.conf </span><br><span class="line">--------------------------------------- predixy.conf开始 ----------------------------------------------------</span><br><span class="line"><span class="comment">################################### GENERAL ####################################</span></span><br><span class="line"><span class="comment"># 开放predixy绑定的ip端口</span></span><br><span class="line">Bind 127.0.0.1:7617</span><br><span class="line"><span class="comment"># Bind 0.0.0.0:7617</span></span><br><span class="line"><span class="comment"># Bind /tmp/predixy</span></span><br><span class="line"><span class="comment">################################### SERVERS，这里几种配置只开启一种 ####################</span></span><br><span class="line"><span class="comment"># Include cluster.conf</span></span><br><span class="line"><span class="comment">#加载sentinel相关配置</span></span><br><span class="line">Include sentinel.conf</span><br><span class="line"><span class="comment"># Include try.conf</span></span><br><span class="line">--------------------------------------- predixy.conf结束 ----------------------------------------------------</span><br><span class="line"><span class="comment"># 修改predixy的sentinel配置</span></span><br><span class="line">vim sentinel.conf</span><br><span class="line">--------------------------------------- sentinel.conf开始 ---------------------------------------------------</span><br><span class="line">SentinelServerPool &#123;</span><br><span class="line">    Databases 16</span><br><span class="line">    Hash crc16</span><br><span class="line">    HashTag <span class="string">&quot;&#123;&#125;&quot;</span></span><br><span class="line">    Distribution modula</span><br><span class="line">    MasterReadPriority 60</span><br><span class="line">    StaticSlaveReadPriority 50</span><br><span class="line">    DynamicSlaveReadPriority 50</span><br><span class="line">    RefreshInterval 1</span><br><span class="line">    ServerTimeout 1</span><br><span class="line">    ServerFailureLimit 10</span><br><span class="line">    ServerRetryTimeout 1</span><br><span class="line">    KeepAlive 120</span><br><span class="line">    Sentinels &#123;</span><br><span class="line">        + 127.0.0.1:26379  <span class="comment">#配置哨兵节点</span></span><br><span class="line">        + 127.0.0.1:26380  <span class="comment">#配置哨兵节点</span></span><br><span class="line">        + 127.0.0.1:26381  <span class="comment">#配置哨兵节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    Group mySentinel001 &#123; <span class="comment">#配置redis主从分组名</span></span><br><span class="line">    &#125;</span><br><span class="line">    Group mySentinel002 &#123; <span class="comment">#配置redis主从分组名</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------- sentinel.conf结束 ---------------------------------------------------</span><br></pre></td></tr></table></figure><h4 id="4-2-3、配置sentinel"><a href="#4-2-3、配置sentinel" class="headerlink" title="4.2.3、配置sentinel"></a>4.2.3、配置sentinel</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">--------------------------------- sentinel_26379.conf配置 ---------------------------------------------------</span><br><span class="line">port 26379</span><br><span class="line">sentinel monitor mySentinel001 127.0.0.1 36379 2</span><br><span class="line">sentinel monitor mySentinel002 127.0.0.1 46379 2</span><br><span class="line">daemonize yes</span><br><span class="line">--------------------------------- sentinel_26380.conf配置 ---------------------------------------------------</span><br><span class="line">port 26380</span><br><span class="line">sentinel monitor mySentinel001 127.0.0.1 36379 2</span><br><span class="line">sentinel monitor mySentinel002 127.0.0.1 46379 2</span><br><span class="line">daemonize yes</span><br><span class="line">--------------------------------- sentinel_26381.conf配置 ---------------------------------------------------</span><br><span class="line">port 26381</span><br><span class="line">sentinel monitor mySentinel001 127.0.0.1 36379 2</span><br><span class="line">sentinel monitor mySentinel002 127.0.0.1 46379 2</span><br><span class="line">daemonize yes</span><br></pre></td></tr></table></figure><p><strong>启动sentinel</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-server sentinel_26379.conf --sentinel</span><br><span class="line">redis-server sentinel_26380.conf --sentinel</span><br><span class="line">redis-server sentinel_26381.conf --sentinel</span><br></pre></td></tr></table></figure><h4 id="4-2-4、启动Redis主从"><a href="#4-2-4、启动Redis主从" class="headerlink" title="4.2.4、启动Redis主从"></a>4.2.4、启动Redis主从</h4><table><thead><tr><th align="center">主机 IP:端口</th><th align="center">从机 IP:端口</th></tr></thead><tbody><tr><td align="center">127.0.0.1:36379</td><td align="center">127.0.0.1:46380</td></tr><tr><td align="center">127.0.0.1:46379</td><td align="center">127.0.0.1:46380</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/<span class="built_in">local</span>/bin/redis-cluster/36379 &amp;&amp; <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/bin/redis-cluster/36379 &amp;&amp; redis-server --port 36379</span><br><span class="line">mkdir /usr/<span class="built_in">local</span>/bin/redis-cluster/36380 &amp;&amp; <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/bin/redis-cluster/36380 &amp;&amp; redis-server --port 36380 --replicaof 127.0.0.1 36379</span><br><span class="line">mkdir /usr/<span class="built_in">local</span>/bin/redis-cluster/46379 &amp;&amp; <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/bin/redis-cluster/46379 &amp;&amp; redis-server --port 46379</span><br><span class="line">mkdir /usr/<span class="built_in">local</span>/bin/redis-cluster/46380 &amp;&amp; <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/bin/redis-cluster/46380 &amp;&amp; redis-server --port 46380 --replicaof 127.0.0.1 46379</span><br></pre></td></tr></table></figure><p><strong>查看redis和sentinel状态<code>ps -ef|grep redis</code></strong></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210718224719609.png" alt="image-20210718224719609"></p><h4 id="4-2-5、启动Predixy"><a href="#4-2-5、启动Predixy" class="headerlink" title="4.2.5、启动Predixy"></a>4.2.5、启动Predixy</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;predixy-1.0.5&#x2F;bin &amp;&amp; .&#x2F;predixy ..&#x2F;conf&#x2F;predixy.conf</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210718225448705.png" alt="image-20210718225448705"></p><h4 id="4-2-6、连接测试Predixy"><a href="#4-2-6、连接测试Predixy" class="headerlink" title="4.2.6、连接测试Predixy"></a>4.2.6、连接测试Predixy</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 7617</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210718230109921.png" alt="image-20210718230109921"></p><h3 id="4-3、查询路由分区——Redis-Cluster（理论）"><a href="#4-3、查询路由分区——Redis-Cluster（理论）" class="headerlink" title="4.3、查询路由分区——Redis-Cluster（理论）"></a>4.3、查询路由分区——Redis-Cluster（理论）</h3><blockquote><p>无需<code>proxy</code>代理，客户端直接与<code>redis</code>集群的每个节点连接，根据同样的<code>Hash</code>算法计算出<code>key</code>对应的<code>slot</code>，然后直接在<code>slot</code>对应的<code>redis</code>节点上执行命令。</p><p>在<code>redis</code>看来，响应时间是最苛刻的条件，增加一层带来的开销是<code>redis</code>不能接受的。因此，<code>redis</code>实现了客户端对节点的直接访问，<strong>为了去中心化，节点之间通过<code>gossip</code>协议交换互相的状态，以及探测新加入的节点信息</strong>。<code>redis</code>集群支持动态加入节点，动态迁移<code>slot</code>，以及自动故障转移。</p></blockquote><h4 id="4-3-1、slot分配"><a href="#4-3-1、slot分配" class="headerlink" title="4.3.1、slot分配"></a>4.3.1、slot分配</h4><p>&emsp;&emsp;<strong>Redis集群模式使用公式 <code>CRC16(key) % 16384</code> 来计算键<code>key</code>属于哪个槽， 其中 <code>CRC16(key)</code> 语句用于计算键 <code>key</code> 的 <code>CRC16</code> 校验和 。集群中的每个节点负责处理一部分哈希槽。</strong></p><p><a href="https://yrlzero.gitee.io/images/linux/redis/redis-28.png"><img src="http://cheng_qiwei.gitee.io/blog/img/redis-28.png" alt="img"></a></p><blockquote><p>这里简单举个例子， 一个集群可以有三个节点， 其中：</p><ol><li>节点 A 负责处理 0 号至 5500 号哈希槽。</li><li>节点 B 负责处理 5501 号至 11000 号哈希槽。</li><li>节点 C 负责处理 11001 号至 16383 号哈希槽。</li></ol><p>&emsp;&emsp;此时 <code>Redis Client</code> 需要根据一个<code>Key</code>获取对应的 <code>Value</code> 的数据，首先通过 <code>CRC16(key)%16384</code> 计算出 Slot 的值，假设计算的结果是 5000，将这个数据传送给 <code>Redis Cluster</code>，集群接收到以后会到一个对照表中查找这个 <code>Slot=5000</code> 属于那个缓存节点。发现属于“节点 A ”负责，于是顺着红线的方向调用节点 A中存放的 <code>Key-Value</code> 的内容并且返回给 <code>Redis Client</code>。而这种将哈希槽分布到不同节点的做法使得用户可以很容易地向集群中添加或者删除节点。 比如说：</p><ul><li>如果用户将新节点 D 添加到集群中， 那么集群只需要将节点 A 、B 、 C 中的某些槽移动到节点 D 就可以了。</li><li>如果用户要从集群中移除节点 A ， 那么集群只需要将节点 A 中的所有哈希槽移动到节点 B 和节点 C ， 然后再移除空白（不包含任何哈希槽）的节点 A 就可以了。</li></ul></blockquote><p>&emsp;&emsp;<strong>因为将一个哈希槽从一个节点移动到另一个节点不会造成节点阻塞，且成本很低， 所以无论是添加新节点还是移除已存在节点， 又或者改变某个节点包含的哈希槽数量， 都不会造成集群下线</strong>。</p><h4 id="4-3-2、数据结构"><a href="#4-3-2、数据结构" class="headerlink" title="4.3.2、数据结构"></a>4.3.2、数据结构</h4><p>&emsp;&emsp;<code>Redis Cluster</code>中的每个节点都保存了集群的配置信息，并且存储在<code>clusterState</code>中，结构如下：</p><p><a href="https://yrlzero.gitee.io/images/linux/redis/redis-30.png"><img src="https://yrlzero.gitee.io/images/linux/redis/redis-30.png" alt="img"></a></p><p>上图的各个变量语义如下:</p><ul><li><code>clusterState</code> 记录了从集群中某个节点视角，来看集群配置状态；</li><li><code>currentEpoch</code> 表示整个集群中最大的版本号，集群信息每变更一次，改版本号都会自增。</li><li><code>nodes</code> 是一个列表，包含了本节点所感知的，集群所有节点的信息（<code>clusterNode</code>），也包含自身的信息。</li><li><code>clusterNode</code> 记录了每个节点的信息，其中包含了节点本身的版本 <code>Epoch</code>；自身的信息描述：节点对应的数据分片范围（<code>slot</code>）、为<code>master</code>时的<code>slave</code>列表、为<code>slave</code>时的<code>master</code>等。</li></ul><p>**每个节点包含一个全局唯一的<code>NodeId</code>**。</p><p>&emsp;&emsp;当集群的数据分片信息发生变更（数据在节点间迁移时），<code>Redis Cluster</code>仍然保持对外服务。</p><p>当集群中某个master出现宕机时，<code>Redis Cluster</code> 会自动发现，并触发故障转移的操作。会将<code>master</code>的某个<code>slave</code>晋升为新的 <code>master</code>。</p><p>&emsp;&emsp;由此可见，每个节点都保存着<code>Node</code>视角的集群结构。它描述了数据的分片方式，节点主备关系，并通过<code>Epoch</code>作为版本号实现集群结构信息的一致性，同时也控制着数据迁移和故障转移的过程。</p><h4 id="4-3-3、节点通信"><a href="#4-3-3、节点通信" class="headerlink" title="4.3.3、节点通信"></a>4.3.3、节点通信</h4><p>&emsp;&emsp;在<code>Redis Cluster</code>中，这个配置信息交互通过<code>Redis Cluster Bus</code>来完成（<code>独立端口</code>）。<code>Redis Cluster Bus</code>上交互的信息结构如下：</p><p><img src="https://yrlzero.gitee.io/images/linux/redis/redis-31.png" alt="img"></p><p>&emsp;&emsp;<code>clusterMsg</code> 中的<code>type</code>指明了消息的类型，配置信息的一致性主要依靠<code>PING/PONG</code>。每个节点向其他节点频繁的周期性的发送<code>PING/PONG</code>消息。对于消息体中的<code>Gossip</code>部分，包含了<code>sender/receiver</code> 所感知的其他节点信息，接受者根据这些<code>Gossip</code> 跟新对集群的认识。</p><p>&emsp;&emsp;对于大规模的集群，如果每次<code>PING/PONG</code> 都携带着所有节点的信息，则网络开销会很大。此时<code>Redis Cluster</code> 在每次<code>PING/PONG</code>，只包含了随机的一部分节点信息。由于交互比较频繁，短时间的几次交互之后，集群的状态也会达成一致。</p><h4 id="4-3-4、一致性"><a href="#4-3-4、一致性" class="headerlink" title="4.3.4、一致性"></a>4.3.4、一致性</h4><p>&emsp;&emsp;当<code>Cluster</code> 结构不发生变化时，各个节点通过<code>gossip</code> 协议在几轮交互之后，便可以得知<code>Cluster</code>的结构信息，达到一致性的状态。但是当集群结构发生变化时（故障转移/分片迁移等），优先得知变更的节点通过Epoch变量，将自己的最新信息扩散到<code>Cluster</code>，并最终达到一致。</p><p>&emsp;&emsp;<code>clusterNode</code> 的<code>Epoch</code>描述的单个节点的信息版本；<br>&emsp;&emsp;<code>clusterState</code> 的<code>currentEpoch</code> 描述的是集群信息的版本，它可以辅助<code>Epoch</code> 的自增生成。因为<code>currentEpoch</code> 是维护在每个节点上的，在集群结构发生变更时，<code>Cluster</code> 在一定的时间窗口控制更新规则，来保证每个节点的<code>currentEpoch</code>都是最新的。<br>&emsp;&emsp;Cluster更新规则如下：当某个节点率先知道了变更时，将自身的<code>currentEpoch</code> 自增，并使之成为集群中的最大值。再用自增后的<code>currentEpoch</code> 作为新的<code>Epoch</code> 版本；</p><ul><li>当某个节点收到了比自己大的<code>currentEpoch</code>时，更新自己的<code>currentEpoch</code>；</li><li>当收到的<code>Redis Cluster Bus</code> 消息中的某个节点的<code>Epoch</code> &gt; 自身的时，将更新自身的内容；</li><li>当<code>Redis Cluster Bus</code> 消息中，包含了自己没有的节点时，将其加入到自身的配置中。</li></ul><p>&emsp;&emsp;上述的规则保证了信息的更新都是单向的，最终朝着<code>Epoch</code>更大的信息收敛。同时<code>Epoch</code>也随着<code>currentEpoch</code>的增加而增加，最终将各节点信息趋于稳定。</p><p>&emsp;&emsp;为了使得集群在一部分节点下线或者无法与集群的大多数（<code>majority</code>）节点进行通讯的情况下， 仍然可以正常运作， <code>Redis</code> 集群对节点使用了主从复制功能： 集群中的每个节点都有 1 个至 N 个复制品（<code>replica</code>）， 其中一个复制品为主节点（<code>master</code>）， 而其余的 N-1 个复制品为从节点（<code>slave</code>）。</p><p><strong>集群间节点支持主从关系</strong>，复制的逻辑基本复用了单机版的实现。不过还是有些地方需要注意。</p><ul><li>首先集群间节点建立主从关系不再使用原有的<code>SLAVEOF</code>命令和<code>SLAVEOF</code>配置，而是通过<code>cluster replicate</code>命令，这保证了主从节点需要先完成握手，才能建立主从关系。</li><li>集群是不能组成链式主从关系的，也就是说从节点不能有自己的从节点。不过对于集群外的没开启集群功能的节点，<code>redis</code>并不干预这些节点去复制集群内的节点，但是在集群故障转移时，这些集群外的节点，集群不会处理。</li><li>集群内节点想要复制另一个节点，需要保证本节点不再负责任何<code>slot</code>，不然<code>redis</code>也是不允许的。</li><li>集群内的从节点在与其他节点通信的时候，传递的消息中数据分布表和<code>epoch</code>是<code>master</code>的值。</li></ul><p><strong>集群主节点出现故障，发生故障转移，其他主节点会把故障主节点的从节点自动提为主节点，原来的主节点恢复后，自动成为新主节点的从节点</strong>。</p><p>&emsp;&emsp;这里先说明，把一个<code>master</code>和它的全部<code>slave</code>描述为一个<code>group</code>，故障转移是以<code>group</code>为单位的，集群故障转移的方式跟sentinel的实现很类似。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/redis-32.png" alt="img"></p><h4 id="4-3-5、均衡集群"><a href="#4-3-5、均衡集群" class="headerlink" title="4.3.5、均衡集群"></a>4.3.5、均衡集群</h4><p>&emsp;&emsp;在集群运行过程中，有的<code>master</code>的<code>slave</code>宕机，导致了该<code>master</code>成为孤儿<code>master</code>（<code>orphaned masters</code>），而有的<code>master</code>有很多<code>slave</code>。（此处孤儿<code>master</code>的定义是那些本来有<code>slave</code>，但是全部离线的<code>master</code>，对于那些原来就没有<code>slave</code>的<code>master</code>不能认为是孤儿<code>master</code>。）</p><p>&emsp;&emsp;<code>redis</code>集群支持均衡<code>slave</code>功能，官方称为<code>Replica migration</code>，而我觉得均衡集群的<code>slave</code>更好理解该概念。集群能把某个<code>slave</code>较多的<code>group</code>上的<code>slave</code>迁移到那些孤儿<code>master</code>上，该功能通过<code>cluster-migration-barrier</code>参数配置，默认为1。<code>slave</code>在每次定时任务都会检查是否需要迁移<code>slave</code>，即把自己变成孤儿<code>master</code>的<code>slave</code>。 满足以下条件，<code>slave</code>就会成为孤儿<code>master</code>的<code>slave</code>：</p><ul><li>自己所在的<code>group</code>是<code>slave</code>最多的<code>group</code>；</li><li>目前存在孤儿<code>master</code>；</li><li>自己所在的<code>group</code>的<code>slave</code>数目至少超过2个，只有自己一个的话迁移到其他<code>group</code>，自己原来的<code>group</code>的<code>master</code>又成了孤儿<code>master</code>；</li><li>自己所在的<code>group</code>的<code>slave</code>数量大于<code>cluster-migration-barrier</code>配置；</li><li>与<code>group</code>内的其他<code>slave</code>基于<code>memcmp</code>比较<code>node id</code>，自己的<code>node id</code>最小。这个可以防止多个<code>slave</code>并发复制孤儿<code>master</code>，从而原来的<code>group</code>失去过多的<code>slave</code>。</li></ul><blockquote><ul><li>优势</li></ul><ol><li>去中心化，集群最大可增加1000个节点，性能随节点增加而线性扩展。</li><li>解耦 <strong>数据</strong> 和 <strong>节点</strong> 之间的关系，简化了节点 <strong>扩容</strong> 和 <strong>收缩</strong> 难度。</li><li><strong>节点自身</strong> 维护槽的 <strong>映射关系</strong>，不需要 <strong>客户端</strong> 或者 <strong>代理服务</strong> 维护 <strong>槽分区元数据</strong>。</li></ol><ul><li>劣势</li></ul><ol><li><code>key</code> <strong>批量操作</strong> 支持有限。类似 <code>mset</code>、<code>mget</code> 操作，目前只支持对具有相同 <code>slot</code> 值的<code>key</code> 执行 <strong>批量操作</strong>。对于 <strong>映射为不同</strong> <code>slot</code> 值的<code>key</code> 由于执行 <code>mget</code>、<code>mget</code> 等操作可能存在于多个节点上，因此不被支持。</li><li>只支持 <strong>多</strong> <code>key</code> 在 <strong>同一节点上</strong> 的 <strong>事务操作</strong>，当多个 <code>key</code> 分布在 <strong>不同</strong> 的节点上时 <strong>无法</strong> 使用事务功能。</li><li><code>key</code> 作为 <strong>数据分区</strong> 的最小粒度，不能将一个 <strong>大的键值</strong> 对象如 <code>Hash</code>、<code>list</code> 等映射到 <strong>不同的节点</strong>。</li><li>不支持<strong>多数据库空间</strong>，<strong>单机</strong>下的<code>Redis</code>可以支持 16 个数据库（db0 ~ db15），<strong>集群模式</strong>下只能使用<strong>一个</strong> 数据库空间，即 db0。</li><li><strong>复制结构</strong> 只支持一层，<strong>从节点</strong> 只能复制 <strong>主节点</strong>，不支持 <strong>嵌套树状复制</strong> 结构。</li></ol></blockquote><h3 id="4-4、查询路由分区——Redis-Cluster（操作）"><a href="#4-4、查询路由分区——Redis-Cluster（操作）" class="headerlink" title="4.4、查询路由分区——Redis-Cluster（操作）"></a>4.4、查询路由分区——Redis-Cluster（操作）</h3><p>&emsp;&emsp;操作Redis-Cluster有两种方式，一种是脚本启动（由Redis-Cluster创建实例），一种是手动启动（自行创建实例）。</p><ul><li><strong>脚本启动</strong></li></ul><h4 id="4-4-1、配置脚本"><a href="#4-4-1、配置脚本" class="headerlink" title="4.4.1、配置脚本"></a>4.4.1、配置脚本</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/redis-6.0.9/utils/create-cluster &amp;&amp; vim create-cluster</span><br><span class="line"></span><br><span class="line"><span class="comment"># Settings</span></span><br><span class="line">BIN_PATH=<span class="string">&quot;../../src/&quot;</span></span><br><span class="line">CLUSTER_HOST=127.0.0.1</span><br><span class="line">PORT=30000</span><br><span class="line">TIMEOUT=2000</span><br><span class="line">NODES=6 <span class="comment">#总的节点数量</span></span><br><span class="line">REPLICAS=1 <span class="comment">#每个master对应的slave数量</span></span><br><span class="line">PROTECTED_MODE=yes</span><br><span class="line">ADDITIONAL_OPTIONS=<span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里总的节点数为6个，每个主节点对应一个从节点，可自行配置。</p><h4 id="4-4-2、启动集群实例"><a href="#4-4-2、启动集群实例" class="headerlink" title="4.4.2、启动集群实例"></a>4.4.2、启动集群实例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./create-cluster start</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210719135126262.png" alt="image-20210719135126262"></p><h4 id="4-4-3、脚本自动分配slot（Hash槽位）"><a href="#4-4-3、脚本自动分配slot（Hash槽位）" class="headerlink" title="4.4.3、脚本自动分配slot（Hash槽位）"></a>4.4.3、脚本自动分配slot（Hash槽位）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./create-cluster create</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210719135644846.png" alt="image-20210719135644846"></p><h4 id="4-4-4、客户端连接集群"><a href="#4-4-4、客户端连接集群" class="headerlink" title="4.4.4、客户端连接集群"></a>4.4.4、客户端连接集群</h4><ul><li><strong>普通模式连接集群节点</strong></li></ul><p>&emsp;&emsp;在普通模式连接时，如果key分配的slot不在当前连接的redis server时，服务端返回错误提示，让客户端自己进行跳转 <code>(error) MOVED 12706 ip:port</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 30001</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210719140247198.png" alt="image-20210719140247198"></p><ul><li><strong>集群模式连接集群节点</strong></li></ul><p>&emsp;&emsp;在集群模式连接时，如果key分配的slot不在当前连接的redis server时，集群模式客户端会帮助我们进行重定向跳转 <code>Redirected to slot [12706] located at ip:port</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -c -p 30001</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210719140511550.png" alt="image-20210719140511550"></p><h4 id="4-4-5、注意事项"><a href="#4-4-5、注意事项" class="headerlink" title="4.4.5、注意事项"></a>4.4.5、注意事项</h4><p>&emsp;&emsp;不管是<code>普通客户端模式</code>还是<code>集群客户端模式</code>去连接服务，如果key不在一个slot仍无法使用事务等指令。解决同类业务数据不在同个 redis哈希槽的问题，在key上加上{tag}来标识某个key，会计算第一次出现’{‘到第一次出现’}’之间的subString内容的Hash值，如果该内容为空，则计算整个key;这种方式是解决分区key不同分区的通用解决方案。</p><h4 id="4-4-6、停止与还原"><a href="#4-4-6、停止与还原" class="headerlink" title="4.4.6、停止与还原"></a>4.4.6、停止与还原</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 停止所有正在运行的redis-cluster实例 </span></span><br><span class="line">./create-cluster stop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除配置、日志、持久化文件 </span></span><br><span class="line">./create-cluster clean</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210719140900210.png" alt="image-20210719140900210"></p><ul><li><strong>手动启动</strong></li></ul><h4 id="4-4-7、修改Redis启动配置文件"><a href="#4-4-7、修改Redis启动配置文件" class="headerlink" title="4.4.7、修改Redis启动配置文件"></a>4.4.7、修改Redis启动配置文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/<span class="built_in">local</span>/bin/redis.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">################################ REDIS CLUSTER  ###############################</span></span><br><span class="line"><span class="comment">#redis.conf相关集群配置</span></span><br><span class="line"><span class="comment">#配置为cluster模式</span></span><br><span class="line">cluster-enabled yes</span><br><span class="line"></span><br><span class="line"><span class="comment">#集群节点配置信息，包括nodeid，集群信息。此文件非常关键，要确保故障转移或者重启的时候此文件还在，所以如果在docker环境下要外挂到外部存储</span></span><br><span class="line">cluster-config-file nodes-6379.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">#节点连接超时，如果集群规模小，都在同一个网络环境下，可以配置的短些，更快的做故障转移</span></span><br><span class="line">cluster-node-timeout 2000</span><br><span class="line"></span><br><span class="line"><span class="comment">#慢查询日志，用于性能分析，生产环境可设置为1000（毫秒）</span></span><br><span class="line">slowlog-log-slower-than 1000</span><br><span class="line"></span><br><span class="line"><span class="comment">#保存慢查询的队列长度 ，设置为1000</span></span><br><span class="line">slowlog-max-len 1000</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置为0，默认为10如果master slave都挂掉，slave跟master失联又超过这个数值*timeout的数值，就不会发起选举了。</span></span><br><span class="line"><span class="comment">#如果设置为0，就是永远都会尝试发起选举，尝试从slave变为mater</span></span><br><span class="line">cluster-slave-validity-factor 10</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置为no，默认为yes，故障发现到自动完成转移期间整个集群是不可用状态，对于大多数业务无法容忍这种情况</span></span><br><span class="line"><span class="comment">#因此要设置为no，当主节点故障时只影 响它负责槽的相关命令执行，不会影响其他主节点的可用性</span></span><br><span class="line">cluster-require-full-coverage yes</span><br></pre></td></tr></table></figure><p><strong>其他实例配置：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">################################ REDIS CLUSTER  ###############################</span></span><br><span class="line">cluster-enabled yes</span><br><span class="line"></span><br><span class="line">cluster-config-file nodes-6380.conf <span class="comment">#注意区分各个节点</span></span><br></pre></td></tr></table></figure><h4 id="4-4-8、启动并手动分配slot（Hash槽）"><a href="#4-4-8、启动并手动分配slot（Hash槽）" class="headerlink" title="4.4.8、启动并手动分配slot（Hash槽）"></a>4.4.8、启动并手动分配slot（Hash槽）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动redis实例（启动cluster【6379】和其他各个要接入的节点【6380~6383】）</span></span><br><span class="line">redis-server  ./redis.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动分配slot（Hash槽）</span></span><br><span class="line">redis-cli --cluster create 127.0.0.1:6380 127.0.0.1:6381 127.0.0.1:6382 127.0.0.1:6383 127.0.0.1:6384 127.0.0.1:6385 --cluster-replicas 1</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210720111900909.png" alt="image-20210720111900909"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210720112151755.png" alt="image-20210720112151755"></p><h4 id="4-4-9、移动slot（Hash槽）"><a href="#4-4-9、移动slot（Hash槽）" class="headerlink" title="4.4.9、移动slot（Hash槽）"></a>4.4.9、移动slot（Hash槽）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#实行重新分片命令，可任意连接一个redis实例进行操作</span></span><br><span class="line">redis-cli --cluster reshard 127.0.0.1:6380</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:30001)</span><br><span class="line">M: 1ba79d08eacd99fa3791d1824907a3e3e136cf06 127.0.0.1:30001</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: d23ba04b97a59fa4bf3400510feb128ef0694520 127.0.0.1:30004</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 1ba79d08eacd99fa3791d1824907a3e3e136cf06</span><br><span class="line">S: 40b2868d28ac09031df1caa9847066eadebfa4f7 127.0.0.1:30006</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates e5bb13b4ea84f4fd5f23a944ae59a6768a34be28</span><br><span class="line">S: ddeb75d4235f26ce86fe30d3aa9edffde92d5a31 127.0.0.1:30005</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates e3e285582cabc5360d74e99c778867526cecb2a1</span><br><span class="line">M: e3e285582cabc5360d74e99c778867526cecb2a1 127.0.0.1:30002</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: e5bb13b4ea84f4fd5f23a944ae59a6768a34be28 127.0.0.1:30003</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br><span class="line"><span class="comment">#想要移动多少槽位？这里指定了2000</span></span><br><span class="line">How many slots <span class="keyword">do</span> you want to move (from 1 to 16384)? 2000</span><br><span class="line"><span class="comment"># 想要移动到哪个节点？这里指定了30002的节点id</span></span><br><span class="line">What is the receiving node ID? e3e285582cabc5360d74e99c778867526cecb2a1</span><br><span class="line">Please enter all the <span class="built_in">source</span> node IDs.</span><br><span class="line">  Type <span class="string">&#x27;all&#x27;</span> to use all the nodes as <span class="built_in">source</span> nodes <span class="keyword">for</span> the <span class="built_in">hash</span> slots.</span><br><span class="line">  Type <span class="string">&#x27;done&#x27;</span> once you entered all the <span class="built_in">source</span> nodes IDs.</span><br><span class="line">Source node <span class="comment">#1: 1ba79d08eacd99fa3791d1824907a3e3e136cf06</span></span><br><span class="line">Source node <span class="comment">#2: done</span></span><br><span class="line"><span class="comment">#略</span></span><br><span class="line">    Moving slot 1998 from 1ba79d08eacd99fa3791d1824907a3e3e136cf06</span><br><span class="line">    Moving slot 1999 from 1ba79d08eacd99fa3791d1824907a3e3e136cf06</span><br><span class="line"><span class="comment"># 是否执行表重新分片计划？yes</span></span><br><span class="line">Do you want to proceed with the proposed reshard plan (yes/no)? yes</span><br><span class="line"><span class="comment">#略</span></span><br><span class="line">Moving slot 1997 from 127.0.0.1:30001 to 127.0.0.1:30002: </span><br><span class="line">Moving slot 1998 from 127.0.0.1:30001 to 127.0.0.1:30002: </span><br><span class="line">Moving slot 1999 from 127.0.0.1:30001 to 127.0.0.1:30002:</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分配完成后可以使用一下命令查询分配情况</span></span><br><span class="line">redis-cli --cluster check 127.0.0.1:6380</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210720113627150.png" alt="image-20210720113627150"></p><h4 id="4-4-10、集群客户端-帮助"><a href="#4-4-10、集群客户端-帮助" class="headerlink" title="4.4.10、集群客户端-帮助"></a>4.4.10、集群客户端-帮助</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-3 create-cluster]<span class="comment"># redis-cli --cluster help</span></span><br><span class="line">Cluster Manager Commands:</span><br><span class="line">  create         host1:port1 ... hostN:portN</span><br><span class="line">                 --cluster-replicas &lt;arg&gt;</span><br><span class="line">  check          host:port</span><br><span class="line">                 --cluster-search-multiple-owners</span><br><span class="line">  info           host:port</span><br><span class="line">  fix            host:port</span><br><span class="line">                 --cluster-search-multiple-owners</span><br><span class="line">                 --cluster-fix-with-unreachable-masters</span><br><span class="line">  reshard        host:port</span><br><span class="line">                 --cluster-from &lt;arg&gt;</span><br><span class="line">                 --cluster-to &lt;arg&gt;</span><br><span class="line">                 --cluster-slots &lt;arg&gt;</span><br><span class="line">                 --cluster-yes</span><br><span class="line">                 --cluster-timeout &lt;arg&gt;</span><br><span class="line">                 --cluster-pipeline &lt;arg&gt;</span><br><span class="line">                 --cluster-replace</span><br><span class="line">  rebalance      host:port</span><br><span class="line">                 --cluster-weight &lt;node1=w1...nodeN=wN&gt;</span><br><span class="line">                 --cluster-use-empty-masters</span><br><span class="line">                 --cluster-timeout &lt;arg&gt;</span><br><span class="line">                 --cluster-simulate</span><br><span class="line">                 --cluster-pipeline &lt;arg&gt;</span><br><span class="line">                 --cluster-threshold &lt;arg&gt;</span><br><span class="line">                 --cluster-replace</span><br><span class="line">  add-node       new_host:new_port existing_host:existing_port</span><br><span class="line">                 --cluster-slave</span><br><span class="line">                 --cluster-master-id &lt;arg&gt;</span><br><span class="line">  del-node       host:port node_id</span><br><span class="line">  call           host:port <span class="built_in">command</span> arg arg .. arg</span><br><span class="line">                 --cluster-only-masters</span><br><span class="line">                 --cluster-only-replicas</span><br><span class="line">  set-timeout    host:port milliseconds</span><br><span class="line">  import         host:port</span><br><span class="line">                 --cluster-from &lt;arg&gt;</span><br><span class="line">                 --cluster-copy</span><br><span class="line">                 --cluster-replace</span><br><span class="line">  backup         host:port backup_directory</span><br><span class="line">  <span class="built_in">help</span>           </span><br><span class="line"></span><br><span class="line">For check, fix, reshard, del-node, set-timeout you can specify the host and port of any working node <span class="keyword">in</span> the cluster.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主从复制 </tag>
            
            <tag> Redis </tag>
            
            <tag> 哨兵 </tag>
            
            <tag> 分区 </tag>
            
            <tag> 集群 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis的进阶使用</title>
      <link href="/blog/2021/06/14/Redis%E7%9A%84%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8/"/>
      <url>/blog/2021/06/14/Redis%E7%9A%84%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis的进阶使用"><a href="#Redis的进阶使用" class="headerlink" title="Redis的进阶使用"></a>Redis的进阶使用</h1><h1 id="一、Redis的消息发布与订阅"><a href="#一、Redis的消息发布与订阅" class="headerlink" title="一、Redis的消息发布与订阅"></a>一、Redis的消息发布与订阅</h1><h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><p>&emsp;&emsp;Redis发布订阅(pub/sub)是一种消息通信模式：发送者(publish)发送消息，订阅者(subscribe)接收消息。发布订阅也叫生产者消费者模式,是实现消息队列的一种方式。发布订阅应用在即时通信应用中较多，比如网络聊天室，实时广播、实时提醒等。同时滴滴打车软件的抢单、外卖的抢单、在微信群发红包、抢红包都可以使用发布订阅实现。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210703170254871.png" alt="image-20210703170254871"></p><h2 id="2、操作命令"><a href="#2、操作命令" class="headerlink" title="2、操作命令"></a>2、操作命令</h2><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>PSUBSCRIBE pattern [pattern …]</td><td>订阅一个或多个符合给定模式的频道</td></tr><tr><td>PUBSUB subcommand [argument [argument …]]</td><td>查看订阅与发布系统状态</td></tr><tr><td>PUBLISH channel message</td><td>将信息发送到指定的频道</td></tr><tr><td>PUNSUBSCRIBE [pattern [pattern …]]</td><td>退订所有给定模式的频道</td></tr><tr><td>SUBSCRIBE channel [channel …]</td><td>订阅给定的一个或多个频道的信息</td></tr><tr><td>UNSUBSCRIBE [channel [channel …]]</td><td>退订指定的频道</td></tr></tbody></table><h1 id="二、Redis的淘汰与过期"><a href="#二、Redis的淘汰与过期" class="headerlink" title="二、Redis的淘汰与过期"></a>二、Redis的淘汰与过期</h1><p>&emsp;&emsp;我们都知道，Redis缓存使用的是内存资源，虽然缓存服务器会配置比较高的内存资源，但如果对于Redis中的缓存数据我们不管不顾，内存资源总有耗尽的时候，这时缓存服务器就无法再对外提供服务了。我们要用有限的服务器资源支撑更多的业务服务，就必须要让那些访问频率不高的缓存删除掉，为新的缓存腾出内存空间。</p><p>&emsp;&emsp;而Redis主要通过两种方式相互配合来实现键值的清理，即：内存淘汰机制和过期策略。</p><h2 id="1、缓存过期策略"><a href="#1、缓存过期策略" class="headerlink" title="1、缓存过期策略"></a>1、缓存过期策略</h2><p>&emsp;&emsp;内存淘汰策略是当内存不够用时才会触发的一种机制，是缓存服务层面的操作，而过期策略定义的是具体缓存数据何时失效。我们在使用Redis的时候经常会给redis的key设置一个过期时间如：<code>EXPIRE key 30</code>，过期策略就是指当 Redis 中缓存的 key 过期了，Redis 如何处理。对于已经过期的数据，Redis将使用两种策略搭配使用来删除这些过期的键值，分别是惰性删除和定期删除。</p><p><strong>Redis总共有三种过期策略，分别如下：</strong></p><h3 id="1-1、定时过期"><a href="#1-1、定时过期" class="headerlink" title="1.1、定时过期"></a>1.1、定时过期</h3><blockquote><p>定时过期是在设置key的过期时间的同时，为该key创建一个定时器，让定时器在key的过期时间来临时，对key进行删除。</p><p>优点：保证内存被尽快释放。</p><p>缺点：若过期key很多，删除这些key会占用很多的CPU时间，在CPU时间紧张的情况下，CPU不能把所有的时间用来做要紧的事儿，还需要去花时间删除这些key定时器的创建耗时，若为每一个设置过期时间的key创建一个定时器（将会有大量的定时器产生），性能影响严重。</p></blockquote><h3 id="1-2、惰性过期"><a href="#1-2、惰性过期" class="headerlink" title="1.2、惰性过期"></a>1.2、惰性过期</h3><blockquote><p>惰性过期是指key过期的时候不删除，每次通过key获取值的时候去检查是否过期，若过期则删除，返回null，即用的时候再检查删除。</p><p>优点：删除操作只在通过key取值的时候发生，而且只删除当前key，所以对CPU时间的占用是比较少的。<br>缺点：若大量的key在超出超时时间后，很久一段时间内，都没有被获取过，那么可能发生内存泄露（无用的垃圾占用了大量的内存）。</p></blockquote><h3 id="1-3、定期过期"><a href="#1-3、定期过期" class="headerlink" title="1.3、定期过期"></a>1.3、定期过期</h3><blockquote><p>定期过期是指每隔一段时间执行一次删除过期key操作。<br>优点：通过限制删除操作的时长和频率，该策略是前两者的一个折中方案。<br>缺点：在内存友好方面，不如”定时过期”（会造成一定的内存占用，但是没有“惰性过期”那么占用内存）在CPU时间友好方面，不如”惰性过期”（会定期的去进行比较和删除操作，cpu方面不如“惰性过期”，但是比“定时过期”好）。</p></blockquote><h2 id="2、内存淘汰机制"><a href="#2、内存淘汰机制" class="headerlink" title="2、内存淘汰机制"></a>2、内存淘汰机制</h2><p>&emsp;&emsp;内存淘汰策略是指在Redis的用于缓存的<strong>内存不足时，怎么处理需要新写入且需要申请额外空间的数据</strong>。我们可以修改Redis的配置文件，设置maxmemory为0代表没有内存限制。这对于64位的系统这是个默认值，而对于32位的系统默认内存限制为3GB。当指定的内存限制大小达到时，需要选择不同的行为，也就是策略。 Redis可以仅仅对命令返回错误，这将使得内存被使用得更多，或者回收一些旧的数据来使得添加数据时可以避免内存限制。当maxmemory限制达到的时候Redis会使用的行为由 Redis的maxmemory-policy配置指令来进行配置。可配置的策略如下：</p><table><thead><tr><th>淘汰策略</th><th>备注</th></tr></thead><tbody><tr><td>volatile-lru</td><td>在过期集合的键中，尝试回收最久未被访问的键（LRU）,使得新添加的数据有空间存放。</td></tr><tr><td>allkeys-lru</td><td>在所有的键中，尝试回收最久未被访问的键（LRU），使得新添加的数据有空间存放。</td></tr><tr><td>volatile-lfu</td><td>在过期集合的键中，驱逐使用频率最少的键（LFU），使得新添加的数据有空间存放。</td></tr><tr><td>allkeys-lfu</td><td>在所有的键中，驱逐使用频率最少的键（LFU），使得新添加的数据有空间存放。</td></tr><tr><td>volatile-random</td><td>在过期集合的键中，随机回收键，使得新添加的数据有空间存放。</td></tr><tr><td>allkeys-random</td><td>在所有的键中，随机回收键，使得新添加的数据有空间存放。</td></tr><tr><td>volatile-ttl</td><td>在过期集合的键，优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。</td></tr><tr><td>noeviction</td><td>不淘汰，返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外）</td></tr></tbody></table><h1 id="三、Redis的布隆过滤器"><a href="#三、Redis的布隆过滤器" class="headerlink" title="三、Redis的布隆过滤器"></a>三、Redis的布隆过滤器</h1><h2 id="1、为什么需要布隆过滤器"><a href="#1、为什么需要布隆过滤器" class="headerlink" title="1、为什么需要布隆过滤器"></a>1、为什么需要布隆过滤器</h2><p>&emsp;&emsp;有以下几个场景：1、原本有10亿个号码，现在又来了10万个号码，要快速准确判断这10万个号码是否在10亿个号码库中？2、在进行爬虫时，需要爬虫的网站千千万万，对于一个新的网站url，我们如何判断这个url我们是否已经爬过了？3、垃圾邮箱如何过滤？对于这一类操作，我们想到的：</p><p>&emsp;&emsp;解决办法一：将原来的数据存入数据库中，进行数据库查询，准确性有了，但是速度会比较慢。</p><p>&emsp;&emsp;解决办法二：将原来的数据放入内存中，比如Redis缓存中，通过内存查询，准确性和速度都有了，但是这部分内存空间，挺浪费的。</p><p>&emsp;&emsp;对于上述两个解决方案，虽然都能够解决问题，但在解决上又多多少少有一点问题，对于类似这种，大数据量集合，如何准确快速的判断某个数据是否在大数据量集合中，并且不占用内存，<strong>布隆过滤器</strong>应运而生了。</p><h2 id="2、什么是布隆过滤器"><a href="#2、什么是布隆过滤器" class="headerlink" title="2、什么是布隆过滤器"></a>2、什么是布隆过滤器</h2><p>&emsp;&emsp;布隆过滤器：一种数据结构，是由一串很长的二进制向量组成，可以将其看成一个二进制数组。既然是二进制，那么里面存放的不是0，就是1，但是初始默认值都是0。</p><p>&emsp;&emsp;当我们添加一个数据到布隆过滤器时，其将该数据分别多个hash函数进行计算，算出多个值，然后将这个值所在的方格置为1。当我们需要判断这个数据是否存在时，只需要将这个数据通过上面多个hash函数进行计算，判断获得的值对应方格是否为1，如果存在不为1的情况，那么我们就可以确定这个值并不存在。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.png" alt="布隆过滤器"></p><h2 id="3、布隆过滤器的优缺点"><a href="#3、布隆过滤器的优缺点" class="headerlink" title="3、布隆过滤器的优缺点"></a>3、布隆过滤器的优缺点</h2><p>&emsp;&emsp;我们在上面说了如果查询到某个位置为0，则表示数据一定不存在，但是，反过来说，如果都查询到为1，则是否可以判断其一定存在呢？答案是否定的，因为多个数据算出来的结果可能存在重复。所以有可能出现在某些数值并不存在，但由于其他数值的hash结果刚好填充了其位置，导致误判其为存在的情况。</p><p><strong>优点</strong>：二进制组成的数组，占用内存极少，并且插入和查询速度都足够快。</p><p><strong>缺点</strong>：随着数据的增加，误判率会增加，无法判断数据一定存在；另外还有一个重要缺点，无法删除数据。</p><p>&emsp;&emsp;虽然当数据达到一定量时，布隆过滤器会发生误判的概率上升，但是正常情况下，布隆过滤器能够满足我们正常的需求。同时，<strong>布隆过滤器能够帮助我们解决Redis的一个问题——缓存穿透</strong>。</p><h2 id="4、Redis使用布隆过滤器"><a href="#4、Redis使用布隆过滤器" class="headerlink" title="4、Redis使用布隆过滤器"></a>4、Redis使用布隆过滤器</h2><h3 id="4-1、正常安装Redis"><a href="#4-1、正常安装Redis" class="headerlink" title="4.1、正常安装Redis"></a>4.1、正常安装Redis</h3><h3 id="4-2、下载布隆过滤器插件"><a href="#4-2、下载布隆过滤器插件" class="headerlink" title="4.2、下载布隆过滤器插件"></a>4.2、下载布隆过滤器插件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 下载安装包</span><br><span class="line">wget https://github.com/RedisBloom/RedisBloom/archive/refs/tags/v2.2.4.zip</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210704164111885.png" alt="image-20210704164111885"></p><h3 id="4-3、安装布隆过滤器"><a href="#4-3、安装布隆过滤器" class="headerlink" title="4.3、安装布隆过滤器"></a>4.3、安装布隆过滤器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 解压到指定目录</span><br><span class="line">unzip RedisBloom-2.2.4.zip -d /usr/<span class="built_in">local</span></span><br><span class="line"></span><br><span class="line">-- 安装</span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/RedisBloom-master/ &amp;&amp; make</span><br><span class="line">-- 出现redisbloom.so这说明安装成功</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210704174807342.png" alt="image-20210704174807342"></p><h3 id="4-4、配置布隆过滤器"><a href="#4-4、配置布隆过滤器" class="headerlink" title="4.4、配置布隆过滤器"></a>4.4、配置布隆过滤器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-- 修改Redis配置文件，使其启动时加载布隆过滤器</span><br><span class="line">vim /usr/<span class="built_in">local</span>/bin/redis.conf</span><br><span class="line"></span><br><span class="line">-- 新增加载配置（注意，不要使用相对路径，一定要使用绝对路径）</span><br><span class="line"></span><br><span class="line">loadmodule /usr/<span class="built_in">local</span>/RedisBloom-2.2.4/redisbloom.so</span><br><span class="line"></span><br><span class="line">-- 重启Redis</span><br><span class="line">redis-server /usr/<span class="built_in">local</span>/bin/redis.conf</span><br><span class="line"></span><br><span class="line">-- 检查布隆过滤器是否生效，使用客户端连接，查看BF.ADD命令是否存在，存在即为成功</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210704175340139.png" alt="image-20210704175340139"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210704175732619.png" alt="image-20210704175732619"></p><h2 id="5、布隆过滤器的命令"><a href="#5、布隆过滤器的命令" class="headerlink" title="5、布隆过滤器的命令"></a>5、布隆过滤器的命令</h2><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>BF.ADD key …option…</td><td>添加值到key这个布隆过滤器中</td></tr><tr><td>BF.MADD key …option…</td><td>添加多个值到key这个布隆过滤器中，已存在的元素返回0</td></tr><tr><td>BF.EXISTS key …option…</td><td>判断值在key这个布隆过滤器中是否存在</td></tr><tr><td>BF.MEXISTS key …option…</td><td>批量判断过滤器中是否存在该元素</td></tr><tr><td>BF.RESERVE key  error_rate  size</td><td>设置过滤器的错误率和储存量<br />error_rate：允许的错误率 0.0001等  默认值：0.01<br />size：保存的数组大小，尽可能设大一些，防止不够用。默认值：100</td></tr></tbody></table><h1 id="四、Redis-Pipeline"><a href="#四、Redis-Pipeline" class="headerlink" title="四、Redis Pipeline"></a>四、Redis Pipeline</h1><h2 id="1、Redis-Pipeline产生背景"><a href="#1、Redis-Pipeline产生背景" class="headerlink" title="1、Redis Pipeline产生背景"></a>1、Redis Pipeline产生背景</h2><p>&emsp;&emsp;Redis执行命令的流程是：<strong>发送命令－〉命令排队－〉命令执行－〉返回结果</strong>。这个过程称为Round trip time(简称RTT, 往返时间)，虽然mget mset有效节约了RTT，但大部分命令（如hgetall，并没有mhgetall）不支持批量操作，需要消耗N次RTT ，这个时候需要pipeline 来解决这个问题。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210704222933855.png" alt="image-20210704222933855"></p><h2 id="2、Redis-Pipeline的操作流程"><a href="#2、Redis-Pipeline的操作流程" class="headerlink" title="2、Redis Pipeline的操作流程"></a>2、Redis Pipeline的操作流程</h2><p>&emsp;&emsp;这里介绍两种使用Redis Pipeline的操作方式，第一种是使用Jedis进行操作，另一种是使用redisTemplate来操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedisDemoApplicationTests</span> </span>&#123;</span><br><span class="line">----------------------------------------Jedis操作-----------------------------------------------------</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testJedis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">        Pipeline pipelined = jedis.pipelined();</span><br><span class="line">        pipelined.set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        pipelined.set(<span class="string">&quot;age&quot;</span>,<span class="string">&quot;20&quot;</span>);</span><br><span class="line">        pipelined.incr(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        pipelined.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        pipelined.get(<span class="string">&quot;age&quot;</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Object&gt; results = pipelined.syncAndReturnAll();</span><br><span class="line">        results.stream().forEach( o -&gt; System.out.println(o));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">------------------------------------------redisTemplate操作--------------------------------------------------</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testSpringBootData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Object&gt; results = stringRedisTemplate.executePipelined(<span class="keyword">new</span> RedisCallback&lt;String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">doInRedis</span><span class="params">(RedisConnection redisConnection)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line">                redisConnection.flushDb();</span><br><span class="line">                redisConnection.set(<span class="string">&quot;name&quot;</span>.getBytes(StandardCharsets.UTF_8), <span class="string">&quot;张三&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">                redisConnection.set(<span class="string">&quot;age&quot;</span>.getBytes(StandardCharsets.UTF_8), <span class="string">&quot;20&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">                redisConnection.incr(<span class="string">&quot;age&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">                redisConnection.get(<span class="string">&quot;name&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">                redisConnection.get(<span class="string">&quot;age&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        results.stream().forEach( o -&gt; System.out.println(o));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五、Redis的持久化"><a href="#五、Redis的持久化" class="headerlink" title="五、Redis的持久化"></a>五、Redis的持久化</h1><p>&emsp;&emsp;Redis是一个内存数据库，数据保存在内存中，所以如果没有将Redis的数据持久化，就会在重启之后发生数据丢失。所以Redis为我们提供了持久化的机制，分别是RDB(Redis DataBase)和AOF(Append Only File)。</p><h2 id="1、RDB持久化"><a href="#1、RDB持久化" class="headerlink" title="1、RDB持久化"></a>1、RDB持久化</h2><p>&emsp;&emsp;RDB其实就是把数据以<strong>快照</strong>的形式保存在磁盘上。RDB的持久化方式就是指在指定的时间内将内存中的数据集以快照的方式写入磁盘，这也是Redis默认的持久化方式。</p><h3 id="1-1、RDB持久化的优缺点"><a href="#1-1、RDB持久化的优缺点" class="headerlink" title="1.1、RDB持久化的优缺点"></a>1.1、RDB持久化的优缺点</h3><h4 id="1-1-1、优点"><a href="#1-1-1、优点" class="headerlink" title="1.1.1、优点"></a>1.1.1、优点</h4><blockquote><p>1、只存在一个文件 dump.rdb，是一个<strong>二进制文件，很小，方便持久化</strong>；</p><p>2、 主进程<strong>不会进行任何 IO 操作，保证了 redis 的高性能</strong> ，使用fork()创建子进程来进行RDB备份操作，子进程拥有父进程数据的指针，不需要全部数据拷贝一份，当有主进程有新数据进行修改时，触发系统内核的copy on write写时复制的机制，新数据写入新的内存位置，之后再操作旧数据的指针，而子进程的指针仍指向旧数据，因此两个进程的数据是隔离的，也保证了数据备份的时点性。同时copy on write只是一个寻址的过程，是纳秒级别的。而aof<strong>每次</strong>都是写盘操作，毫秒级别。</p></blockquote><h4 id="1-1-2、缺点"><a href="#1-1-2、缺点" class="headerlink" title="1.1.2、缺点"></a>1.1.2、缺点</h4><blockquote><p>数据安全性低。RDB 是间隔一段时间进行持久化，如果在持久化之前 Redis 发生故障，那么从上一次持久化到当前时间的数据会发生丢失。</p></blockquote><h3 id="1-2、RDB持久化的触发条件"><a href="#1-2、RDB持久化的触发条件" class="headerlink" title="1.2、RDB持久化的触发条件"></a>1.2、RDB持久化的触发条件</h3><p>&emsp;&emsp;RDB持久化的触发分为手动触发和自动触发两种。下面save和bgsave两种方法都是属于手动触发。</p><h4 id="1-2-1、save"><a href="#1-2-1、save" class="headerlink" title="1.2.1、save"></a>1.2.1、save</h4><p>&emsp;&emsp;执行save命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在Redis服务器阻塞期间，服务器不能处理任何命令请求。对于这种方式，如果是数据量小的还能够接受，如果是数据量大的（例如10G），是不能接受的，因为一次持久化可能需要1小时以上，那就相当于这一个小时上面都做不了。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/e7cd7b899e510fb3aa8c05042b22c093d0430ca7.jpeg" alt="img"></p><h4 id="1-2-2、bgsave"><a href="#1-2-2、bgsave" class="headerlink" title="1.2.2、bgsave"></a>1.2.2、bgsave</h4><p>&emsp;&emsp;执行bgsave命令则会创建一个子进程，由<strong>子进程来负责创建RDB文件</strong>，<strong>父进程(即Redis主进程)则继续处理请求</strong>。新写的数据对我持久化不会造成数据影响，你持久化的过程中报错或者耗时太久都对我当前对外提供请求的服务不会产生任何影响。<strong>持久化完会将新的rdb文件覆盖之前的</strong>。bgsave命令执行过程中，只有fork子进程时会阻塞服务器，而对于save命令，整个过程都会阻塞服务器，因此save已基本被废弃，线上环境要杜绝save的使用。</p><p>&emsp;&emsp;bgsave的原理是<strong>fork()和copy on write</strong>。fork()用于创建一个子进程，fork()出来的进程共享其父类的内存数据。但仅仅是共享fork()出子进程的那一刻的内存数据，后期主进程修改数据对子进程不可见，同理，子进程修改的数据对主进程也不可见。fork()出来子进程后，就利用copy on write完成快照的生成。正常情况下我们说copy on write，指的是修改共享资源时，将共享资源copy一份，加锁后修改，再将原容器的引用指向新的容器。但是显然Redis并不能直接使用标准的copy on write来进行操作，因为这样操作必然会使Redis的可用内存容量减半。所以Redis在fork()出子进程之后，并没有将数据进行copy，但是kernel会把主进程中的所有内存页的权限都设为read-only，主进程和子进程访问数据的指针都指向同一内存地址。主进程发生写操作时，因为权限已经设置为read-only了，所以会触发页异常中断（page-fault）。在中断处理中，需要被写入的内存页面会复制一份，复制出来的旧数据交给子进程使用，然后主进程该干啥就干啥。也就是说，在进行IO操作写盘的过程中（on write），对于没有改变的数据，主进程和子进程资源共享；只有在出现了需要变更的数据时（写脏的数据），才进行copy操作。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/023b5bb5c9ea15cefb035bc8431132f53b87b21e.jpeg" alt="img"></p><h4 id="1-2-3、自动触发"><a href="#1-2-3、自动触发" class="headerlink" title="1.2.3、自动触发"></a>1.2.3、自动触发</h4><p>&emsp;&emsp;自动触发是由我们的配置文件来完成的。在redis.conf配置文件中，里面有如下配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">################################ SNAPSHOTTING  ################################</span></span><br><span class="line"><span class="comment">#RDB触发规则，每多少秒触发了多少次则执行RDB，“”表示不开启RDB，可以多个save规则同时配置</span></span><br><span class="line"><span class="comment">#   save &quot;&quot;</span></span><br><span class="line"><span class="attr">save</span> <span class="string">900 1</span></span><br><span class="line"><span class="attr">save</span> <span class="string">300 10</span></span><br><span class="line"><span class="attr">save</span> <span class="string">60 10000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># bgsave快照出错时是否停止数据写入</span></span><br><span class="line"><span class="meta">stop-writes-on-bgsave-error</span> <span class="string">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否开启压缩</span></span><br><span class="line"><span class="attr">rdbcompression</span> <span class="string">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否设置检查点</span></span><br><span class="line"><span class="attr">rdbchecksum</span> <span class="string">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># rdb文件名称</span></span><br><span class="line"><span class="attr">dbfilename</span> <span class="string">dump.rdb</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否同步删除rdb文件</span></span><br><span class="line"><span class="meta">rdb-del-sync-files</span> <span class="string">no</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 持久化文件存放的目录（RDB和AOF问备份文件都会放在这里）</span></span><br><span class="line"><span class="attr">dir</span> <span class="string">/var/lib/redis/6379</span></span><br></pre></td></tr></table></figure><h2 id="2、AOF持久化"><a href="#2、AOF持久化" class="headerlink" title="2、AOF持久化"></a>2、AOF持久化</h2><p>&emsp;&emsp;AOF（append only file）持久化：以独立日志的方式记录每次写命令， 重启时再重新执行AOF文件中的命令达到恢复数据的目的。AOF的主要作用 是解决了数据持久化的实时性，目前已经是Redis持久化的主流方式之一。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/redis-03.png" alt="img"></p><h3 id="2-1、AOF持久化的优缺点"><a href="#2-1、AOF持久化的优缺点" class="headerlink" title="2.1、AOF持久化的优缺点"></a>2.1、AOF持久化的优缺点</h3><h4 id="2-1-1、优点"><a href="#2-1-1、优点" class="headerlink" title="2.1.1、优点"></a>2.1.1、优点</h4><blockquote><ol><li>AOF可以更好的保护数据不丢失，一般AOF会每隔1秒，通过一个后台线程执行一次fsync操作，最多丢失1秒钟的数据;</li><li>AOF日志文件没有任何磁盘寻址的开销，写入性能非常高，文件不容易破损；</li><li>AOF日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写；</li><li>AOF日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用flushall命令清空了所有数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall命令给删了，然后再将该AOF文件放回去，就可以通过恢复机制，自动恢复所有数据。</li></ol></blockquote><h4 id="2-1-2、缺点"><a href="#2-1-2、缺点" class="headerlink" title="2.1.2、缺点"></a>2.1.2、缺点</h4><blockquote><ol><li>对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大；</li><li>AOF开启后，支持的写QPS会比RDB支持的写QPS低，因为AOF一般会配置成每秒fsync一次日志文件，当然，每秒一次fsync，性能也还是很高的。</li></ol></blockquote><h3 id="2-2、AOF持久化的触发条件"><a href="#2-2、AOF持久化的触发条件" class="headerlink" title="2.2、AOF持久化的触发条件"></a>2.2、AOF持久化的触发条件</h3><p><strong>每修改同步always</strong>：同步持久化 每次发生数据变更会被立即记录到磁盘 性能较差但数据完整性比较好；</p><p><strong>每秒同步everysec</strong>：异步操作，每秒记录 如果一秒内宕机，有数据丢失；</p><p><strong>不同步no</strong>：从不同步。</p><h3 id="2-3、AOF使用配置"><a href="#2-3、AOF使用配置" class="headerlink" title="2.3、AOF使用配置"></a>2.3、AOF使用配置</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">############################## APPEND ONLY MODE ###############################</span></span><br><span class="line"><span class="comment"># 是否开启aof</span></span><br><span class="line"><span class="string">appendonly</span> <span class="literal">no</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># aof文件名</span></span><br><span class="line"><span class="string">appendfilename</span> <span class="string">&quot;appendonly.aof&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># aof触发策略</span></span><br><span class="line"><span class="string">appendfsync</span> <span class="string">always</span> <span class="comment">#每个动作都追加</span></span><br><span class="line"><span class="string">appendfsync</span> <span class="string">everysec</span> <span class="comment">#默认配置，每秒都追加</span></span><br><span class="line"><span class="string">appendfsync</span> <span class="literal">no</span> <span class="comment">#等待内核缓冲区满了在一起追加</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#当有其他子进程在对磁盘进行写操作（rdb）或者重写操作时，no表示不参与争抢，此时不进行aof操作</span></span><br><span class="line"><span class="literal">no</span><span class="string">-appendfsync-on-rewrite</span> <span class="literal">no</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 重写配置</span></span><br><span class="line"><span class="string">auto-aof-rewrite-percentage</span> <span class="number">100</span>   </span><br><span class="line"><span class="string">auto-aof-rewrite-min-size</span> <span class="string">64mb</span> <span class="comment">#aof达到64MB时触发重写</span></span><br><span class="line"></span><br><span class="line"><span class="string">aof-load-truncated</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#是否混合使用RDB和AOF备份，重写时会将旧数据以RDB形势放入aof文件前面，新数据以追加日志方式写入，[RDB file][AOF tail]，当打开aof文件时前面出现&quot;REDIS&quot;证明是开启RDB前置的新AOF混合文件，4.0之后才有的新功能</span></span><br><span class="line"><span class="string">aof-use-rdb-preamble</span> <span class="literal">yes</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;对于AOF，Redis是默认不开启的，所以我们需要通过修改配置文件来开启AOF持久化功能。而对于AOF持久化，我们还有几个可以研究的问题：</p><p><strong>a、AOF为什么把命令追加到aof_buf中？</strong></p><p>&emsp;&emsp;答：Redis使用单线程响应命令，如 果每次写AOF文件命令都直接追加到硬盘，那么性能完全取决于当前硬盘负 载。先写入缓冲区aof_buf中，还有另一个好处，Redis可以提供多种缓冲区同步硬盘的策略，可以在性能和安全性方面做出平衡。</p><p><strong>b、随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的。为什么重写后的AOF文件可以变小？</strong></p><p>&emsp;&emsp;答：首先，进程内已经超时的数据不再写入文件。其次，重写使用进程内数据直接生成，这样新的AOF文件只保留最终数据的写入命令。中间的内容不再保留。最后，多条写命令可以合并为一个。触发AOF进行重写可以通过命令<code>bgrewriteaof</code>来触发，同时也可以通过上面的<code>#重写配置</code>来自动触发。</p><p>&emsp;&emsp;对于Redis4.0版本之后的重写，Redis会将就的数据RDB到AOF文件中，其它增量的指令再以命令的方式Append到AOF文件中。</p><h2 id="3、持久化的选择"><a href="#3、持久化的选择" class="headerlink" title="3、持久化的选择"></a>3、持久化的选择</h2><p>&emsp;&emsp;一般来说， 如果想达到足以媲美PostgreSQL的数据安全性，你应该 同时使用两种持久化功能。在这种情况下，当 Redis 重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。 </p><p>&emsp;&emsp;如果非常关心数据，但仍然可以承受数分钟以内的数据丢失，那么可以只使用RDB持久化。 </p><p>&emsp;&emsp;有很多用户都只使用AOF持久化，但并不推荐这种方式，因为定时生成RDB快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比AOF恢复的速度要快，除此之外，使用RDB还可以避免AOF程序的bug。 </p><p>&emsp;&emsp;如果只希望数据在服务器运行的时候存在，你也可以不使用任何持久化方式。</p><h1 id="六、Redis的相关面试题"><a href="#六、Redis的相关面试题" class="headerlink" title="六、Redis的相关面试题"></a>六、Redis的相关面试题</h1><h2 id="1、缓存穿透"><a href="#1、缓存穿透" class="headerlink" title="1、缓存穿透"></a>1、缓存穿透</h2><h3 id="1-1、概念"><a href="#1-1、概念" class="headerlink" title="1.1、概念"></a>1.1、概念</h3><p>&emsp;&emsp;<font color='red'><strong>客户端大量请求不存在的数据。</strong></font></p><p>&emsp;&emsp;举例：在购书网站上查询日用百货，本来就是不存在的商品自然在Redis上就不存在，此时按照我们正常逻辑就会直接压到数据库进行查询，如果查询量大的话，肯定会造成系统响应速度变慢，其次甚至会造成数据库宕机。</p><h3 id="1-2、解决方案"><a href="#1-2、解决方案" class="headerlink" title="1.2、解决方案"></a>1.2、解决方案</h3><p>&emsp;&emsp;对于这一类的无效查询，我们应该尽量避免对数据库的空查询。所以我们可以联想到我们上面说的布隆过滤器。例如：我们可以将所有商品的名称存储到布隆过滤器中，在每次搜索时，先搜索布隆过滤器中是否有该商品，没有的话直接返回没有，使无效查询减少。当然，布隆过滤器也是有缺点的：一方面，它只能key的映射增加不能删除（<strong>布谷鸟过滤器</strong>可以解决）另一方面，不存在的key有一定程度可能跟存在的key出现映射重合，存在一定的误差。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/20201003165626288.jpg" alt="在这里插入图片描述"></p><blockquote><p>问题：如果使用布隆过滤器还是发生了低概率的缓存穿透，有没有什么优化方式？</p><ol><li>client端发送的请求穿透了redis，进行数据库查询但是没有查询到结果，可以增加 redis 中的key，value 标记为 null，下次进行同样的查询直接返回 null，查询就相当于被过滤，不会打到数据库；</li><li>数据库增加了元素，需要进行映射，在位图 bitmap 中标记为 1；</li><li>如果增加商品，需要完成元素对 bloom 的添加（此时就出现了双写的问题——数据既要添加数据库，又需要添加布隆过滤器，怎么保证这两个操作的原子性？）</li></ol></blockquote><h2 id="2、缓存击穿"><a href="#2、缓存击穿" class="headerlink" title="2、缓存击穿"></a>2、缓存击穿</h2><h3 id="2-1、概念"><a href="#2-1、概念" class="headerlink" title="2.1、概念"></a>2.1、概念</h3><p>&emsp;&emsp;<font color='red'><strong>少量的 key 过期时，恰好有大量的并发同时请求此数据。</strong></font></p><p>&emsp;&emsp;不管是设置 key 的有效期，还是通过 LRU 内存自动回收，总会有长期没被访问的冷数据会从内存中剔除，恰好在过期这一时刻，有<strong>大量并发</strong>同时请求此数据，此时 Redis 缓存中没数据，大量并发就会压到数据库。</p><blockquote><p>注意：条件一定是大量并发同时到达，因为如果只有少量请求，并不会给数据库带来严重的压力。</p></blockquote><h3 id="2-2、解决方案"><a href="#2-2、解决方案" class="headerlink" title="2.2、解决方案"></a>2.2、解决方案</h3><p><img src="http://cheng_qiwei.gitee.io/blog/img/20201003165754472.jpg" alt="在这里插入图片描述"></p><p>&emsp;&emsp;对于缓存击穿这种情况，我们可以给第一个请求线程加锁，后续的请求得不到锁就不能请求数据库。第一个请求把数据 load 到Redis，后续请求直接从 Redis 中获取数据，无需查询数据库。</p><blockquote><p>利用 redis 是单进程单实例，所有请求排队请求 Redis </p><ol><li>请求redis，没有值；</li><li>抢锁setnx px，这里分抢到和没抢到；<pre><code>2.1.抢到锁的查询DB；2.2.抢不到锁的sleep（或者服务治理返回）；</code></pre></li><li>更新redis数据，删除锁；</li><li>sleep苏醒的线程回到第一步。</li></ol></blockquote><h3 id="2-3、加锁会产生的问题"><a href="#2-3、加锁会产生的问题" class="headerlink" title="2.3、加锁会产生的问题"></a>2.3、加锁会产生的问题</h3><h4 id="2-3-1、死锁"><a href="#2-3-1、死锁" class="headerlink" title="2.3.1、死锁"></a>2.3.1、死锁</h4><p>&emsp;&emsp;由于第一个获得锁的线程到达数据库的时候，出现意外情况，此线程挂掉了，后续的请求就无法获得锁，出现了死锁，后续的请求也都无法获得锁，就会造成服务不可用。</p><p><strong>解决方案：</strong>可以在加锁的时候设置锁的过期时间，这样就不会出现死锁。</p><h4 id="2-3-2、锁误删"><a href="#2-3-2、锁误删" class="headerlink" title="2.3.2、锁误删"></a>2.3.2、锁误删</h4><p>&emsp;&emsp;业务执行时间过久，造成锁已失效，在此期间其他线程抢占了锁，当前线程执行解锁误删其他线程的锁。</p><p><strong>解决方案：</strong>设置value为当前线程的操作标识（可以是随机数），删除时取出该值进行判断，看是否为当前线程持有的锁，是才进行删除。</p><p>&emsp;&emsp;当前线程取出value值判断锁为本线程持有，到删除之间存在时间差，可能因为锁失效缘故造成其他线程再次期间抢占到了锁。</p><p><strong>解决方案：</strong>保证get操作和del操作的原子性，使用lua脚本或者事务。</p><h4 id="2-3-3、锁超时"><a href="#2-3-3、锁超时" class="headerlink" title="2.3.3、锁超时"></a>2.3.3、锁超时</h4><p>&emsp;&emsp;在上面设置过期时间的基础上，如果第一个没挂，但是数据库出现拥堵，锁超时了会释放锁，后续的获得了锁，继续拥堵，造成服务阻塞不可用。</p><p><strong>解决方案：</strong>使用多线程，一个线程取DB，另一个线程监控是否取回来，如果没有就更新锁时间，可以使用Redisson解决方案。</p><h2 id="3、缓存雪崩"><a href="#3、缓存雪崩" class="headerlink" title="3、缓存雪崩"></a>3、缓存雪崩</h2><h3 id="3-1、概念"><a href="#3-1、概念" class="headerlink" title="3.1、概念"></a>3.1、概念</h3><p>&emsp;&emsp;<font color='red'><strong>大量的 key 同时失效，间接造成大量的访问到达数据库</strong></font></p><p>&emsp;&emsp;缓存雪崩和缓存击穿很像：缓存击穿是有一个key过期，恰好大量的请求同时到达，这种情况好像很难很难很难发生。而缓存雪崩是比如零点的时候一批几百个 key 会被清除，此时每个 key 有二三十个请求，算起来就会有就会有几万并发，同样会给数据库带来一定的压力，这种情况不像缓存击穿那么极端，是很有出现的。</p><h3 id="3-2、解决方案"><a href="#3-2、解决方案" class="headerlink" title="3.2、解决方案"></a>3.2、解决方案</h3><p><img src="http://cheng_qiwei.gitee.io/blog/img/20201003170150288.jpg" alt="在这里插入图片描述"></p><p>&emsp;&emsp;缓存雪崩的解决方案，有以下两个方面：</p><blockquote><ol><li>对于时点性无关的数据，如果出现缓存雪崩，说明过期时间的设置可能存在问题，此时可以将过期是按设置相对均匀分布。</li><li>而对于有些和时点性相关的数据，例如：在晚上零点会删除一批数据，压上新的数据。而此时是有概率发生缓存雪崩的，可以在前面的业务代码进行处理，在该段时间进行零点延时（让业务sleep几秒），在此处理完所有更新请求，不要把流量放行到数据库。</li></ol></blockquote><h2 id="4、缓存的双写一致性"><a href="#4、缓存的双写一致性" class="headerlink" title="4、缓存的双写一致性"></a>4、缓存的双写一致性</h2><p>先更新数据库，后更新缓存</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B401.png" alt="img"></p><p>由图可知：</p><ul><li>请求A先更新DB</li><li>请求B也更新DB</li><li>但是因为网络等原因，B却比A更早更新了缓存。</li><li>导致数据的不一致，出现脏数据</li></ul><p>先更新数据库，后删除缓存</p><ul><li>更新DB成功</li><li>删除缓存失败</li><li>导致缓存数据为旧数据，出现脏数据</li></ul><p>先更新缓存，后更新数据库</p><ul><li>更新缓存成功</li><li>更新DB失败</li><li>导致数据不一致，出现脏数据</li></ul><p>先删除缓存，后更新数据库</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B404.png" alt="img"></p><p>由图可知：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 如果同时有一个请求A先删除，再进行更新操作</span><br><span class="line">- 中间另一个请求B进行查询发现没有缓存，查询了DB更新了缓存</span><br><span class="line">- 之后A再更新DB</span><br><span class="line">- 导致数据的不一致，出现脏数据</span><br></pre></td></tr></table></figure><p>解决方案</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、消息队列</span><br><span class="line">2、canal</span><br></pre></td></tr></table></figure><h1 id="七、自定义RedisTemplate"><a href="#七、自定义RedisTemplate" class="headerlink" title="七、自定义RedisTemplate"></a>七、自定义RedisTemplate</h1><h2 id="1、引入依赖"><a href="#1、引入依赖" class="headerlink" title="1、引入依赖"></a>1、引入依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-json<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2、配置类"><a href="#2、配置类" class="headerlink" title="2、配置类"></a>2、配置类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.hash.Jackson2HashMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTemplateConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Jackson2HashMapper jackson2HashMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        jackson2HashMapper  = <span class="keyword">new</span> Jackson2HashMapper(objectMapper,<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringRedisTemplate <span class="title">objectTemplate</span><span class="params">(RedisConnectionFactory fc)</span></span>&#123;</span><br><span class="line">        StringRedisTemplate stringRedisTemplate = <span class="keyword">new</span> StringRedisTemplate(fc);</span><br><span class="line">        stringRedisTemplate.setHashValueSerializer(<span class="keyword">new</span> Jackson2JsonRedisSerializer&lt;&gt;(Object.class));</span><br><span class="line">        <span class="keyword">return</span> stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">toHash</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; stringObjectMap = jackson2HashMapper.toHash(obj);</span><br><span class="line">        <span class="keyword">return</span> stringObjectMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ObjectMapper <span class="title">objectMapper</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> objectMapper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> Redis </tag>
            
            <tag> 消息 </tag>
            
            <tag> 布隆过滤器 </tag>
            
            <tag> 持久化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis介绍与命令</title>
      <link href="/blog/2021/06/07/Redis%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%91%BD%E4%BB%A4/"/>
      <url>/blog/2021/06/07/Redis%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis介绍与命令"><a href="#Redis介绍与命令" class="headerlink" title="Redis介绍与命令"></a>Redis介绍与命令</h1><h1 id="一、NoSQL简介"><a href="#一、NoSQL简介" class="headerlink" title="一、NoSQL简介"></a>一、NoSQL简介</h1><h2 id="1、什么是NoSQL"><a href="#1、什么是NoSQL" class="headerlink" title="1、什么是NoSQL"></a>1、什么是NoSQL</h2><p>&emsp;&emsp;NoSQL(<strong>NoSQL = Not Only SQL</strong>)，意即“不仅仅是SQL”，泛指非关系型的数据库。随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL 数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题，包括超大规模数据的存储。</p><h2 id="2、为什么需要NoSQL"><a href="#2、为什么需要NoSQL" class="headerlink" title="2、为什么需要NoSQL"></a>2、为什么需要NoSQL</h2><h3 id="2-1、易扩展"><a href="#2-1、易扩展" class="headerlink" title="2.1、易扩展"></a>2.1、易扩展</h3><p>&emsp;&emsp;NoSQL数据库种类繁多，但是一个共同的特点都是去掉关系数据库的关系型特性。数据之间无关系，这样就非常容易扩展。也无形之间，在架构的层面上带来了可扩展的能力。</p><h3 id="2-2、大数据量高性能"><a href="#2-2、大数据量高性能" class="headerlink" title="2.2、大数据量高性能"></a>2.2、大数据量高性能</h3><p>&emsp;&emsp;NoSQL数据库都具有非常高的读写性能，尤其在大数据量下，同样表现优秀。这得益于它的无关系性，数据库的结构简单。</p><p>&emsp;&emsp;一般MySQL使用Query Cache，每次表的更新Cache就失效，是一种大粒度的Cache，在针对web2.0的交互频繁的应用，Cache性能不高。而NoSQL的Cache是记录级的，是一种细粒度的Cache，所以NoSQL在这个层面上来说就要性能高很多了。</p><h3 id="2-3、多样灵活的数据模型"><a href="#2-3、多样灵活的数据模型" class="headerlink" title="2.3、多样灵活的数据模型"></a>2.3、多样灵活的数据模型</h3><p>&emsp;&emsp;NoSQL无需事先为要存储的数据建立字段，随时可以存储自定义的数据格式。而在关系数据库里，增删字段是一件非常麻烦的事情。如果是非常大数据量的表，增加字段简直就是一个噩梦。</p><h2 id="3、NoSQL数据库的四大分类"><a href="#3、NoSQL数据库的四大分类" class="headerlink" title="3、NoSQL数据库的四大分类"></a>3、NoSQL数据库的四大分类</h2><h3 id="3-1、KV键值对"><a href="#3-1、KV键值对" class="headerlink" title="3.1、KV键值对"></a>3.1、KV键值对</h3><p>&emsp;&emsp;使用KV键值对的NoSQL有：Redis、memcache 、BerkeleyDB 等，各大公司使用KV键值对的NoSQL软件如下：</p><blockquote><p>新浪：BerkeleyDB + Redis<br>美团：Redis + tair<br>阿里、百度：memcache + Redis</p></blockquote><h3 id="3-2、文档型数据库"><a href="#3-2、文档型数据库" class="headerlink" title="3.2、文档型数据库"></a>3.2、文档型数据库</h3><p>&emsp;&emsp;文档型数据库一般使用<strong>bson格式</strong>比较多。使用文档型数据库的NoSQL有：CouchDB、MongoDB等。</p><h3 id="3-3、列存储数据库"><a href="#3-3、列存储数据库" class="headerlink" title="3.3、列存储数据库"></a>3.3、列存储数据库</h3><p>&emsp;&emsp;使用列存储数据库的NoSQL有：Cassandra、HBase等。</p><h3 id="3-4、图关系数据库"><a href="#3-4、图关系数据库" class="headerlink" title="3.4、图关系数据库"></a>3.4、图关系数据库</h3><p>&emsp;&emsp;它不是放图形的、放的是关系比如：朋友圈社交网络、广告推荐系统、社交网络、推荐系统。专注于构建关系图谱。使用图关系数据库的NoSQL有：Neo4j、InfoGrid等。</p><p><strong>NoSQL数据库四大分类对比如下：</strong></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/2021022516092576.png" alt="2021022516092576"></p><h1 id="二、Redis安装"><a href="#二、Redis安装" class="headerlink" title="二、Redis安装"></a>二、Redis安装</h1><p>&emsp;&emsp;Redis:REmote DIctionary Server(远程字典服务)。是由意大利人Salvatore Sanfilippo（网名：antirez）开发的一款内存高速<strong>缓存</strong>数据库。是完全开源免费的，用<strong>C语言</strong>编写的，遵守BSD协议，高性能的(<strong>key/value</strong>)<strong>分布式内存数据库</strong>，基于内存运行并支持<strong>持久化</strong>的<strong>NoSQL</strong>数据库。</p><h2 id="1、Redis官方地址"><a href="#1、Redis官方地址" class="headerlink" title="1、Redis官方地址"></a>1、Redis官方地址</h2><p>官方地址：<a href="https://redis.io/">https://redis.io/</a></p><p>中文网地址：<a href="http://www.redis.cn/">http://www.redis.cn/</a></p><p>Github地址：<a href="https://github.com/http://cheng_qiwei.gitee.io/blog/img/redis">https://github.com/http://cheng_qiwei.gitee.io/blog/img/redis</a></p><h2 id="2、下载安装包"><a href="#2、下载安装包" class="headerlink" title="2、下载安装包"></a>2、下载安装包</h2><p>&emsp;&emsp;本次使用的是Redis 6.2.4版本，进入官方地址后下载对应安装包即可。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210614180221234.png" alt="image-20210614180221234"></p><p>&emsp;&emsp;Linux环境直接执行以下命令即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://download.redis.io/releases/redis-6.2.4.tar.gz</span><br></pre></td></tr></table></figure><h2 id="3、安装Redis"><a href="#3、安装Redis" class="headerlink" title="3、安装Redis"></a>3、安装Redis</h2><h3 id="3-1、解压Redis"><a href="#3-1、解压Redis" class="headerlink" title="3.1、解压Redis"></a>3.1、解压Redis</h3><p>&emsp;&emsp;将Redis解压到安装目录<code>/usr/local</code>上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxf redis-6.2.4.tar.gz -C /usr/<span class="built_in">local</span></span><br></pre></td></tr></table></figure><h3 id="3-2、编译安装"><a href="#3-2、编译安装" class="headerlink" title="3.2、编译安装"></a>3.2、编译安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> redis-6.2.4 &amp;&amp; make</span><br><span class="line"></span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210614181636058.png" alt="image-20210614181636058"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210614181806842.png" alt="image-20210614181806842"></p><blockquote><p>安装完成后进入bin目录下，可以看到以下内容</p><ol><li>redis-benchmark redis性能测试工具</li><li>redis-check-aof AOF文件修复工具</li><li>redis-check-rdb RDB文件修复工具</li><li>redis-cli redis命令行客户端</li><li>redis.conf redis配置文件</li><li>redis-sentinal redis集群管理工具</li><li>redis-server redis服务进程</li></ol></blockquote><h3 id="3-3、启动Redis"><a href="#3-3、启动Redis" class="headerlink" title="3.3、启动Redis"></a>3.3、启动Redis</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/redis &amp;&amp; ./bin/redis-server ./redis.conf</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;按照正常情况下，以下命令即可启动redis，但是你会发现启动完成后你的窗口就不能做其他工作了，所以需要配置后台启动。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拷贝配置文件</span></span><br><span class="line">cp /usr/<span class="built_in">local</span>/redis-6.2.4/redis.conf /usr/<span class="built_in">local</span>/bin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改配置文件</span></span><br><span class="line">vim /usr/<span class="built_in">local</span>/bin/redis.conf</span><br><span class="line">...</span><br><span class="line">daemonize yes</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动redis</span></span><br><span class="line">/usr/<span class="built_in">local</span>/bin/redis-server /usr/<span class="built_in">local</span>/bin/redis.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看启动情况</span></span><br><span class="line">ps -ef | grep redis</span><br><span class="line">losf -i:6379</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210614191126800.png" alt="image-20210614191126800"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210614191702361.png" alt="image-20210614191702361"></p><h3 id="3-4、连接Redis"><a href="#3-4、连接Redis" class="headerlink" title="3.4、连接Redis"></a>3.4、连接Redis</h3><p>&emsp;&emsp;我们可以使用Redis自带的客户端redis-cli redis命令行客户端进行连接。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 6379</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入ping测试是否连接成功，返回pong为成功</span></span><br><span class="line">ping</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在启动命令中添加 --raw 可以使中文不乱码</span></span><br><span class="line">redis-cli -p 6379 --raw</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210614192656994.png" alt="image-20210614192656994"></p><h3 id="3-5、关闭Redis"><a href="#3-5、关闭Redis" class="headerlink" title="3.5、关闭Redis"></a>3.5、关闭Redis</h3><p>&emsp;&emsp;redis-cli shutdown：安全关闭，如果有密码需要加上 -a {password} 参数（<strong>推荐使用</strong>此方式关闭，会进行持久化文件生成，能够防止数据丢失）。</p><h1 id="三、Redis命令"><a href="#三、Redis命令" class="headerlink" title="三、Redis命令"></a>三、Redis命令</h1><h2 id="1、通用命令"><a href="#1、通用命令" class="headerlink" title="1、通用命令"></a>1、通用命令</h2><table><thead><tr><th align="left">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="left">DEL key</td><td align="center">当 key 存在时删除 key</td></tr><tr><td align="left">FLUSHDB</td><td align="center">清除当前数据库数据</td></tr><tr><td align="left">FLUSHALL</td><td align="center">清除所有数据库数据</td></tr><tr><td align="left">SCAN cursor</td><td align="center">游标扫描匹配的key</td></tr><tr><td align="left">KEYS  pattern</td><td align="center">查找所有符合匹配模式 pattern 的 key</td></tr><tr><td align="left">DBSIZE</td><td align="center">返回当前数据库的 key 的数量</td></tr><tr><td align="left">SELECT dbnum</td><td align="center">切换数据库</td></tr><tr><td align="left">EXISTS key</td><td align="center">检查给定 key 是否存在</td></tr><tr><td align="left">TYPE key</td><td align="center">返回 key 所储存的值的类型</td></tr><tr><td align="left">MOVE key db</td><td align="center">将当前数据库的 key 移动到给定的数据库 db 当中</td></tr><tr><td align="left">RANDOMKEY</td><td align="center">从当前数据库中随机返回一个 key</td></tr><tr><td align="left">RENAME key newkey</td><td align="center">修改 key 的名称</td></tr><tr><td align="left">RENAMENX key newkey</td><td align="center">仅当 newkey 不存在时，将 key 改名为 newkey</td></tr><tr><td align="left">OBJECT encoding key</td><td align="center">查看键对应值的类型（int raw等等）</td></tr></tbody></table><p><strong>过期时间相关命令</strong></p><table><thead><tr><th align="left">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="left">EXPIRE key seconds</td><td align="center">为给定 key 设置过期时间，单位：秒</td></tr><tr><td align="left">EXPIREAT key timestamp</td><td align="center">为给定 key 设置过期时间，单位： UNIX 时间戳(unix timestamp)。</td></tr><tr><td align="left">PEXPIRE key milliseconds</td><td align="center">为给定 key 设置过期时间，单位：毫秒</td></tr><tr><td align="left">PEXPIREAT key milliseconds-timestamp</td><td align="center">设置 key 过期时间的时间戳(unix timestamp) 以毫秒计</td></tr><tr><td align="left">PTTL key</td><td align="center">以毫秒为单位，返回 key 的剩余的过期时间</td></tr><tr><td align="left">TTL key</td><td align="center">以秒为单位，返回给定 key 的剩余生存时间</td></tr><tr><td align="left">PERSIST key</td><td align="center">移除 key 的过期时间，key 将持久保持</td></tr></tbody></table><h2 id="2、string命令"><a href="#2、string命令" class="headerlink" title="2、string命令"></a>2、string命令</h2><p>&emsp;&emsp;string是redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。string类型是Redis最基本的数据类型，<strong>一个redis中字符串value最多可以是512M</strong>。</p><h3 id="2-1、Redis字符串类型键的设置和查询"><a href="#2-1、Redis字符串类型键的设置和查询" class="headerlink" title="2.1、Redis字符串类型键的设置和查询"></a>2.1、Redis字符串类型键的设置和查询</h3><blockquote><p>参考案例：</p><p>案例一：高速缓存（HTML / DATA / SESSION）</p><p>案例二：分布式锁</p><p>案例三：防止重复提交</p><p>案例四：存储设置固定格式的字符串序列（例如：时间序列）</p></blockquote><table><thead><tr><th align="left">命令</th><th>描述</th><th>参数解析</th></tr></thead><tbody><tr><td align="left">SET key value [EX seconds] [PX milliseconds] [NX|XX]</td><td>设置指定 key 的值，如果 key 已经持有其他值， SET 就覆写旧值， 无视类型</td><td><strong>EX seconds</strong> ： 将键的过期时间设置为 seconds 秒。 执行 SET key value EX seconds 的效果等同于执行 SETEX key seconds value 。            <br/><strong>PX milliseconds</strong> ： 将键的过期时间设置为 milliseconds 毫秒。 执行 SET key value PX milliseconds 的效果等同于执行 PSETEX key milliseconds value 。<br/><strong>NX **： 只在键不存在时， 才对键进行设置操作。 执行 SET key value NX 的效果等同于执行 SETNX key value 。<br/>**XX</strong> ： 只在键已经存在时， 才对键进行设置操作。</td></tr><tr><td align="left">MSET key value [ key value … ]</td><td>同时设置一个或多个 key-value 对</td><td>成功返回OK。</td></tr><tr><td align="left">SETEX key seconds value</td><td>将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位)</td><td>如果键 key 已经存在， 那么 SETEX 命令将覆盖已有的值。<br/>SETEX 和SET EXPIRE这两个命令的不同之处在于 SETEX 是一个原子（atomic）操作， 它可以在同一时间内完成设置值和设置过期时间这两个操作， 因此 SETEX 命令在储存缓存的时候非常实用。</td></tr><tr><td align="left">PSETEX key milliseconds value</td><td>将值 value 关联到 key ，并将 key 的过期时间设为 milliseconds (以毫秒为单位)</td><td>这个命令和 SETEX 命令功能相同，但它以毫秒为单位设置 key 的生存时间。</td></tr><tr><td align="left">SETNX key value</td><td>只有在 key 不存在时设置 key 的值为value</td><td>若键 key 已经存在， 则 SETNX 命令不做任何动作。设置成功时返回 1 ， 设置失败时返回 0 。</td></tr><tr><td align="left">MSETNX key value [key value …]</td><td>同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在</td><td>同时设置多个key，如果其中一个key存在则设置失败，不考虑其他键是否存在。 msetnx 是原子的，所有键会同时设置成功或者失败。</td></tr><tr><td align="left">SETRANGE key offset value</td><td>用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始。</td><td>不存在的键 key 当作空白字符串处理。<br/>SETRANGE 命令会确保字符串足够长以便将 value 设置到指定的偏移量上， 如果键 key 原来储存的字符串长度比偏移量小(比如字符串只有 5 个字符长，但你设置的 offset 是 10 )， 那么原字符和偏移量之间的空白将用零字节(zerobytes, “\x00” )进行填充。<br/>因为 Redis 字符串的大小被限制在 512 兆(megabytes)以内， 所以用户能够使用的最大偏移量为 2^29-1(536870911) ， 如果你需要使用比这更大的空间， 请使用多个 key 。</td></tr><tr><td align="left">APPEND key value</td><td>如果 key 已经存在并且是一个字符串， APPEND 命令将指定的 value 追加到该 key 原来值（value）的末尾</td><td>如果 key 不存在， APPEND 就简单地将键 key 的值设为 value ， 就像执行 SET key value 一样。追加 value 之后， 返回键 key 的值的长度。</td></tr><tr><td align="left">GET key</td><td>获取指定 key 的值</td><td>如果键 key 不存在， 那么返回特殊值 nil ； 否则， 返回键 key 的值 ； 如果键 key 的值并非字符串类型， 那么返回一个错误， 因为 GET 命令只能用于字符串值。</td></tr><tr><td align="left">MGET [key1 key2…]</td><td>获取所有(一个或多个)给定 key 的值</td><td></td></tr><tr><td align="left">GETRANGE key start end</td><td>返回 key 中字符串值的子字符</td><td>返回键 key 储存的字符串值的指定部分， 字符串的截取范围由 start 和 end 两个偏移量决定 (包括 start 和 end 在内)。<br/>负数偏移量表示从字符串的末尾开始计数， -1 表示最后一个字符， -2 表示倒数第二个字符， 以此类推。<br/>GETRANGE 通过保证子字符串的值域(range)不超过实际字符串的值域来处理超出范围的值域请求。</td></tr><tr><td align="left">GETSET key value</td><td>将给定 key 的值设为 value ，并返回 key 的旧值</td><td>如果键 key 没有旧值， 也即是说， 键 key 在被设置之前并不存在， 那么命令返回 nil 。当键 key 存在但不是字符串类型时， 命令返回一个错误。</td></tr><tr><td align="left">STRLEN key</td><td>返回 key 所储存的字符串值的长度。</td><td>当键 key 不存在时， 命令返回 0 。当 key 储存的不是字符串值时， 返回一个错误。</td></tr></tbody></table><h3 id="2-2、Redis字符串类型键的计数操作"><a href="#2-2、Redis字符串类型键的计数操作" class="headerlink" title="2.2、Redis字符串类型键的计数操作"></a>2.2、Redis字符串类型键的计数操作</h3><blockquote><p>参考案例：</p><p>案例一：统计网站访问者数量</p><p>案例二：每天注册用户数</p><p>案例三：限制API在某一时段的访问次数</p></blockquote><table><thead><tr><th align="left">命令</th><th>描述</th><th>参数解析</th></tr></thead><tbody><tr><td align="left">INCR key</td><td>将 key 中储存的数字值增一</td><td>如果键 key 不存在， 那么它的值会先被初始化为 0 ， 然后再执行 INCR 命令。<br/>如果键 key 储存的值不能被解释为数字， 那么 INCR 命令将返回一个错误。<br/>本操作的值限制在 64 位(bit)有符号数字表示之内。<br/>返回键 key 在执行加一操作之后的值。</td></tr><tr><td align="left">INCRBY key increment</td><td>将 key 所储存的值加上给定的增量值</td><td>同上</td></tr><tr><td align="left">INCRBYFLOAT key increment</td><td>将 key 所储存的值加上给定的增量值，增加量为小数</td><td>计算结果最多只保留小数点的后十七位。<br/>键 key 当前的值或者给定的增量 increment 不能被解释(parse)为双精度浮点数时返回异常。</td></tr><tr><td align="left">DECR key</td><td>将 key 中储存的数字值减一</td><td>如果键 key 不存在， 那么它的值会先被初始化为 0 ， 然后再执行 DECR 命令。<br/>如果键 key 储存的值不能被解释为数字， 那么 DECR 命令将返回一个错误。<br/>本操作的值限制在 64 位(bit)有符号数字表示之内。<br/>返回键 key 在执行减一操作之后的值。</td></tr><tr><td align="left">DECRBY key decrement</td><td>将 key 所储存的减少给定的减量值</td><td>同上</td></tr></tbody></table><h3 id="2-3、Redis字符串类型键的二进制操作（Bitmap位图）"><a href="#2-3、Redis字符串类型键的二进制操作（Bitmap位图）" class="headerlink" title="2.3、Redis字符串类型键的二进制操作（Bitmap位图）"></a>2.3、Redis字符串类型键的二进制操作（Bitmap位图）</h3><blockquote><p>参考案例：</p><p>案例一：用户签到</p><p>案例二：统计活跃用户</p><p>案例三：用户在线状态</p></blockquote><table><thead><tr><th align="left">命令</th><th>描述</th><th>参数解析</th></tr></thead><tbody><tr><td align="left">GETBIT key offset</td><td>对 key 所储存的字符串值，获取指定偏移量上的位(bit)</td><td>当 offset 比字符串值的长度大，或者 key 不存在时，返回 0 。<br/>字符串值指定偏移量上的位(bit)。</td></tr><tr><td align="left">SETBIT key offset value</td><td>对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。</td><td>当 key 不存在时，自动生成一个新的字符串值。</td></tr><tr><td align="left">BITCOUNT  key [start] [end]</td><td>计算给定字符串中，被设置为 1 的比特位的数量。</td><td>一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行。 返回值： 不存在的 key 被当成是空字符串来处理，因此对一个不存在的 key 进行 BITCOUNT 操作，结果为 0 / 被设置为 1 的位的数量。</td></tr><tr><td align="left">BITOP operation destkey key [key …]</td><td>对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。</td><td>OPERATION： 可以是 AND 、 OR 、 NOT 、 XOR 这四种操作中的任意一种。 除了 NOT 操作之外，其他操作都可以接受一个或多个 key 作为输入。 <br/>注意： 当 bitop 处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 0 。空的 key 也被看作是包含 0 的字符串序列。 返回值： 保存到 destkey 的字符串的长度，和输入 key 中最长的字符串长度相等。</td></tr><tr><td align="left">BITPOP key bit [start] [end]</td><td>返回字符串里面第一个被设置为1或者0的bit位。</td><td>命令返回字符串里面第一个被设置为1或者0的bit位。 如果我们在空字符串或者0字节的字符串里面查找bit为1的内容，那么结果将返回-1。</td></tr><tr><td align="left">BITFIELD key [GET type offset] [SET type offset value] [INCRBY type offset increment] [OVERFLOW WRAP|SAT|FAIL]</td><td>把Redis字符串当作位数组，并能对变长位宽和任意未字节对齐的指定整型位域进行寻址。</td><td>把Redis字符串当作位数组，并能对变长位宽和任意未字节对齐的指定整型位域进行寻址。在实践中，可以使用该命令对一个有符号的5位整型数的1234位设置指定值，也可以对一个31位无符号整型数的4567位进行取值。类似地，在对指定的整数进行自增和自减操作，本命令可以提供有保证的、可配置的上溢和下溢处理操作。 返回值： get 当前偏移位置所在的值。 set 当前偏移量的旧值。 incrby 当前偏移量的旧值。 nil 设置失败。 值的类型有误或者命令语法有误返回错误。<br/>返回值：<br/>a、get 当前偏移位置所在的值。 <br/>b、set 当前偏移量的旧值。 <br/>c、incrby 当前偏移量的旧值。 <br/>d、nil 设置失败。</td></tr></tbody></table><h2 id="3、Hash命令"><a href="#3、Hash命令" class="headerlink" title="3、Hash命令"></a>3、Hash命令</h2><p>&emsp;&emsp;Redis hash 是一个键值对集合，类似Java里面的Map&lt;String,Object&gt;。Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。</p><table><thead><tr><th align="left">命令</th><th align="left">描述</th><th>参数解析</th></tr></thead><tbody><tr><td align="left">HSET key field value</td><td align="left">将哈希表 key 中的字段 field 的值设为 value</td><td>如果给定的哈希表并不存在， 那么一个新的哈希表将被创建并执行 HSET 操作。如果域 field 已经存在于哈希表中， 那么它的旧值将被新值 value 覆盖。<br/>当 HSET 命令在哈希表中新创建 field 域并成功为它设置值时， 命令返回 1 ； 如果域 field 已经存在于哈希表， 并且 HSET 命令成功使用新值覆盖了它的旧值， 那么命令返回 0</td></tr><tr><td align="left">HSETNX key field value</td><td align="left">只有在字段 field 不存在时，设置哈希表字段的值</td><td>如果给定域已经存在于哈希表当中， 那么命令将放弃执行设置操作。<br/>在设置成功时返回 1 ， 在给定域已经存在而放弃执行设置操作时返回 0 。</td></tr><tr><td align="left">HMSET key field1 value1 [field2 value2 ]</td><td align="left">同时将多个 field-value (域-值)对设置到哈希表 key 中</td><td>此命令会覆盖哈希表中已存在的域。<br/>如果 key 不存在，一个空哈希表被创建并执行 HMSET 操作。</td></tr><tr><td align="left">HGET key field</td><td align="left">获取存储在哈希表中指定字段的值</td><td>如果给定域不存在于哈希表中， 又或者给定的哈希表并不存在， 那么命令返回 nil 。</td></tr><tr><td align="left">HMGET key field1 [field2]</td><td align="left">获取所有给定字段的值</td><td></td></tr><tr><td align="left">HGETALL key</td><td align="left">获取在哈希表中指定 key 的所有字段和值</td><td>如果给定的域不存在于哈希表，那么返回一个 nil 值。<br/>因为不存在的 key 被当作一个空哈希表来处理，所以对一个不存在的 key 进行 HMGET 操作将返回一个只带有 nil 值的表。</td></tr><tr><td align="left">HEXISTS key field</td><td align="left">查看哈希表 key 中，指定的字段是否存在</td><td>在给定field存在时返回 1 ， 在给定field不存在时返回 0 。</td></tr><tr><td align="left">HKEYS key</td><td align="left">获取所有哈希表中的字段</td><td></td></tr><tr><td align="left">HLEN key</td><td align="left">获取哈希表中字段的数量</td><td>当 key 不存在时，返回 0 。</td></tr><tr><td align="left">HVALS key</td><td align="left">获取哈希表中所有值</td><td></td></tr><tr><td align="left">HDEL key field1 [field2]</td><td align="left">删除一个或多个哈希表字段</td><td>删除哈希表 key 中的一个或多个指定域，不存在的域将被忽略。<br/>被成功移除的域的数量，不包括被忽略的域。</td></tr><tr><td align="left">HSCAN key cursor [MATCH pattern] [COUNT count]</td><td align="left">迭代哈希表中的键值对</td><td>简单来讲，这个命令就是可以将Key中的某些有相同规则的键找出来。pattern是规则，cursor是指光标，我们输入0即可。Count这个参数似乎在数据量较小的情况下不会生效。<br/>返回的每个元素都是一个键值对，一个键值对由一个键和一个值组成。</td></tr><tr><td align="left">HINCRBY key field increment</td><td align="left">为哈希表 key 中的指定字段的整数值加上增量 increment</td><td>为哈希表 key 中的指定字段的浮点数值加上增量 increment <br/>如果 key 不存在，一个新的哈希表被创建并执行 HINCRBY 命令。<br/>如果域 field 不存在，那么在执行命令前，域的值被初始化为 0 。<br/>对一个储存字符串值的域 field 执行 HINCRBY 命令将造成一个错误。<br/>本操作的值被限制在 64 位(bit)有符号数字表示之内。</td></tr><tr><td align="left">HINCRBYFLOAT key field increment</td><td align="left">为哈希表 key 中的指定字段的浮点数值加上增量 increment</td><td>同上</td></tr></tbody></table><h2 id="4、List命令"><a href="#4、List命令" class="headerlink" title="4、List命令"></a>4、List命令</h2><p>&emsp;&emsp;Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）。它的底层实际是个双向链表。</p><table><thead><tr><th align="left">命令</th><th align="left">描述</th><th>参数解析</th></tr></thead><tbody><tr><td align="left">LPUSH key value1 [value2]</td><td align="left">将一个或多个值插入到列表头部</td><td>如果有多个 value 值，那么各个 value 值按从左到右的顺序依次插入到表头： 比如说，对空列表 mylist 执行命令 LPUSH mylist a b c ，列表的值将是 c b a 。<br/>如果 key 不存在，一个空列表会被创建并执行 LPUSH 操作。<br/>当 key 存在但不是列表类型时，返回一个错误。</td></tr><tr><td align="left">LPUSHX key value</td><td align="left">将一个值插入到已存在的列表头部</td><td>将值 value 插入到列表 key 的表头，当且仅当 key 存在并且是一个列表。Key 不存在时则不进行操作。</td></tr><tr><td align="left">LSET key index value</td><td align="left">通过索引设置列表元素的值</td><td>当 index 参数超出范围，或对一个空列表( key 不存在)进行 LSET 时，返回一个错误。</td></tr><tr><td align="left">LINSERT key BEFORE|AFTER pivot value</td><td align="left">在列表的元素前或者后插入元素</td><td>当 pivot 不存在于列表 key 时，不执行任何操作，返回 -1 。       <br/>当 key 不存在时， key 被视为空列表，不执行任何操作，返回 0 。<br/>如果 key 不是列表类型，返回一个错误。</td></tr><tr><td align="left">LRANGE key start stop</td><td align="left">获取列表指定范围内的元素</td><td>下标(index)参数 start 和 stop 都以 0 为底，也就是说，以 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。<br/>如果 start 下标比列表的最大下标 end ( LLEN list 减去 1 )还要大，那么 LRANGE 返回一个空列表。如果 stop 下标比 end 下标还要大，Redis将 stop 的值设置为 end 。</td></tr><tr><td align="left">LPOP key</td><td align="left">移出并获取列表的第一个元素</td><td>列表的头元素。 当 key 不存在时，返回 nil 。</td></tr><tr><td align="left">LINDEX key index</td><td align="left">通过索引获取列表中的元素</td><td>下标(index)参数 start 和 stop 都以 0 为底，也就是说，以 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推 。你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。如果 key 不是列表类型，返回一个错误。</td></tr><tr><td align="left">LLEN key</td><td align="left">获取列表长度</td><td>如果 key 不存在，则 key 被解释为一个空列表，返回 0 。如果 key 不是列表类型，返回一个错误。</td></tr><tr><td align="left">LREM key count value</td><td align="left">移除列表元素</td><td>count &gt; 0 : 从表头开始向表尾搜索，移除与 value 相等的元素，数量为 count 。<br/>count &lt; 0 : 从表尾开始向表头搜索，移除与 value 相等的元素，数量为 count 的绝对值。<br/> count = 0 : 移除表中所有与 value 相等的值。</td></tr><tr><td align="left">LTRIM key start stop</td><td align="left">对一个列表进行修剪(trim)</td><td>让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</td></tr><tr><td align="left">RPUSH key value1 [value2]</td><td align="left">将一个或多个值 value 插入到列表 key 的表尾(最右边)</td><td>如果有多个 value 值，那么各个 value 值按从左到右的顺序依次插入到表尾：比如对一个空列表 mylist 执行 RPUSH mylist a b c ，得出的结果列表为 a b c 。<br/> 如果 key 不存在，一个空列表会被创建并执行 RPUSH 操作。当 key 存在但不是列表类型时，返回一个错误。</td></tr><tr><td align="left">RPUSHX key value</td><td align="left">将值 value 插入到列表 key 的表尾，当且仅当 key 存在并且是一个列表</td><td>和 RPUSH key value [value …] 命令相反，当 key 不存在时， RPUSHX 命令什么也不做。</td></tr><tr><td align="left">RPOP key</td><td align="left">移除列表的最后一个元素，返回值为移除的元素</td><td></td></tr><tr><td align="left">RPOPLPUSH source destination</td><td align="left">移除列表的最后一个元素，并将该元素添加到另一个列表并返回</td><td>命令 RPOPLPUSH 在一个原子时间内，执行以下两个动作：<br/>将列表 source 中的最后一个元素(尾元素)弹出，并返回给客户端。<br/>将 source 弹出的元素插入到列表 destination ，作为 destination 列表的的头元素。<br/>如果 source 不存在，值 nil 被返回，并且不执行其他动作。<br/>如果 source 和 destination 相同，则列表中的表尾元素被移动到表头，并返回该元素，可以把这种特殊情况视作列表的旋转(rotation)操作。</td></tr><tr><td align="left">BLPOP key1 [key2 ] timeout</td><td align="left">移出并获取列表的第一个元素</td><td>它是 LPOP key 命令的阻塞版本，当给定列表内没有任何元素可供弹出的时候，连接将被 BLPOP 命令阻塞，直到等待超时或发现可弹出元素为止。<br/>当给定多个 key 参数时，按参数 key 的先后顺序依次检查各个列表，弹出第一个非空列表的头元素。<br/>如果列表为空，返回一个 nil 。 否则，返回一个含有两个元素的列表，第一个元素是被弹出元素所属的 key ，第二个元素是被弹出元素的值</td></tr><tr><td align="left">BRPOP key1 [key2] timeout</td><td align="left">移出并获取列表的最后一个元素</td><td>它是 RPOP key 命令的阻塞版本，当给定列表内没有任何元素可供弹出的时候，连接将被 BRPOP 命令阻塞，直到等待超时或发现可弹出元素为止。<br/>当给定多个 key 参数时，按参数 key 的先后顺序依次检查各个列表，弹出第一个非空列表的尾部元素。<br/>假如在指定时间内没有任何元素被弹出，则返回一个 nil 和等待时长。 反之，返回一个含有两个元素的列表，第一个元素是被弹出元素所属的 key ，第二个元素是被弹出元素的值。</td></tr><tr><td align="left">BRPOPLPUSH source destination timeout</td><td align="left">从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它</td><td>BRPOPLPUSH 是 RPOPLPUSH source destination 的阻塞版本，当给定列表 source 不为空时， BRPOPLPUSH 的表现和 RPOPLPUSH source destination 一样。<br/>当列表 source 为空时， BRPOPLPUSH 命令将阻塞连接，直到等待超时，或有另一个客户端对 source 执行 LPUSH key value [value …] 或 RPUSH key value [value …] 命令为止。<br/>超时参数 timeout 接受一个以秒为单位的数字作为值。超时参数设为 0 表示阻塞时间可以无限期延长(block indefinitely) 。<br/>假如在指定时间内没有任何元素被弹出，则返回一个 nil 和等待时长。 反之，返回一个含有两个元素的列表，第一个元素是被弹出元素的值，第二个元素是等待时长。</td></tr></tbody></table><h2 id="5、set命令"><a href="#5、set命令" class="headerlink" title="5、set命令"></a>5、set命令</h2><p>&emsp;&emsp;Redis的Set是string类型的无序集合。它是通过HashTable实现实现的。</p><table><thead><tr><th align="left">命令</th><th align="left">描述</th><th>参数解析</th></tr></thead><tbody><tr><td align="left">SADD key member1 [member2]</td><td align="left">向集合添加一个或多个成员，已经存在于集合的 member 元素将被忽略</td><td>假如 key 不存在，则创建一个只包含 member 元素作成员的集合。<br/>当 key 不是集合类型时，返回一个错误。</td></tr><tr><td align="left">SCARD key</td><td align="left">获取集合的元素数量</td><td>当 key 不存在时，返回 0 。</td></tr><tr><td align="left">SMEMBERS key</td><td align="left">返回集合中的所有成员</td><td>不存在的 key 被视为空集合。</td></tr><tr><td align="left">SISMEMBER key member</td><td align="left">判断 member 元素是否是集合 key 的成员</td><td>如果 member 元素是集合的成员，返回 1 。 如果 member 元素不是集合的成员，或 key 不存在，返回 0 。</td></tr><tr><td align="left">SREM key member1 [member2]</td><td align="left">移除集合中一个或多个成员</td><td>不存在的 member 元素会被忽略。当 key 不是集合类型，返回一个错误。同时，被成功移除的元素的数量，不包括被忽略的元素。</td></tr><tr><td align="left">SPOP key</td><td align="left">移除并返回集合中的一个随机元素</td><td>如果只想获取一个随机元素，但不想该元素从集合中被移除的话，可以使用 SRANDMEMBER key [count] 命令。<br/>被移除的随机元素。 当 key 不存在或 key 是空集时，返回 nil 。</td></tr><tr><td align="left">SRANDMEMBER key [count]</td><td align="left">返回集合中一个或多个随机数</td><td>从 Redis 2.6 版本开始， SRANDMEMBER 命令接受可选的 count 参数：<br/>a、 如果 count 为正数，且小于集合基数，那么命令返回一个包含 count 个元素的数组，数组中的元素各不相同。如果 count 大于等于集合基数，那么返回整个集合。<br/>b、 如果 count 为负数，那么命令返回一个数组，数组中的元素可能会重复出现多次，而数组的长度为 count 的绝对值。<br/>该操作和 SPOP key 相似，但 SPOP key 将随机元素从集合中移除并返回，而 SRANDMEMBER 则仅仅返回随机元素，而不对集合进行任何改动。</td></tr><tr><td align="left">SSCAN key cursor [MATCH pattern] [COUNT count]</td><td align="left">迭代集合中的元素</td><td>简单来讲，这个命令就是可以将集合中的某些有相同规则的内容找出来。pattern是规则。</td></tr><tr><td align="left">SMOVE source destination member 将 member</td><td align="left">元素从 source 集合移动到 destination 集合</td><td>如果 source 集合不存在或不包含指定的 member 元素，则 SMOVE 命令不执行任何操作，仅返回 0 。否则， member 元素从 source 集合中被移除，并添加到 destination 集合中去。<br/>当 destination 集合已经包含 member 元素时， SMOVE 命令只是简单地将 source 集合中的 member 元素删除。<br/>当 source 或 destination 不是集合类型时，返回一个错误。<br/>如果 member 元素被成功移除，返回 1 。 如果 member 元素不是 source 集合的成员，并且没有任何操作对 destination 集合执行，那么返回 0 。</td></tr><tr><td align="left">SDIFF key1 [key2]</td><td align="left">返回第一个集合与其他集合之间的差集</td><td>不存在的 key 被视为空集</td></tr><tr><td align="left">SDIFFSTORE destination key1 [key2]</td><td align="left">返回给定所有集合的差集并存储在 destination 中</td><td>如果 destination 集合已经存在，则将其覆盖。       <br/>destination 可以是 key 本身</td></tr><tr><td align="left">SINTER key1 [key2]</td><td align="left">返回给定所有集合的交集</td><td>不存在的 key 被视为空集。<br/>当给定集合当中有一个空集时，结果也为空集(根据集合运算定律)。</td></tr><tr><td align="left">SINTERSTORE destination key1 [key2]</td><td align="left">返回给定所有集合的交集并存储在 destination 中</td><td>如果 destination 集合已经存在，则将其覆盖。       <br/>destination 可以是 key 本身。</td></tr><tr><td align="left">SUNION key1 [key2]</td><td align="left">返回所有给定集合的并集</td><td>不存在的 key 被视为空集。</td></tr><tr><td align="left">SUNIONSTORE destination key1 [key2]</td><td align="left">所有给定集合的并集存储在 destination 集合中</td><td>如果 destination 已经存在，则将其覆盖。<br/>destination 可以是 key 本身。<br/>结果集中的元素数量。</td></tr></tbody></table><h2 id="6、Sorted-Set命令（ZSet）"><a href="#6、Sorted-Set命令（ZSet）" class="headerlink" title="6、Sorted Set命令（ZSet）"></a>6、Sorted Set命令（ZSet）</h2><p>&emsp;&emsp;Redis zset 和 set 一样也是string类型元素的集合，且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。Redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的，但分数(score)却可以重复。<br>&emsp;&emsp;Sorted Set实现方式：Redis Sorted Set 的内部使用 HashMap 和跳跃表（skipList）来保证数据的存储和有序，HashMap 里放的是成员到 Score 的映射。</p><h3 id="6-1、基本命令"><a href="#6-1、基本命令" class="headerlink" title="6.1、基本命令"></a>6.1、基本命令</h3><table><thead><tr><th align="left">命令</th><th align="left">描述</th><th>参数解析</th></tr></thead><tbody><tr><td align="left">ZADD key [NX|XX] [CH] [INCR] score member [score member …]</td><td align="left">向有序集合添加一个或多个成员，或者更新已存在成员的分数</td><td>如果某个 member 已经是有序集的成员，那么更新这个 member 的 score 值，并通过重新插入这个 member 元素，来保证该 member 在正确的位置上。       <br/>score 值可以是整数值或双精度浮点数。<br/>如果 key 不存在，则创建一个空的有序集并执行 ZADD 操作。<br/>当 key 存在但不是有序集类型时，返回一个错误。</td></tr><tr><td align="left">ZCARD key</td><td align="left">获取有序集合的成员数</td><td>当 key 不存在时，返回 0 。</td></tr><tr><td align="left">ZCOUNT key min max</td><td align="left">计算在有序集合中指定区间分数的成员数</td><td>score 值在 min 和 max 之间(默认包括 score 值等于 min 或 max )的成员的数量。</td></tr><tr><td align="left">ZINCRBY key increment member</td><td align="left">有序集合中对指定成员的分数加上增量 increment</td><td>可以通过传递一个负数值 increment ，让 score 减去相应的值<br/>当 key 不存在，或 member 不是 key 的成员时， ZINCRBY key increment member 等同于 ZADD key increment member 。当 key 不是有序集类型时，返回一个错误。<br/>score 值可以是整数值或双精度浮点数<br/>member 成员的新 score 值，以字符串形式表示。</td></tr><tr><td align="left">ZINTERSTORE destination numkeys key [key …]</td><td align="left">计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 destination 中</td><td>计算给定的一个或多个有序集的交集，其中给定 key 的数量必须以 numkeys 参数指定，并将该交集(结果集)储存到 destination 。<br/>默认情况下，结果集中某个成员的 score 值是所有给定集下该成员 score 值之和。<br/>WEIGHTS指定对应key的权重，redis该key对应值得分值乘上权重系数，再根据AGGREGATE聚合函数统计，默认相加。</td></tr><tr><td align="left">ZLEXCOUNT key min max</td><td align="left">在有序集合中计算指定字典区间内成员数量</td><td>对于一个所有成员的分值都相同的有序集合键 key 来说， 这个命令会返回该集合中， 成员介于 min 和 max 范围内的元素数量。<br/>这个命令的 min 参数和 max 参数的意义和 ZRANGEBYLEX key min max [LIMIT offset count] 命令的 min 参数和 max 参数的意义一样。</td></tr><tr><td align="left">ZRANGE key start stop [WITHSCORES]</td><td align="left">通过索引区间返回有序集合指定区间内的成员</td><td>其中成员的位置按 score 值递增(从小到大)来排序。具有相同 score 值的成员按字典序(lexicographical order )来排列。<br/>如果你需要成员按 score 值递减(从大到小)来排列，请使用 ZREVRANGE key start stop [WITHSCORES] 命令。<br/>下标参数 start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推。 你也可以使用负数下标，以 -1 表示最后一个成员， -2 表示倒数第二个成员，以此类推。超出范围的下标并不会引起错误。 比如说，当 start 的值比有序集的最大下标还要大，或是 start &gt; stop 时， ZRANGE 命令只是简单地返回一个空列表。 另一方面，假如 stop 参数的值比有序集的最大下标还要大，那么 Redis 将 stop 当作最大下标来处理。<br/>可以通过使用 WITHSCORES 选项，来让成员和它的 score 值一并返回，返回列表以 value1,score1, …, valueN,scoreN 的格式表示。 客户端库可能会返回一些更复杂的数据类型，比如数组、元组等。</td></tr><tr><td align="left">ZRANGEBYLEX key min max [LIMIT offset count]</td><td align="left">通过字典区间返回有序集合的成员</td><td>如果有序集合里面的成员带有不同的分值， 那么命令返回的结果是未指定的（unspecified）。<br/>命令会使用 C 语言的 memcmp() 函数， 对集合中的每个成员进行逐个字节的对比（byte-by-byte compare）， 并按照从低到高的顺序， 返回排序后的集合成员。 如果两个字符串有一部分内容是相同的话， 那么命令会认为较长的字符串比较短的字符串要大。<br/>可选的 LIMIT offset count 参数用于获取指定范围内的匹配元素 （就像 SQL 中的 SELECT LIMIT offset count 语句）。 需要注意的一点是， 如果 offset 参数的值非常大的话， 那么命令在返回结果之前， 需要先遍历至 offset 所指定的位置， 这个操作会为命令加上最多 O(N) 复杂度。<br/>合法的 min 和 max 参数必须包含 ( 或者 [ ， 其中 ( 表示开区间（指定的值不会被包含在范围之内）， 而 [ 则表示闭区间（指定的值会被包含在范围之内）。<br/>特殊值 + 和 - 在 min 参数以及 max 参数中具有特殊的意义， 其中 + 表示正无限， 而 - 表示负无限。 因此， 向一个所有成员的分值都相同的有序集合发送命令 <code>ZRANGEBYLEX &lt;zset&gt; - + </code>， 命令将返回有序集合中的所有元素。</td></tr><tr><td align="left">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</td><td align="left">通过分数返回有序集合指定区间内的成员</td><td>如果有序集合里面的成员带有不同的分值， 那么命令返回的结果是未指定的（unspecified）。<br/>命令会使用 C 语言的 memcmp() 函数， 对集合中的每个成员进行逐个字节的对比（byte-by-byte compare）， 并按照从低到高的顺序， 返回排序后的集合成员。 如果两个字符串有一部分内容是相同的话， 那么命令会认为较长的字符串比较短的字符串要大。<br/>可选的 LIMIT offset count 参数用于获取指定范围内的匹配元素 （就像 SQL 中的 SELECT LIMIT offset count 语句）。 需要注意的一点是， 如果 offset 参数的值非常大的话， 那么命令在返回结果之前， 需要先遍历至 offset 所指定的位置， 这个操作会为命令加上最多 O(N) 复杂度。<br/>合法的 min 和 max 参数必须包含 ( 或者 [ ， 其中 ( 表示开区间（指定的值不会被包含在范围之内）， 而 [ 则表示闭区间（指定的值会被包含在范围之内）。<br/>特殊值 + 和 - 在 min 参数以及 max 参数中具有特殊的意义， 其中 + 表示正无限， 而 - 表示负无限。 因此， 向一个所有成员的分值都相同的有序集合发送命令 ZRANGEBYLEX <zset> - + ， 命令将返回有序集合中的所有元素。</td></tr><tr><td align="left">ZRANK key member</td><td align="left">返回有序集合中指定成员的索引</td><td>使用 ZREVRANK key member 命令可以获得成员按 score 值递减(从大到小)排列的排名。<br/>如果 member 是有序集 key 的成员，返回 member 的排名。 如果 member 不是有序集 key 的成员，返回 nil 。</td></tr><tr><td align="left">ZREM key member [member …]</td><td align="left">移除有序集合中的一个或多个成员</td><td>不存在的成员将被忽略，当 key 存在但不是有序集类型时，返回一个错误。</td></tr><tr><td align="left">ZREMRANGEBYLEX key min max</td><td align="left">移除有序集合中给定的字典区间的所有成员</td><td>这个命令的 min 参数和 max 参数的意义和 ZRANGEBYLEX key min max [LIMIT offset count] 命令的 min 参数和 max 参数的意义一样。结果返回被移除的元素数量。</td></tr><tr><td align="left">ZREMRANGEBYRANK key start stop</td><td align="left">移除有序集合中给定的排名区间的所有成员</td><td>区间分别以下标参数 start 和 stop 指出，包含 start 和 stop 在内。结果返回被移除的元素数量。<br/>下标参数 start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推。 你也可以使用负数下标，以 -1 表示最后一个成员， -2 表示倒数第二个成员，以此类推。</td></tr><tr><td align="left">ZREMRANGEBYSCORE key min max</td><td align="left">移除有序集合中给定的分数区间的所有成员</td><td>移除有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。可以使用括号（）来指定不包括min和max。结果返回被移除的元素数量。</td></tr><tr><td align="left">ZREVRANGE key start stop [WITHSCORES]</td><td align="left">返回有序集中指定区间内的成员，通过索引，分数从高到低</td><td>其中成员的位置按 score 值递减(从大到小)来排列。 具有相同 score 值的成员按字典序的逆序(reverse lexicographical order)排列。<br/>除了成员按 score 值递减的次序排列这一点外， ZREVRANGE 命令的其他方面和 ZRANGE key start stop [WITHSCORES] 命令一样。</td></tr><tr><td align="left">ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]</td><td align="left">返回有序集中指定分数区间内的成员，分数从高到低排序</td><td>具有相同 score 值的成员按字典序的逆序(reverse lexicographical order )排列。<br/>除了成员按 score 值递减的次序排列这一点外， ZREVRANGEBYSCORE 命令的其他方面和 ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count] 命令一样。</td></tr><tr><td align="left">ZREVRANK key member</td><td align="left">返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</td><td>排名以 0 为底，也就是说， score 值最大的成员排名为 0 。<br/>使用 ZRANK key member 命令可以获得成员按 score 值递增(从小到大)排列的排名。</td></tr><tr><td align="left">ZSCAN key cursor [MATCH pattern] [COUNT count]</td><td align="left">返回有序集中，成员的分数值</td><td>以上列出的四个命令都支持增量式迭代， 它们每次执行都只会返回少量元素， 所以这些命令可以用于生产环境， 而不会出现像 KEYS 命令、 SMEMBERS 命令带来的问题 —— 当 KEYS 命令被用于处理一个大的数据库时， 又或者 SMEMBERS 命令被用于处理一个大的集合键时， 它们可能会阻塞服务器达数秒之久。不过， 增量式迭代命令也不是没有缺点的： 举个例子， 使用 SMEMBERS 命令可以返回集合键当前包含的所有元素， 但是对于 SCAN 这类增量式迭代命令来说， 因为在对键进行增量式迭代的过程中， 键可能会被修改， 所以增量式迭代命令只能对被返回的元素提供有限的保证 （offer limited guarantees about the returned elements）。</td></tr><tr><td align="left">ZUNIONSTORE destination numkeys key [key …]</td><td align="left">计算给定的一个或多个有序集的并集，并存储在新的 key 中</td><td>计算给定的一个或多个有序集的并集，其中给定 key 的数量必须以 numkeys 参数指定，并将该并集(结果集)储存到 destination 。<br/>默认情况下，结果集中某个成员的 score 值是所有给定集下该成员 score 值之 和 。<br/>使用 WEIGHTS 选项，你可以为 每个 给定有序集 分别 指定一个乘法因子(multiplication factor)，每个给定有序集的所有成员的 score 值在传递给聚合函数(aggregation function)之前都要先乘以该有序集的因子。如果没有指定 WEIGHTS 选项，乘法因子默认设置为 1 。<br/>使用 AGGREGATE 选项，你可以指定并集的结果集的聚合方式。<br/>默认使用的参数 SUM ，可以将所有集合中某个成员的 score 值之 和 作为结果集中该成员的 score 值；使用参数 MIN ，可以将所有集合中某个成员的 最小 score 值作为结果集中该成员的 score 值；而参数 MAX 则是将所有集合中某个成员的 最大 score 值作为结果集中该成员的 score 值。</td></tr><tr><td align="left">ZSCORE key member</td><td align="left">返回有序集 key 中，成员 member 的 score 值</td><td>如果 member 元素不是有序集 key 的成员，或 key 不存在，返回 nil 。</td></tr></tbody></table><h3 id="6-2、地理空间-geospatial"><a href="#6-2、地理空间-geospatial" class="headerlink" title="6.2、地理空间(geospatial)"></a>6.2、地理空间(geospatial)</h3><p>&emsp;&emsp;把某个具体的位置信息（经度，纬度，名称）添加到指定的key中，数据将会用一个sorted set存储，以便稍后能使用其他命令来根据半径来查询位置信息。注意：插入geospatial中的数据必须保证以下几点：</p><blockquote><ul><li>经度必须放在纬度前面；</li><li>有效的经度是-180度到180度；</li><li>有效的纬度是-85.05112878度到85.05112878度。</li></ul></blockquote><p>&emsp;&emsp;同时，由上面可知geospatial本质上是sorted set，所以如果需要删除一个地理位置的话，则直接使用sort set相关命令删除即可。geospatial的一个使用场景可以用来查询附近的人。</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>GEOADD key longitude latitude member [longitude latitude member …]</td><td>添加一个或多个地理位置元素到一个key中<br/>longitude ：经度，latitude：纬度</td></tr><tr><td>GEODIST key member1 member2 [unit]</td><td>返回一个key中指定两个位置之间的直线距离<br />unit可以指定长度单位：m,km,ft等 默认为m</td></tr><tr><td>GEOHASH key member [member …]</td><td>返回一个或多个位置元素的 Geohash 表示，Geohash是一种经纬度散列算法，具体请百度。</td></tr><tr><td>GEOPOS key member [member …]</td><td>返回一个或多个位置的经纬度信息，由于采用了geohash算法，返回的经纬度和添加时的数据可能会有细小误差</td></tr><tr><td>GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count]</td><td>以给定位置为中心，半径不超过给定半径的附近所有位置</td></tr><tr><td>GEORADIUSBYMEMBER key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count]</td><td>同上，只是中心点不是指定经纬度，而是指定已添加的某个位置作为中心</td></tr></tbody></table><h2 id="7、Hyperloglog"><a href="#7、Hyperloglog" class="headerlink" title="7、Hyperloglog"></a>7、Hyperloglog</h2><p>&emsp;&emsp;Redis HyperLogLog是用来做基数统计的算法，HyperLogLog的优点是：在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且使很小的。每个HyperLogLog键只需要花费12kb内存，就可以计算接近2^64个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。但是，因为HyperLogLog只会根据输入元素来计算基数，而不会存储输入元素本身，所以HyperLogLog不能像集合那样，返回输入的各个元素。</p><p>&emsp;&emsp;基数简介：比如数据集{1,3,5,7,5,7,8}，那么这个数据集的基数集为{1,3,5,7,8},基数(不重复元素)为5。基数估计就是在误差可接受的范围内，快速计算基数。这里有一个重点，基数是可以存在误差的，所以在使用时需要考虑这一点。</p><p>&emsp;&emsp;Hyperloglog的使用场景一般可以用来统计系统的访问量。传统上我们可以把用户id保存在一个set集合上，但是当数量越大，这个集合需要占用的内存就越大，而Hyperloglog只需要12kb就可以解决。</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>PFADD key element [element……]</td><td>将任意数量的元素添加到指定的HyperLogLog里面。</td></tr><tr><td>PFCOUNT key [key……]</td><td>当其作用于当个键时，返回储存在给定键的HyperLogLog的近似基数，如果键不存在，那么返回0。当其作用于多个键时，返回所有给定HyperLogLog的并集的近似基数，这个近似基数是通过将所有给定HyperLogLog合并至一个临时HyperLogLog来计算得出的。</td></tr><tr><td>PFMERGE destkey sourcekey [sourcekey……]</td><td>将多个HyperLogLog合并（merge）为一个HyperLogLog，合并后的HyperLogLog的基数接近于所有输入HyperLogLog的可见集合(observed set)的并集。</td></tr></tbody></table><h2 id="8、Transactions"><a href="#8、Transactions" class="headerlink" title="8、Transactions"></a>8、Transactions</h2><p>&emsp;&emsp;Redis事务提供了一种“将多个命令打包， 然后一次性、按顺序地执行”的机制， 并且事务在执行的期间不会主动中断 —— 服务器在执行完事务中的所有命令之后， 才会继续处理其他客户端的其他命令。</p><p>&emsp;&emsp;Redis中的事务是可以视为一个队列，即我们可以通过MULTI开始一个事务，这相当于我们声明了一个命令队列。接下来，我们向Redis中提交的每条命令，都会被排入这个命令队列。当我们输入EXEC命令时，将触发当前事务，这相当于我们从命令队列中取出命令并执行，所以Redis中一个事务从开始到执行会经历 <strong>开始事务</strong> 、 <strong>命令入队</strong> 和 <strong>执行事务</strong> 三个阶段。</p><table><thead><tr><th>命令</th><th>描述</th><th>参数解析</th></tr></thead><tbody><tr><td>MULTI</td><td>标记一个事务块的开始</td><td>事务块内的多条命令会按照先后顺序被放进一个队列当中，最后由 EXEC 命令原子性(atomic)地执行。</td></tr><tr><td>EXEC</td><td>执行事务块内的所有命令</td><td>假如某个(或某些) key 正处于 WATCH 命令的监视之下，且事务块中有和这个(或这些) key 相关的命令，那么 EXEC 命令只在这个(或这些) key 没有被其他命令所改动的情况下执行并生效，否则该事务被打断(abort)。</td></tr><tr><td>DISCARD</td><td>取消事务，放弃执行事务块内的所有命令。</td><td>如果正在使用 WATCH 命令监视某个(或某些) key，那么取消所有监视，等同于执行命令 UNWATCH 。</td></tr><tr><td>WATCH key [key …]</td><td>监视一个(或多个) key</td><td>如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。watch是Redis事物乐观锁的实现。</td></tr><tr><td>UNWATCH</td><td>取消 WATCH 命令对所有 key 的监视</td><td>如果在执行 WATCH 命令之后， EXEC 命令或 DISCARD 命令先被执行了的话，那么就不需要再执行 UNWATCH 了。<br />因为 EXEC 命令会执行事务，因此 WATCH 命令的效果已经产生了；而 DISCARD 命令在取消事务的同时也会取消所有对 key 的监视，因此这两个命令执行之后，就没有必要执行 UNWATCH 了。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安装 </tag>
            
            <tag> Redis </tag>
            
            <tag> 命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyCat</title>
      <link href="/blog/2021/06/01/MyCat/"/>
      <url>/blog/2021/06/01/MyCat/</url>
      
        <content type="html"><![CDATA[<h1 id="MyCat"><a href="#MyCat" class="headerlink" title="MyCat"></a>MyCat</h1><h1 id="一、MyCat简介"><a href="#一、MyCat简介" class="headerlink" title="一、MyCat简介"></a>一、MyCat简介</h1><h2 id="1、什么是MyCat？"><a href="#1、什么是MyCat？" class="headerlink" title="1、什么是MyCat？"></a>1、什么是MyCat？</h2><p>&emsp;&emsp;MyCat是数据库中间件，是连接Java应用程序和数据库的软件。</p><h2 id="2、为什么要使用Mycat"><a href="#2、为什么要使用Mycat" class="headerlink" title="2、为什么要使用Mycat?"></a>2、为什么要使用Mycat?</h2><blockquote><ol><li>Java与数据库的紧耦合；</li><li>高访问量高并发可对数据库的压力；</li><li>读写请求数据不一致。</li></ol></blockquote><h2 id="3、MyCat能干什么？"><a href="#3、MyCat能干什么？" class="headerlink" title="3、MyCat能干什么？"></a>3、MyCat能干什么？</h2><h3 id="3-1、读写分离"><a href="#3-1、读写分离" class="headerlink" title="3.1、读写分离"></a>3.1、读写分离</h3><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210531220516982.png" alt="image-20210531220516982"></p><h3 id="3-2、数据分片"><a href="#3-2、数据分片" class="headerlink" title="3.2、数据分片"></a>3.2、数据分片</h3><p>&emsp;&emsp;可以垂直拆分（分库） 、 水平拆分（分表） 、 垂直+水平拆分（分库分表） 。 </p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210531220526030.png" alt="image-20210531220526030"></p><h3 id="3-3、多数据源整合"><a href="#3-3、多数据源整合" class="headerlink" title="3.3、多数据源整合"></a>3.3、多数据源整合</h3><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210531220556388.png" alt="image-20210531220556388"></p><h2 id="4、MyCat的原理"><a href="#4、MyCat的原理" class="headerlink" title="4、MyCat的原理"></a>4、MyCat的原理</h2><p>&emsp;&emsp;Mycat 的原理中最重要的一个动词是“拦截”，它拦截了用户发送过来的 SQL 语句，首先对 SQL语句做了一些特定的分析：如分片分析、路由分析、读写分离分析、缓存分析等，然后将此 SQL 发往后端的真实数据库， 并将返回的结果做适当的处理，最终再返回给用户。  </p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210531220803749.png" alt="image-20210531220803749"></p><h1 id="二、MyCat的安装"><a href="#二、MyCat的安装" class="headerlink" title="二、MyCat的安装"></a>二、MyCat的安装</h1><h2 id="1、下载相关安装包"><a href="#1、下载相关安装包" class="headerlink" title="1、下载相关安装包"></a>1、下载相关安装包</h2><p>MyCat官方网站：【<a href="http://www.mycat.org.cn/">链接</a>】</p><p>也可以使用下面地址，这里下载的是1.6.7.5版本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://dl.mycat.org.cn/1.6.7.5/2020-4-10/</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210531221538842.png" alt="image-20210531221538842"></p><p>同时，下载其他相关后续会使用的软件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">MyCat-Web</span></span><br><span class="line">https://raw.githubusercontent.com/MyCATApache/Mycat-download/master/mycat-web-1.0/Mycat-web-1.0-SNAPSHOT-20160617163048-linux.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">HAProxy</span></span><br><span class="line">https://src.fedoraproject.org/repo/pkgs/haproxy/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">Keepalived</span></span><br><span class="line">https://www.keepalived.org/download.html</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">软件</th><th align="center">使用版本</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">MyCat-Server</td><td align="center">1.6.7.5</td><td align="center"></td></tr><tr><td align="center">MyCat-Web</td><td align="center">1.0</td><td align="center"></td></tr><tr><td align="center">HA - Proxy</td><td align="center">1.8.25</td><td align="center"></td></tr><tr><td align="center">keepalived</td><td align="center">1.4.5</td><td align="center"></td></tr></tbody></table><h2 id="2、搭建读写分离"><a href="#2、搭建读写分离" class="headerlink" title="2、搭建读写分离"></a>2、搭建读写分离</h2><p>&emsp;&emsp;我们通过 Mycat 和 MySQL 的主从复制配合搭建数据库的读写分离， 实现 MySQL 的高可用性。 </p><h3 id="2-1、搭建一主一从"><a href="#2-1、搭建一主一从" class="headerlink" title="2.1、搭建一主一从"></a>2.1、搭建一主一从</h3><p>&emsp;&emsp;按照（  <a href="http://cheng_qiwei.gitee.io/blog/2021/05/21/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/#%E4%B8%89%E3%80%81%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%93%8D%E4%BD%9C">链接</a>  ）地址搭建一主一从数据库。本次搭建的机器如下：</p><table><thead><tr><th align="center">机器类型</th><th align="center">IP</th><th align="center">PORT</th></tr></thead><tbody><tr><td align="center">主机</td><td align="center">192.168.66.131</td><td align="center">3306</td></tr><tr><td align="center">从机</td><td align="center">192.168.66.132</td><td align="center">3306</td></tr></tbody></table><h3 id="2-2、解压MyCat"><a href="#2-2、解压MyCat" class="headerlink" title="2.2、解压MyCat"></a>2.2、解压MyCat</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxf Mycat-server-1.6.7.5-release-20200410174409-linux.tar.gz -C /usr/local</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210601221930172.png" alt="image-20210601221930172"></p><h3 id="2-3、配置MyCat"><a href="#2-3、配置MyCat" class="headerlink" title="2.3、配置MyCat"></a>2.3、配置MyCat</h3><h4 id="2-3-1、配置server-xml"><a href="#2-3-1、配置server-xml" class="headerlink" title="2.3.1、配置server.xml"></a>2.3.1、配置server.xml</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/local/http://cheng_qiwei.gitee.io/blog/img/conf/server.xml</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在最下面添加一个mycat的用户作为我们连接使用的用户</span></span><br><span class="line">&lt;user name=&quot;mycat&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;password&quot;&gt;123456&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;schemas&quot;&gt;TESTDB&lt;/property&gt;</span><br><span class="line">&lt;/user&gt;</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210601223826660.png" alt="image-20210601223826660"></p><h4 id="2-3-2、配置schema-xml"><a href="#2-3-2、配置schema-xml" class="headerlink" title="2.3.2、配置schema.xml"></a>2.3.2、配置schema.xml</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 由于schema.xml需要修改的内容比较多，为了防止意外可以恢复，所以先备份一份</span></span><br><span class="line">cp /usr/local/http://cheng_qiwei.gitee.io/blog/img/conf/schema.xml /usr/local/http://cheng_qiwei.gitee.io/blog/img/conf/schema.xml.bak</span><br><span class="line"></span><br><span class="line">vim /usr/local/http://cheng_qiwei.gitee.io/blog/img/conf/schema.xml</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改内容如下：</span></span><br><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mycat:schema SYSTEM &quot;schema.dtd&quot;&gt;</span><br><span class="line">&lt;mycat:schema xmlns:mycat=&quot;http://io.http://cheng_qiwei.gitee.io/blog/img/&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;schema name=&quot;TESTDB&quot; checkSQLschema=&quot;false&quot; sqlMaxLimit=&quot;100&quot; randomDataNode=&quot;dn1&quot;&gt;</span><br><span class="line">        &lt;/schema&gt;</span><br><span class="line">        &lt;dataNode name=&quot;dn1&quot; dataHost=&quot;host1&quot; database=&quot;mytest&quot; /&gt;</span><br><span class="line">        &lt;dataHost name=&quot;host1&quot; maxCon=&quot;1000&quot; minCon=&quot;10&quot; balance=&quot;0&quot;</span><br><span class="line">                          writeType=&quot;0&quot; dbType=&quot;mysql&quot; dbDriver=&quot;jdbc&quot; switchType=&quot;1&quot;  slaveThreshold=&quot;100&quot;&gt;</span><br><span class="line">                &lt;heartbeat&gt;select user()&lt;/heartbeat&gt;</span><br><span class="line">                &lt;!-- can have multi write hosts --&gt;</span><br><span class="line">                &lt;writeHost host=&quot;hostM1&quot; url=&quot;jdbc:mysql://192.168.66.131:3306&quot; user=&quot;root&quot; password=&quot;123456&quot;&gt;</span><br><span class="line">                        &lt;readHost host=&quot;hostS1&quot; url=&quot;jdbc:mysql://192.168.66.132:3306&quot; user=&quot;root&quot; password=&quot;123456&quot;/&gt;</span><br><span class="line">                &lt;/writeHost&gt;</span><br><span class="line">        &lt;/dataHost&gt;</span><br><span class="line">&lt;/mycat:schema&gt;</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210602224243761.png" alt="image-20210602224243761"></p><h3 id="2-4、启动MyCat"><a href="#2-4、启动MyCat" class="headerlink" title="2.4、启动MyCat"></a>2.4、启动MyCat</h3><p>&emsp;&emsp;为了使MyCat可以在任意位置被访问，所以需要配置环境变量，结果如图则为成功！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">增加环境变量</span></span><br><span class="line">vi /etc/profile</span><br><span class="line">export MYCAT_HOME=/usr/local/mycat</span><br><span class="line">export PATH=$PATH:$MYCAT_HOME/bin</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">让添加的配置生效</span></span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210601231439647.png" alt="image-20210601231439647"></p><p>&emsp;&emsp;这里我们为了观察日志，所以使用console启动，平时情况使用 start 后台启动即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mycat console</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210601232735935.png" alt="image-20210601232735935"></p><h3 id="2-5、登录测试"><a href="#2-5、登录测试" class="headerlink" title="2.5、登录测试"></a>2.5、登录测试</h3><p>&emsp;&emsp;新开一个窗口，登录MyCat</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -umycat -p123456 -P8066 -h192.168.66.131</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210601233712573.png" alt="image-20210601233712573"></p><p>至此，MyCat安装成功！</p><h3 id="2-6、测试读写分离"><a href="#2-6、测试读写分离" class="headerlink" title="2.6、测试读写分离"></a>2.6、测试读写分离</h3><p>&emsp;&emsp;测试读写分离，就需要我们在主库和从库放置不同的数据，此时我们就会想到：在写主机数据库表t1中插入带系统变量数据， 造成主从数据不一。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210601235911309.png" alt="image-20210601235911309"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210601235933673.png" alt="image-20210601235933673"></p><p>此时我们发现，使用MyCat查询还是查到了主库。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210602000050276.png" alt="image-20210602000050276"></p><p>&emsp;&emsp;那么，这是不是MyCat不具备读写分离？答案肯定是不是的。只是我们还没有配置而已。我们需要修改的是schema.xml中dataHost的其中一个配置<code>balance</code>。这个配置项默认为0，其他配置如下：</p><blockquote><p>balance负载均衡类型，目前的取值有4 种： </p><ol><li>balance=”0”, 不开启读写分离机制， 所有读操作都发送到当前可用的 writeHost 上；</li><li>balance=”1”，全部的 readHost 与 stand by writeHost 参与 select 语句的负载均衡，简单的说，当双主双从 模式(M1-&gt;S1， M2-&gt;S2，并且 M1 与 M2 互为主备)，正常情况下， M2,S1,S2 都参与 select 语句的负载均衡；</li><li>balance=”2”，所有读操作都随机的在 writeHost、 readhost 上分发；</li><li>balance=”3”，所有读请求随机的分发到 readhost 执行， writerHost 不负担读压力。</li></ol></blockquote><p>&emsp;&emsp;所以我们需要配置该类型，我们将其配置为2，然后<font color='red'>重新启动MyCat</font>，让其在两台机器上面切换：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210602224325294.png" alt="image-20210602224325294"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210602224548692.png" alt="image-20210602224548692"></p><p>&emsp;&emsp;如上图，查询在主库和从库切换，那么此时如果我们使用balance=“3”，则只会在从库中进行读取。</p><h2 id="3、双主双从的读写分离"><a href="#3、双主双从的读写分离" class="headerlink" title="3、双主双从的读写分离"></a>3、双主双从的读写分离</h2><p>&emsp;&emsp;我们从balance的值中发现其兼容双主双从的读写分离，所以我们可以尝试进行搭建测试。</p><h3 id="3-1、搭建双主双从"><a href="#3-1、搭建双主双从" class="headerlink" title="3.1、搭建双主双从"></a>3.1、搭建双主双从</h3><p>&emsp;&emsp;按照（  <a href="http://cheng_qiwei.gitee.io/blog/2021/05/21/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/#%E5%9B%9B%E3%80%81%E5%8F%8C%E4%B8%BB%E5%8F%8C%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E6%93%8D%E4%BD%9C">链接</a>  ）地址搭建双主双从数据库，注意先<font color='red'>关闭MyCat服务</font>。本次搭建的机器如下：</p><table><thead><tr><th align="center">机器类型</th><th align="center">IP</th><th align="center">PORT</th></tr></thead><tbody><tr><td align="center">主机</td><td align="center">192.168.66.131</td><td align="center">3306</td></tr><tr><td align="center">主机从机</td><td align="center">192.168.66.132</td><td align="center">3306</td></tr><tr><td align="center">备机</td><td align="center">192.168.66.133</td><td align="center">3306</td></tr><tr><td align="center">备机从机</td><td align="center">192.168.66.134</td><td align="center">3306</td></tr></tbody></table><h3 id="3-2、修改配置文件"><a href="#3-2、修改配置文件" class="headerlink" title="3.2、修改配置文件"></a>3.2、修改配置文件</h3><p>&emsp;&emsp;我们主要修改<code>schema.xml</code>文件。首先设置balance为1，其次是增加备机和备机从机的配置。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210603225304205.png" alt="image-20210603225304205"></p><blockquote><p>这里我们还需要了解另外几个参数：</p><p>writeType=”0”: 所有写操作发送到配置的第一个writeHost，第一个挂了切到还生存的第二个 ；</p><p>writeType=”1”，所有写操作都随机的发送到配置的 writeHost， 1.5 以后废弃不推荐 。</p><p>writeHost，重新启动后以切换后的为准，切换记录在配置文件中:dnindex.properties 。 </p><p>switchType=”1”: 1 默认值，自动切换； </p><p>​                             -1 表示不自动切换 ；</p><p>​                                2 基于 MySQL 主从同步的状态决定是否切换。</p></blockquote><h3 id="3-3、重启MyCat服务"><a href="#3-3、重启MyCat服务" class="headerlink" title="3.3、重启MyCat服务"></a>3.3、重启MyCat服务</h3><h3 id="3-4、测试MyCat"><a href="#3-4、测试MyCat" class="headerlink" title="3.4、测试MyCat"></a>3.4、测试MyCat</h3><h4 id="3-4-1、测试读写分离"><a href="#3-4-1、测试读写分离" class="headerlink" title="3.4.1、测试读写分离"></a>3.4.1、测试读写分离</h4><p>&emsp;&emsp;根据之前的balance的设置，M2，S1，S2参与查询负载均衡，测试有效。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210603230453187.png" alt="image-20210603230453187"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210603230605634.png" alt="image-20210603230605634"></p><h4 id="3-4-2、测试抗风险能力"><a href="#3-4-2、测试抗风险能力" class="headerlink" title="3.4.2、测试抗风险能力"></a>3.4.2、测试抗风险能力</h4><p>&emsp;&emsp;我们将主机关闭，看看MyCat能否正常访问和使用。我们发现，当M1关闭后，主机切换为备机M2来使用，可以正常查询和写入数据，但查询只会查询S2。这是因为当M1关闭之后，S1的联系也就断开了，所以查询就只能查询S2。当M1恢复启动之后，M1会作为M2的备机存在，此时查询的话，就会在M1、S1、S2之间进行切换。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210603231402197.png" alt="image-20210603231402197"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210603231501271.png" alt="image-20210603231501271"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210603231530235.png" alt="image-20210603231530235"></p><h1 id="三、垂直拆分——分库"><a href="#三、垂直拆分——分库" class="headerlink" title="三、垂直拆分——分库"></a>三、垂直拆分——分库</h1><p>&emsp;&emsp;一个数据库由很多表的构成，每个表对应着不同的业务，垂直切分是指按照业务将表进行分类，分布到不同 的数据库上面，这样也就将数据或者说压力分担到不同的库上面，如下图：  </p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210604145046241.png" alt="image-20210604145046241"></p><h2 id="1、如何划分库"><a href="#1、如何划分库" class="headerlink" title="1、如何划分库"></a>1、如何划分库</h2><p>&emsp;&emsp;在操作分库之前，有一个问题：在两台主机上的两个数据库中的表，能否关联查询？答案是不可以关联查询。这是因为MyCat在查询时是多个库单独查询结果的合集，所以分在不同的主机上的表是不能进行关联查询的。所以分库的原则是： 有紧密关联关系的表应该在一个库里，相互没有关联关系的表可以分到不同的库里。  </p><h2 id="2、分库操作流程"><a href="#2、分库操作流程" class="headerlink" title="2、分库操作流程"></a>2、分库操作流程</h2><p>&emsp;&emsp;当前有如下的表，查看后我们可以判断：客户表分在一个数据库，另外三张都需要关联查询，分在另外一个数据库。  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#客户表 rows:20万</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customer(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span> AUTO_INCREMENT,</span><br><span class="line"><span class="keyword">NAME</span> <span class="built_in">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">#订单表 rows:600万</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> orders(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span> AUTO_INCREMENT,</span><br><span class="line">order_type <span class="built_in">INT</span>,</span><br><span class="line">customer_id <span class="built_in">INT</span>,</span><br><span class="line">amount <span class="built_in">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>),</span><br><span class="line">PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">#订单详细表 rows:600万</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> orders_detail(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span> AUTO_INCREMENT,</span><br><span class="line">detail <span class="built_in">VARCHAR</span>(<span class="number">2000</span>),</span><br><span class="line">order_id <span class="built_in">INT</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">#订单状态字典表 rows:20</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dict_order_type(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span> AUTO_INCREMENT,</span><br><span class="line">order_type <span class="built_in">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="2-1、修改配置文件"><a href="#2-1、修改配置文件" class="headerlink" title="2.1、修改配置文件"></a>2.1、修改配置文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mycat:schema</span> <span class="attr">xmlns:mycat</span>=<span class="string">&quot;http://io.http://cheng_qiwei.gitee.io/blog/img/&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;TESTDB&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;false&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;customer&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn2&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn1&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;host1&quot;</span> <span class="attr">database</span>=<span class="string">&quot;orders&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn2&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;host2&quot;</span> <span class="attr">database</span>=<span class="string">&quot;orders&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;host1&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">                          <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span>  <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;hostM1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.66.131:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123456&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;host2&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">                          <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span>  <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;hostM2&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.66.133:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123456&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:schema</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210604162951426.png" alt="image-20210604162951426"></p><h3 id="2-2、新增数据库并启动MyCat"><a href="#2-2、新增数据库并启动MyCat" class="headerlink" title="2.2、新增数据库并启动MyCat"></a>2.2、新增数据库并启动MyCat</h3><p>&emsp;&emsp;由于更换了数据库，所以需要在两台主机创建数据库<code>orders</code>。新增完成后，可以启动MyCat测试。</p><h3 id="2-3、测试分库功能"><a href="#2-3、测试分库功能" class="headerlink" title="2.3、测试分库功能"></a>2.3、测试分库功能</h3><p>&emsp;&emsp;登录MyCat，分别插入四张表，观察MyCat和两台主机数据库。发现分库效果成功！</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 登录MySQL</span></span><br><span class="line">mysql -umycat -p123456 -P8066 -h192.168.66.131</span><br><span class="line"></span><br><span class="line"><span class="comment">#分别插入四张表</span></span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210604164223954.png" alt="image-20210604164223954"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210604164454460.png" alt="image-20210604164454460"></p><h1 id="四、水平拆分——分表（分片）"><a href="#四、水平拆分——分表（分片）" class="headerlink" title="四、水平拆分——分表（分片）"></a>四、水平拆分——分表（分片）</h1><p>&emsp;&emsp;相对于垂直拆分，水平拆分不是将表做分类，而是按照某个字段的某种规则来分散到多个库之中，每个表中 包含一部分数据。简单来说，我们可以将数据的水平切分理解为是按照数据行的切分，就是将表中的某些行切分 到一个数据库，而另外的某些行又切分到其他的数据库中，如图：  </p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210604225451498.png" alt="image-20210604225451498"></p><h2 id="1、如何划分表"><a href="#1、如何划分表" class="headerlink" title="1、如何划分表"></a>1、如何划分表</h2><h3 id="1-1、-选择要拆分的表"><a href="#1-1、-选择要拆分的表" class="headerlink" title="1.1、 选择要拆分的表"></a>1.1、 选择要拆分的表</h3><p>&emsp;&emsp;MySQL 单表存储数据条数是有瓶颈的，单表达到 1000 万条数据就达到了瓶颈，会影响查询效率，需要进行水平拆分（分表） 进行优化。<br>&emsp;&emsp;例如：例子中的 orders、 orders_detail 都已经达到 600 万行数据，需要进行分表优化。</p><h3 id="1-2、-分表字段"><a href="#1-2、-分表字段" class="headerlink" title="1.2、 分表字段"></a>1.2、 分表字段</h3><p>以 orders 表为例，可以根据不同自字段进行分表：</p><table><thead><tr><th align="center">编号</th><th align="center">分表字段</th><th align="center">效果</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">id（主键、 或创建时间）</td><td align="center">查询订单注重时效，历史订单被查询的次数少，如此分片会造成一个节点访问多，一个访问少，不平均。</td></tr><tr><td align="center">2</td><td align="center">customer_id（客户 id）</td><td align="center">根据客户 id 去分，两个节点访问平均，一个客户的所 有订单都在同一个节点</td></tr></tbody></table><h2 id="2、分表的方式与操作"><a href="#2、分表的方式与操作" class="headerlink" title="2、分表的方式与操作"></a>2、分表的方式与操作</h2><h3 id="2-1、取模法"><a href="#2-1、取模法" class="headerlink" title="2.1、取模法"></a>2.1、取模法</h3><p>&emsp;&emsp;按照上面的说法，我们可以用customer_id取模来将数据平均分布到两个节点上。</p><h4 id="2-1-1、修改schema-xml文件-并为节点2添加orders表"><a href="#2-1-1、修改schema-xml文件-并为节点2添加orders表" class="headerlink" title="2.1.1、修改schema.xml文件,并为节点2添加orders表"></a>2.1.1、修改schema.xml文件,并为节点2添加orders表</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#为 orders 表设置数据节点为 dn1、 dn2， 并指定分片规则为 mod_rule（自定义的名字）</span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;mod_rule&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210604231715587.png" alt="image-20210604231715587"></p><h4 id="2-1-2、修改rule-xml文件"><a href="#2-1-2、修改rule-xml文件" class="headerlink" title="2.1.2、修改rule.xml文件"></a>2.1.2、修改rule.xml文件</h4><p>&emsp;&emsp;tableRule的部分修改原来的rule1即可！</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;mod_rule&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">columns</span>&gt;</span>customer_id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>mod-long<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;mod-long&quot;</span> <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionByMod&quot;</span>&gt;</span></span><br><span class="line">              <span class="comment">&lt;!-- how many data nodes --&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;count&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210604232944643.png" alt="image-20210604232944643"></p><h4 id="2-1-3、重启MyCat，测试分表效果"><a href="#2-1-3、重启MyCat，测试分表效果" class="headerlink" title="2.1.3、重启MyCat，测试分表效果"></a>2.1.3、重启MyCat，测试分表效果</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在 mycat 里向 orders 表插入数据， INSERT表后面的字段不能省略</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders(<span class="keyword">id</span>,order_type,customer_id,amount) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">101</span>,<span class="number">100</span>,<span class="number">100100</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders(<span class="keyword">id</span>,order_type,customer_id,amount) <span class="keyword">VALUES</span>(<span class="number">2</span>,<span class="number">101</span>,<span class="number">100</span>,<span class="number">100300</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders(<span class="keyword">id</span>,order_type,customer_id,amount) <span class="keyword">VALUES</span>(<span class="number">3</span>,<span class="number">101</span>,<span class="number">101</span>,<span class="number">120000</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders(<span class="keyword">id</span>,order_type,customer_id,amount) <span class="keyword">VALUES</span>(<span class="number">4</span>,<span class="number">101</span>,<span class="number">101</span>,<span class="number">103000</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders(<span class="keyword">id</span>,order_type,customer_id,amount) <span class="keyword">VALUES</span>(<span class="number">5</span>,<span class="number">102</span>,<span class="number">101</span>,<span class="number">100400</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders(<span class="keyword">id</span>,order_type,customer_id,amount) <span class="keyword">VALUES</span>(<span class="number">6</span>,<span class="number">102</span>,<span class="number">100</span>,<span class="number">100020</span>);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;插入数据后，分别使用MyCat、M1、M2查询orders表数据，分表成功！</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210605001420684.png" alt="image-20210605001420684"></p><h3 id="2-2、分表-“join”"><a href="#2-2、分表-“join”" class="headerlink" title="2.2、分表 “join”"></a>2.2、分表 “join”</h3><p>&emsp;&emsp;orders 订单表已经进行了分表，和它关联的 orders_detail 订单详情表和 dict_order_type 订单字典表如何进行 join 查询。我们需要对 orders_detail 和 dict_order_type 进行分片操作。 Join 的原理如下图：  </p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210606153940916.png" alt="image-20210606153940916"></p><p>&emsp;&emsp;而对于不同类型的表，我们也有不同的处理：</p><h4 id="2-2-1、ER表"><a href="#2-2-1、ER表" class="headerlink" title="2.2.1、ER表"></a>2.2.1、ER表</h4><p>&emsp;&emsp;Mycat 借鉴了 NewSQL 领域的新秀 Foundation DB 的设计思路， Foundation DB 创新性的提出了 Table Group 的概念，其将子表的存储位置依赖于主表，并且物理上紧邻存放，因此彻底解决了JOIN 的效率和性能问 题，根据这一思路，提出了基于 E-R 关系的数据分片策略，即<strong>子表的记录与所关联的父表记录存放在同一个数据分片上</strong>。  而 orders_detail 表是适合这种分标方式。</p><h5 id="2-2-1-1、修改schema-xml"><a href="#2-2-1-1、修改schema-xml" class="headerlink" title="2.2.1.1、修改schema.xml"></a>2.2.1.1、修改schema.xml</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">childTable</span> <span class="attr">name</span>=<span class="string">&quot;orders_detail&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span> <span class="attr">joinKey</span>=<span class="string">&quot;order_id&quot;</span> <span class="attr">parentKey</span>=<span class="string">&quot;id&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210606154916499.png" alt="image-20210606154916499"></p><h5 id="2-2-1-2、在备机M2新增-orders-detail-表"><a href="#2-2-1-2、在备机M2新增-orders-detail-表" class="headerlink" title="2.2.1.2、在备机M2新增 orders_detail 表"></a>2.2.1.2、在备机M2新增 orders_detail 表</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> orders_detail(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span> AUTO_INCREMENT,</span><br><span class="line">detail <span class="built_in">VARCHAR</span>(<span class="number">2000</span>),</span><br><span class="line">order_id <span class="built_in">INT</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="2-2-1-3、重启MyCat，在MyCat中插入orders-detail的数据"><a href="#2-2-1-3、重启MyCat，在MyCat中插入orders-detail的数据" class="headerlink" title="2.2.1.3、重启MyCat，在MyCat中插入orders_detail的数据"></a>2.2.1.3、重启MyCat，在MyCat中插入orders_detail的数据</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders_detail(<span class="keyword">id</span>,detail,order_id) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;detail1&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders_detail(<span class="keyword">id</span>,detail,order_id) <span class="keyword">VALUES</span>(<span class="number">2</span>,<span class="string">&#x27;detail1&#x27;</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders_detail(<span class="keyword">id</span>,detail,order_id) <span class="keyword">VALUES</span>(<span class="number">3</span>,<span class="string">&#x27;detail1&#x27;</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders_detail(<span class="keyword">id</span>,detail,order_id) <span class="keyword">VALUES</span>(<span class="number">4</span>,<span class="string">&#x27;detail1&#x27;</span>,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders_detail(<span class="keyword">id</span>,detail,order_id) <span class="keyword">VALUES</span>(<span class="number">5</span>,<span class="string">&#x27;detail1&#x27;</span>,<span class="number">5</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders_detail(<span class="keyword">id</span>,detail,order_id) <span class="keyword">VALUES</span>(<span class="number">6</span>,<span class="string">&#x27;detail1&#x27;</span>,<span class="number">6</span>);</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210606155627013.png" alt="image-20210606155627013"></p><h5 id="2-2-1-4、查看测试结果"><a href="#2-2-1-4、查看测试结果" class="headerlink" title="2.2.1.4、查看测试结果"></a>2.2.1.4、查看测试结果</h5><p>&emsp;&emsp;分别查询M1、M2、MyCat，发现orders_detail 表能够按照 orders 表的分表规则进行分表。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210606161957028.png" alt="image-20210606161957028"></p><h4 id="2-2-2、全局表"><a href="#2-2-2、全局表" class="headerlink" title="2.2.2、全局表"></a>2.2.2、全局表</h4><p>&emsp;&emsp;在分片的情况下，当业务表因为规模而进行分片以后，业务表与这些附属的字典表之间的关联，就成了比较 棘手的问题，考虑到字典表具有以下几个特性：</p><blockquote><p>① 变动不频繁；<br>② 数据量总体变化不大；<br>③ 数据规模不大，很少有超过数十万条记录。</p></blockquote><p>&emsp;&emsp;鉴于此， Mycat 定义了一种特殊的表，称之为“全局表”，全局表具有以下特性：</p><blockquote><p>① 全局表的插入、更新操作会实时在所有节点上执行，保持各个分片的数据一致性；<br>② 全局表的查询操作，只从一个节点获取；<br>③ 全局表可以跟任何一个表进行 JOIN 操作。</p></blockquote><p>&emsp;&emsp;将字典表或者符合字典表特性的一些表定义为全局表，则从另外一个方面，很好的解决了数据JOIN 的难题。 通过全局表+基于 E-R 关系的分片策略， Mycat 可以满足 80%以上的企业应用开发 。</p><h5 id="2-2-2-1、修改schema-xml"><a href="#2-2-2-1、修改schema-xml" class="headerlink" title="2.2.2.1、修改schema.xml"></a>2.2.2.1、修改schema.xml</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;dict_order_type&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2&quot;</span> <span class="attr">type</span>=<span class="string">&quot;global&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210606163000008.png" alt="image-20210606163000008"></p><h5 id="2-2-2-2、在备机M2新增-dict-order-type-表"><a href="#2-2-2-2、在备机M2新增-dict-order-type-表" class="headerlink" title="2.2.2.2、在备机M2新增 dict_order_type 表"></a>2.2.2.2、在备机M2新增 dict_order_type 表</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#订单状态字典表 rows:20</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dict_order_type(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span> AUTO_INCREMENT,</span><br><span class="line">order_type <span class="built_in">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="2-2-2-3、重启MyCat，在MyCat中插入dict-order-type的数据"><a href="#2-2-2-3、重启MyCat，在MyCat中插入dict-order-type的数据" class="headerlink" title="2.2.2.3、重启MyCat，在MyCat中插入dict_order_type的数据"></a>2.2.2.3、重启MyCat，在MyCat中插入dict_order_type的数据</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dict_order_type(<span class="keyword">id</span>,order_type) <span class="keyword">VALUES</span>(<span class="number">101</span>,<span class="string">&#x27;type1&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dict_order_type(<span class="keyword">id</span>,order_type) <span class="keyword">VALUES</span>(<span class="number">102</span>,<span class="string">&#x27;type2&#x27;</span>);</span><br></pre></td></tr></table></figure><h5 id="2-2-2-4、查看测试结果"><a href="#2-2-2-4、查看测试结果" class="headerlink" title="2.2.2.4、查看测试结果"></a>2.2.2.4、查看测试结果</h5><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210606163521225.png" alt="image-20210606163521225"></p><h3 id="2-3、分片枚举"><a href="#2-3、分片枚举" class="headerlink" title="2.3、分片枚举"></a>2.3、分片枚举</h3><p>&emsp;&emsp;通过在配置文件中配置可能的枚举 id，自己配置分片，本规则适用于特定的场景，比如有些业务需要按照省份或区县来做保存，而全国省份区县固定的，这类业务使用本条规则。  </p><h4 id="2-3-1、修改schema-xml文件"><a href="#2-3-1、修改schema-xml文件" class="headerlink" title="2.3.1、修改schema.xml文件"></a>2.3.1、修改schema.xml文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;orders_ware_info&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;sharding-by-intfile&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210606173332074.png" alt="image-20210606173332074"></p><h4 id="2-3-2、修改partition-hash-int-txt文件"><a href="#2-3-2、修改partition-hash-int-txt文件" class="headerlink" title="2.3.2、修改partition-hash-int.txt文件"></a>2.3.2、修改partition-hash-int.txt文件</h4><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210606171843559.png" alt="image-20210606171843559"></p><h4 id="2-3-3、修改rule-xml配置文件"><a href="#2-3-3、修改rule-xml配置文件" class="headerlink" title="2.3.3、修改rule.xml配置文件"></a>2.3.3、修改rule.xml配置文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;sharding_by_intfile&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>areacode<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>hash-int<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line">…</span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;hash-int&quot;</span> <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionByFileMap&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapFile&quot;</span>&gt;</span>partition-hash-int.txt<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;type&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultNode&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>columns：分片字段，</p><p>algorithm：分片函数 </p><p>mapFile： 标识配置文件名称</p><p>type： 0为int型、 非0为String</p><p>defaultNode： 默认节点:小于 0 表示不设置默认节点，大于等于 0 表示设置默认节点</p><p>设置默认节点如果碰到不识别的枚举值，就让它路由到默认节点，如不设置不识别就报错</p></blockquote><h4 id="2-3-4、重启MyCat，并创建对应表和数据"><a href="#2-3-4、重启MyCat，并创建对应表和数据" class="headerlink" title="2.3.4、重启MyCat，并创建对应表和数据"></a>2.3.4、重启MyCat，并创建对应表和数据</h4><h5 id="2-3-4-1、修改-etc-my-cnf文件"><a href="#2-3-4-1、修改-etc-my-cnf文件" class="headerlink" title="2.3.4.1、修改/etc/my.cnf文件"></a>2.3.4.1、修改<code>/etc/my.cnf</code>文件</h5><p> &emsp;&emsp;在mycat操作时它是不区分表明大小写的，需要在mysql的配置文件中添加<code>lower_case_table_names=1</code>参数，来保证查询的时候能够进行正常的查询和使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lower_case_table_names&#x3D;1</span><br></pre></td></tr></table></figure><h5 id="2-3-4-2、重启mysql"><a href="#2-3-4-2、重启mysql" class="headerlink" title="2.3.4.2、重启mysql"></a>2.3.4.2、重启mysql</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 重启</span><br><span class="line">service mysqld restart</span><br><span class="line"># 查看状态</span><br><span class="line">service mysqld status</span><br></pre></td></tr></table></figure><h5 id="2-3-4-3、插入新表和数据"><a href="#2-3-4-3、插入新表和数据" class="headerlink" title="2.3.4.3、插入新表和数据"></a>2.3.4.3、插入新表和数据</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#订单归属区域信息表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> orders_ware_info</span><br><span class="line">(</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">INT</span> AUTO_INCREMENT <span class="keyword">comment</span> <span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line"><span class="string">`order_id`</span> <span class="built_in">INT</span> <span class="keyword">comment</span> <span class="string">&#x27;订单编号&#x27;</span>,</span><br><span class="line"><span class="string">`address`</span> <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">comment</span> <span class="string">&#x27;地址&#x27;</span>,</span><br><span class="line"><span class="string">`areacode`</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">comment</span> <span class="string">&#x27;区域编号&#x27;</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">#插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders_ware_info(<span class="keyword">id</span>, order_id,address,areacode) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;北京&#x27;</span>,<span class="string">&#x27;110&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders_ware_info(<span class="keyword">id</span>, order_id,address,areacode) <span class="keyword">VALUES</span> (<span class="number">2</span>,<span class="number">2</span>,<span class="string">&#x27;天津&#x27;</span>,<span class="string">&#x27;120&#x27;</span>);</span><br></pre></td></tr></table></figure><p><font color='red'>注意：这里会出现在MyCat创建的表到真实数据库时是大写，此时需要设置真实数据库不关注大小写，否则写入数据会出现异常。</font></p><h4 id="2-3-5、查看测试结果"><a href="#2-3-5、查看测试结果" class="headerlink" title="2.3.5、查看测试结果"></a>2.3.5、查看测试结果</h4><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210606215302274.png" alt="image-20210606215302274"></p><h3 id="2-4、范围分片"><a href="#2-4、范围分片" class="headerlink" title="2.4、范围分片"></a>2.4、范围分片</h3><p>&emsp;&emsp;此分片适用于提前规划好分片字段某个范围属于哪个分片。  </p><h4 id="2-4-1、修改schema-xml配置文件"><a href="#2-4-1、修改schema-xml配置文件" class="headerlink" title="2.4.1、修改schema.xml配置文件"></a>2.4.1、修改schema.xml配置文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;payment_info&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;auto-sharding-long&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210606220547284.png" alt="image-20210606220547284"></p><h4 id="2-4-2、修改rule-xml配置文件"><a href="#2-4-2、修改rule-xml配置文件" class="headerlink" title="2.4.2、修改rule.xml配置文件"></a>2.4.2、修改rule.xml配置文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;auto_sharding_long&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>order_id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>rang-long<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line">…</span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;rang-long&quot;</span> <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.AutoPartitionByLong&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapFile&quot;</span>&gt;</span>autopartition-long.txt<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultNode&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>columns：分片字段；</p><p>algorithm：分片函数；</p><p>mapFile： 标识配置文件名称；</p><p>defaultNode： 默认节点:小于 0 表示不设置默认节点，大于等于 0 表示设置默认节点；</p><p>设置默认节点如果碰到不识别的枚举值，就让它路由到默认节点，如不设置不识别就报错。</p></blockquote><h4 id="2-4-3、修改autopartition-long-txt配置文件"><a href="#2-4-3、修改autopartition-long-txt配置文件" class="headerlink" title="2.4.3、修改autopartition-long.txt配置文件"></a>2.4.3、修改autopartition-long.txt配置文件</h4><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210606220905737.png" alt="image-20210606220905737"></p><h4 id="2-4-4、重启MyCat，并创建对应表和数据"><a href="#2-4-4、重启MyCat，并创建对应表和数据" class="headerlink" title="2.4.4、重启MyCat，并创建对应表和数据"></a>2.4.4、重启MyCat，并创建对应表和数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#支付信息表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> payment_info</span><br><span class="line">(</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">INT</span> AUTO_INCREMENT <span class="keyword">comment</span> <span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line"><span class="string">`order_id`</span> <span class="built_in">INT</span> <span class="keyword">comment</span> <span class="string">&#x27;订单编号&#x27;</span>,</span><br><span class="line"><span class="string">`payment_status`</span> <span class="built_in">INT</span> <span class="keyword">comment</span> <span class="string">&#x27;支付状态&#x27;</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">#插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> payment_info (<span class="keyword">id</span>,order_id,payment_status) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">101</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> payment_info (<span class="keyword">id</span>,order_id,payment_status) <span class="keyword">VALUES</span> (<span class="number">2</span>,<span class="number">102</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> payment_info (<span class="keyword">id</span>,order_id ,payment_status) <span class="keyword">VALUES</span> (<span class="number">3</span>,<span class="number">103</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> payment_info (<span class="keyword">id</span>,order_id,payment_status) <span class="keyword">VALUES</span> (<span class="number">4</span>,<span class="number">104</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h4 id="2-4-5、查看测试结果"><a href="#2-4-5、查看测试结果" class="headerlink" title="2.4.5、查看测试结果"></a>2.4.5、查看测试结果</h4><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210606221819015.png" alt="image-20210606221819015"></p><h3 id="2-5、范围取模分片"><a href="#2-5、范围取模分片" class="headerlink" title="2.5、范围取模分片"></a>2.5、范围取模分片</h3><p>&emsp;&emsp;范围取模分片是先进行范围分片计算出分片组，组内再求模。其优点可以<strong>避免扩容时的数据迁移，又可以一定程度上避免范围分片的热点问题</strong>。综合了范围分片和求模分片的优点，分片组内使用求模可以保证组内数据比较均匀，分片组之间是范围分片可以兼顾范围查询。最好事先规划好分片的数量，数据扩容时按分片组扩容，则原有分片组的数据不需要迁移。由于分片组内数据比较均匀，所以分片组内可以避免热点数据问题。</p><h4 id="2-5-1、创建数据库"><a href="#2-5-1、创建数据库" class="headerlink" title="2.5.1、创建数据库"></a>2.5.1、创建数据库</h4><p>&emsp;&emsp;测试范围取模分片，需要三个节点进行测试，所以需要添加一个新的数据源M3，并在其创建数据库orders。同样，需要配置数据库不敏感大小写。</p><h4 id="2-5-2、修改schema-xml配置文件"><a href="#2-5-2、修改schema-xml配置文件" class="headerlink" title="2.5.2、修改schema.xml配置文件"></a>2.5.2、修改schema.xml配置文件</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;table name=&quot;test&quot; primaryKey=&quot;id&quot; dataNode=&quot;dn1,dn2,dn3&quot; rule=&quot;auto-sharding-rang-mod&quot; /&gt;</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210606225807993.png" alt="image-20210606225807993"></p><h4 id="2-5-3、修改rule-xml配置文件"><a href="#2-5-3、修改rule-xml配置文件" class="headerlink" title="2.5.3、修改rule.xml配置文件"></a>2.5.3、修改rule.xml配置文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;auto-sharding-rang-mod&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>rang-mod<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;rang-mod&quot;</span> <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionByRangeMod&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapFile&quot;</span>&gt;</span>partition-range-mod.txt<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultNode&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-5-4、修改partition-range-mod-txt配置文件"><a href="#2-5-4、修改partition-range-mod-txt配置文件" class="headerlink" title="2.5.4、修改partition-range-mod.txt配置文件"></a>2.5.4、修改partition-range-mod.txt配置文件</h4><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210606230344846.png" alt="image-20210606230344846"></p><p><code>M</code>表示一万，第一行是0到1万分配两个节点<br><code>M1</code>表示万零一（10001），第二行表示10001到20000分配一个节点。<br><code>=</code>号后面的数字代表该分片组所<strong>拥有</strong>的分片的数量。比如你有5个节点，设置一行<code>=1</code>，那你就剩下4个节点，剩下的配置的和只能小于等于4。</p><h4 id="2-5-5、重启MyCat，并创建对应表和数据"><a href="#2-5-5、重启MyCat，并创建对应表和数据" class="headerlink" title="2.5.5、重启MyCat，并创建对应表和数据"></a>2.5.5、重启MyCat，并创建对应表和数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建测试表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`test`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) ；</span><br><span class="line"><span class="comment"># 插入测试数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">test</span> (<span class="keyword">id</span>, <span class="keyword">name</span>)<span class="keyword">VALUES</span> (<span class="number">9999</span>, <span class="string">&#x27;weikaixxxxxx&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">test</span> (<span class="keyword">id</span>, <span class="keyword">name</span>)<span class="keyword">VALUES</span> (<span class="number">10000</span>, <span class="string">&#x27;weikaixxxxxx&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">test</span> (<span class="keyword">id</span>, <span class="keyword">name</span>)<span class="keyword">VALUES</span> (<span class="number">10001</span>, <span class="string">&#x27;weikaixxxxxx&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">test</span> (<span class="keyword">id</span>, <span class="keyword">name</span>)<span class="keyword">VALUES</span> (<span class="number">20000</span>, <span class="string">&#x27;weikaixxxxxx&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="2-5-6、查看测试结果"><a href="#2-5-6、查看测试结果" class="headerlink" title="2.5.6、查看测试结果"></a>2.5.6、查看测试结果</h4><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210606231201646.png" alt="image-20210606231201646"></p><h3 id="2-6、应用指定的算法"><a href="#2-6、应用指定的算法" class="headerlink" title="2.6、应用指定的算法"></a>2.6、应用指定的算法</h3><p>&emsp;&emsp;在运行阶段由应用程序自主决定路由到哪个分片。</p><h4 id="2-6-1、修改schema-xml配置文件"><a href="#2-6-1、修改schema-xml配置文件" class="headerlink" title="2.6.1、修改schema.xml配置文件"></a>2.6.1、修改schema.xml配置文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;test2&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2,dn3&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;sharding-by-substring&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210606232012033.png" alt="image-20210606232012033"> </p><h4 id="2-6-2、修改rule-xml配置文件"><a href="#2-6-2、修改rule-xml配置文件" class="headerlink" title="2.6.2、修改rule.xml配置文件"></a>2.6.2、修改rule.xml配置文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;sharding-by-substring&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>name<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>sharding-by-substring<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;sharding-by-substring&quot;</span> <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionDirectBySubString&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开始的索引值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;startIndex&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 取值长度 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;size&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 分片数量 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;partitionCount&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 默认的分片节点 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultPartition&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-6-3、重启MyCat，并创建对应表和数据"><a href="#2-6-3、重启MyCat，并创建对应表和数据" class="headerlink" title="2.6.3、重启MyCat，并创建对应表和数据"></a>2.6.3、重启MyCat，并创建对应表和数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`test2`</span> (</span><br><span class="line">    <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test2(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;0-zhangsan&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test2(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;1-lisi&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test2(<span class="keyword">id</span>,<span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;2-wangwu&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="2-6-4、查看测试结果"><a href="#2-6-4、查看测试结果" class="headerlink" title="2.6.4、查看测试结果"></a>2.6.4、查看测试结果</h4><p>&emsp;&emsp;由下图可以看出，<code>mycat</code>会将我们插入的数据根据<code>name</code>值从<code>startIndex</code>截取<code>size</code>数量的字符，结果值匹配分片的索引，最终确定存放在哪个节点</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210606233730864.png" alt="image-20210606233730864"></p><h3 id="2-7、日期分片"><a href="#2-7、日期分片" class="headerlink" title="2.7、日期分片"></a>2.7、日期分片</h3><h4 id="2-7-1、修改schema-xml配置文件"><a href="#2-7-1、修改schema-xml配置文件" class="headerlink" title="2.7.1、修改schema.xml配置文件"></a>2.7.1、修改schema.xml配置文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;login_info&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;sharding-by-date&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210607100442252.png" alt="image-20210607100442252"></p><h4 id="2-7-2、修改rule-xml配置文件"><a href="#2-7-2、修改rule-xml配置文件" class="headerlink" title="2.7.2、修改rule.xml配置文件"></a>2.7.2、修改rule.xml配置文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;sharding-by-date&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>login_date<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>shardingByDate<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line">…</span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;shardingByDate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionByDate&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dateFormat&quot;</span>&gt;</span>yyyy-MM-dd<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sBeginDate&quot;</span>&gt;</span>2021-06-01<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sEndDate&quot;</span>&gt;</span>2021-06-04<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sPartionDay&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>columns：分片字段</p><p>algorithm：分片函数</p><p>dateFormat ：日期格式 </p><p>sBeginDate ：开始日期 </p><p>sEndDate：结束日期,则代表数据达到了这个日期的分片后循环从开始分片插入 </p><p>sPartionDay ：分区天数，即默认从开始日期算起，分隔 2 天一个分区</p></blockquote><h4 id="2-7-3、重启MyCat，并创建对应表和数据"><a href="#2-7-3、重启MyCat，并创建对应表和数据" class="headerlink" title="2.7.3、重启MyCat，并创建对应表和数据"></a>2.7.3、重启MyCat，并创建对应表和数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#用户信息表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> login_info</span><br><span class="line">(</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">INT</span> AUTO_INCREMENT <span class="keyword">comment</span> <span class="string">&#x27;编号&#x27;</span>,</span><br><span class="line"><span class="string">`user_id`</span> <span class="built_in">INT</span> <span class="keyword">comment</span> <span class="string">&#x27;用户编号&#x27;</span>,</span><br><span class="line"><span class="string">`login_date`</span> <span class="built_in">date</span> <span class="keyword">comment</span> <span class="string">&#x27;登录日期&#x27;</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">#插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> login_info(<span class="keyword">id</span>,user_id,login_date) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">101</span>,<span class="string">&#x27;2021-06-01&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> login_info(<span class="keyword">id</span>,user_id,login_date) <span class="keyword">VALUES</span> (<span class="number">2</span>,<span class="number">102</span>,<span class="string">&#x27;2021-06-02&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> login_info(<span class="keyword">id</span>,user_id,login_date) <span class="keyword">VALUES</span> (<span class="number">3</span>,<span class="number">103</span>,<span class="string">&#x27;2021-06-03&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> login_info(<span class="keyword">id</span>,user_id,login_date) <span class="keyword">VALUES</span> (<span class="number">4</span>,<span class="number">104</span>,<span class="string">&#x27;2021-06-04&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> login_info(<span class="keyword">id</span>,user_id,login_date) <span class="keyword">VALUES</span> (<span class="number">5</span>,<span class="number">103</span>,<span class="string">&#x27;2021-06-05&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> login_info(<span class="keyword">id</span>,user_id,login_date) <span class="keyword">VALUES</span> (<span class="number">6</span>,<span class="number">104</span>,<span class="string">&#x27;2021-06-06&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="2-7-4、查看测试结果"><a href="#2-7-4、查看测试结果" class="headerlink" title="2.7.4、查看测试结果"></a>2.7.4、查看测试结果</h4><p>&emsp;&emsp;我们可以看到：数据按照时间间隔进行插入，当整个循环结束之后，会重新进行循环。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210607101251462.png" alt="image-20210607101251462"></p><h1 id="五、全局序列号"><a href="#五、全局序列号" class="headerlink" title="五、全局序列号"></a>五、全局序列号</h1><h2 id="1、全局序列号简介"><a href="#1、全局序列号简介" class="headerlink" title="1、全局序列号简介"></a>1、全局序列号简介</h2><p>&emsp;&emsp;在实现分库分表的情况下，数据库自增主键已无法保证自增主键的全局唯一。为此， Mycat 提供了全局 sequence，并且提供了包含本地配置和数据库配置等多种实现方式：</p><h3 id="1-1、-本地文件"><a href="#1-1、-本地文件" class="headerlink" title="1.1、 本地文件"></a>1.1、 本地文件</h3><p>&emsp;&emsp;此方式 Mycat 将 sequence 配置到文件中，当使用到 sequence 中的配置后， Mycat 会更下classpath 中的 sequence_conf.properties 文件中 sequence 当前的值。</p><blockquote><ol><li>优点： 本地加载，读取速度较快 </li><li>缺点： 抗风险能力差， Mycat 所在主机宕机后，无法读取本地文件</li></ol></blockquote><h3 id="1-2、-数据库方式"><a href="#1-2、-数据库方式" class="headerlink" title="1.2、 数据库方式"></a>1.2、 数据库方式</h3><p>&emsp;&emsp;利用数据库一个表来进行计数累加。但是并不是每次生成序列都读写数据库，这样效率太低。Mycat 会预加载一部分号段到 Mycat 的内存中，这样大部分读写序列都是在内存中完成的。如果内存中的号段用完了 Mycat 会再向数据库要一次。<br><strong>问题：那如果 Mycat 崩溃了 ，那内存中的序列岂不是都没了？</strong><br>&emsp;&emsp;是的。如果是这样，那么 Mycat 启动后会向数据库申请新的号段，原有号段会弃用。也就是说如果 Mycat 重启，那么损失是当前的号段没用完的号码，但是不会因此出现主键重复。</p><h3 id="1-3、-时间戳方式"><a href="#1-3、-时间戳方式" class="headerlink" title="1.3、 时间戳方式"></a>1.3、 时间戳方式</h3><p>&emsp;&emsp;全局序列ID= 64 位二进制 (42(毫秒)+5(机器 ID)+5(业务编码)+12(重复累加) 换算成十进制为 18 位数的long 类型，每毫秒可以并发 12 位二进制的累加。</p><blockquote><ol><li>优点： 配置简单</li><li>缺点： 18 位 ID 过长</li></ol></blockquote><h3 id="1-4、-自主生成全局序列"><a href="#1-4、-自主生成全局序列" class="headerlink" title="1.4、 自主生成全局序列"></a>1.4、 自主生成全局序列</h3><p>&emsp;&emsp;可以在 java 项目里自己生成全局序列，但是自主生成需要单独在工程中用 java 代码实现，还是推荐使用 Mycat 自带全局序列。  </p><blockquote><ol><li>根据业务逻辑组合</li><li>可以利用 redis 的单线程原子性 incr 来生成序列</li><li>可以使用分布式ZK ID生成器</li></ol></blockquote><h2 id="2、全局序列号的操作"><a href="#2、全局序列号的操作" class="headerlink" title="2、全局序列号的操作"></a>2、全局序列号的操作</h2><p>&emsp;&emsp;本次测试仅测试前三种方法，自主生成全局序列在 MyCat 自带全局序列功能能够达到要求时不考虑该方法。</p><h3 id="2-1、本地文件"><a href="#2-1、本地文件" class="headerlink" title="2.1、本地文件"></a>2.1、本地文件</h3><h4 id="2-1-1、修改-sequence-conf-properties-文件"><a href="#2-1-1、修改-sequence-conf-properties-文件" class="headerlink" title="2.1.1、修改 sequence_conf.properties 文件"></a>2.1.1、修改 sequence_conf.properties 文件</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用过的历史分段（无特殊需要不配置）</span></span><br><span class="line"><span class="meta">GLOBAL.HISIDS</span>=<span class="string"></span></span><br><span class="line"><span class="comment">#最小 ID 值</span></span><br><span class="line"><span class="meta">GLOBAL.MINID</span>=<span class="string">10001</span></span><br><span class="line"><span class="comment">#最大 ID 值</span></span><br><span class="line"><span class="meta">GLOBAL.MAXID</span>=<span class="string">20000</span></span><br><span class="line"><span class="comment"># CURID 表示当前 ID 值</span></span><br><span class="line"><span class="meta">GLOBAL.CURID</span>=<span class="string">10000</span></span><br></pre></td></tr></table></figure><h4 id="2-1-2、修改server-xml-文件"><a href="#2-1-2、修改server-xml-文件" class="headerlink" title="2.1.2、修改server.xml 文件"></a>2.1.2、修改server.xml 文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- sequnceHandlerType 需要配置为 0，表示使用本地文件方式。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 全局序列类型： 0-本地文件， 1-数据库方式， 2-时间戳方式。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">system</span>&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sequnceHandlerType&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="tag">&lt;/<span class="name">system</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210607140340488.png" alt="image-20210607140340488"></p><h4 id="2-1-3、重启MyCat，插入测试数据"><a href="#2-1-3、重启MyCat，插入测试数据" class="headerlink" title="2.1.3、重启MyCat，插入测试数据"></a>2.1.3、重启MyCat，插入测试数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders(<span class="keyword">id</span>,order_type,customer_id,amount) <span class="keyword">VALUES</span>(<span class="keyword">next</span> <span class="keyword">value</span> <span class="keyword">for</span> mycatseq_global,<span class="number">101</span>,<span class="number">100</span>,<span class="number">100100</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders(<span class="keyword">id</span>,order_type,customer_id,amount) <span class="keyword">VALUES</span>(<span class="keyword">next</span> <span class="keyword">value</span> <span class="keyword">for</span> mycatseq_global,<span class="number">101</span>,<span class="number">100</span>,<span class="number">100300</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders(<span class="keyword">id</span>,order_type,customer_id,amount) <span class="keyword">VALUES</span>(<span class="keyword">next</span> <span class="keyword">value</span> <span class="keyword">for</span> mycatseq_global,<span class="number">101</span>,<span class="number">101</span>,<span class="number">120000</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders(<span class="keyword">id</span>,order_type,customer_id,amount) <span class="keyword">VALUES</span>(<span class="keyword">next</span> <span class="keyword">value</span> <span class="keyword">for</span> mycatseq_global,<span class="number">101</span>,<span class="number">101</span>,<span class="number">103000</span>);</span><br></pre></td></tr></table></figure><h4 id="2-1-4、查看测试结果"><a href="#2-1-4、查看测试结果" class="headerlink" title="2.1.4、查看测试结果"></a>2.1.4、查看测试结果</h4><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210607141307381.png" alt="image-20210607141307381"></p><h3 id="2-2、数据库方式"><a href="#2-2、数据库方式" class="headerlink" title="2.2、数据库方式"></a>2.2、数据库方式</h3><h4 id="2-2-1、数据库支持"><a href="#2-2-1、数据库支持" class="headerlink" title="2.2.1、数据库支持"></a>2.2.1、数据库支持</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在 dn1 上创建全局序列表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> MYCAT_SEQUENCE (<span class="keyword">NAME</span> <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,current_value <span class="built_in">INT</span> <span class="keyword">NOT</span></span><br><span class="line"><span class="literal">NULL</span>,<span class="keyword">increment</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">100</span>, PRIMARY <span class="keyword">KEY</span>(<span class="keyword">NAME</span>)) <span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span>;</span><br><span class="line"><span class="comment">#创建全局序列所需函数</span></span><br><span class="line"></span><br><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> mycat_seq_currval(seq_name <span class="built_in">VARCHAR</span>(<span class="number">50</span>)) <span class="keyword">RETURNS</span> <span class="built_in">VARCHAR</span>(<span class="number">64</span>)</span><br><span class="line"><span class="keyword">DETERMINISTIC</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> retval <span class="built_in">VARCHAR</span>(<span class="number">64</span>);</span><br><span class="line"><span class="keyword">SET</span> retval=<span class="string">&quot;-999999999,null&quot;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(<span class="keyword">CAST</span>(current_value <span class="keyword">AS</span> <span class="built_in">CHAR</span>),<span class="string">&quot;,&quot;</span>,<span class="keyword">CAST</span>(<span class="keyword">increment</span> <span class="keyword">AS</span> <span class="built_in">CHAR</span>)) <span class="keyword">INTO</span> retval <span class="keyword">FROM</span></span><br><span class="line">MYCAT_SEQUENCE <span class="keyword">WHERE</span> <span class="keyword">NAME</span> = seq_name;</span><br><span class="line">RETURN retval;</span><br><span class="line"><span class="keyword">END</span> $$</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> mycat_seq_setval(seq_name <span class="built_in">VARCHAR</span>(<span class="number">50</span>),<span class="keyword">VALUE</span> <span class="built_in">INTEGER</span>) <span class="keyword">RETURNS</span></span><br><span class="line"><span class="built_in">VARCHAR</span>(<span class="number">64</span>)</span><br><span class="line"><span class="keyword">DETERMINISTIC</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">UPDATE</span> MYCAT_SEQUENCE</span><br><span class="line"><span class="keyword">SET</span> current_value = <span class="keyword">VALUE</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NAME</span> = seq_name;</span><br><span class="line">RETURN mycat_seq_currval(seq_name);</span><br><span class="line"><span class="keyword">END</span> $$</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> mycat_seq_nextval(seq_name <span class="built_in">VARCHAR</span>(<span class="number">50</span>)) <span class="keyword">RETURNS</span> <span class="built_in">VARCHAR</span>(<span class="number">64</span>)</span><br><span class="line"><span class="keyword">DETERMINISTIC</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">UPDATE</span> MYCAT_SEQUENCE</span><br><span class="line"><span class="keyword">SET</span> current_value = current_value + <span class="keyword">increment</span> <span class="keyword">WHERE</span> <span class="keyword">NAME</span> = seq_name;</span><br><span class="line">RETURN mycat_seq_currval(seq_name);</span><br><span class="line"><span class="keyword">END</span> $$</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"><span class="comment">#初始化序列表记录</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> MYCAT_SEQUENCE(<span class="keyword">NAME</span>,current_value,<span class="keyword">increment</span>) <span class="keyword">VALUES</span> (<span class="string">&#x27;ORDERS&#x27;</span>, <span class="number">200000</span>,</span><br><span class="line"><span class="number">100</span>);</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210607143938390.png" alt="image-20210607143938390"></p><h4 id="2-2-2、修改server-xml-文件"><a href="#2-2-2、修改server-xml-文件" class="headerlink" title="2.2.2、修改server.xml 文件"></a>2.2.2、修改server.xml 文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- sequnceHandlerType 需要配置为 1，表示使用数据库方式。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 全局序列类型： 0-本地文件， 1-数据库方式， 2-时间戳方式。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">system</span>&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sequnceHandlerType&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="tag">&lt;/<span class="name">system</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-2-3、修改-schema-xml-文件"><a href="#2-2-3、修改-schema-xml-文件" class="headerlink" title="2.2.3、修改 schema.xml 文件"></a>2.2.3、修改 schema.xml 文件</h4><h4 id="2-2-4、修改-sequence-db-conf-properties-文件"><a href="#2-2-4、修改-sequence-db-conf-properties-文件" class="headerlink" title="2.2.4、修改 sequence_db_conf.properties 文件"></a>2.2.4、修改 sequence_db_conf.properties 文件</h4><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210607144415152.png" alt="image-20210607144415152"></p><h4 id="2-2-5、重启MyCat，插入测试数据"><a href="#2-2-5、重启MyCat，插入测试数据" class="headerlink" title="2.2.5、重启MyCat，插入测试数据"></a>2.2.5、重启MyCat，插入测试数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> orders(<span class="keyword">id</span>,amount,customer_id,order_type) <span class="keyword">values</span>(<span class="keyword">next</span> <span class="keyword">value</span> <span class="keyword">for</span> MYCATSEQ_ORDERS,<span class="number">1009</span>,<span class="number">101</span>,<span class="number">102</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> orders(<span class="keyword">id</span>,amount,customer_id,order_type) <span class="keyword">values</span>(<span class="keyword">next</span> <span class="keyword">value</span> <span class="keyword">for</span> MYCATSEQ_ORDERS,<span class="number">1019</span>,<span class="number">101</span>,<span class="number">102</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> orders(<span class="keyword">id</span>,amount,customer_id,order_type) <span class="keyword">values</span>(<span class="keyword">next</span> <span class="keyword">value</span> <span class="keyword">for</span> MYCATSEQ_ORDERS,<span class="number">1029</span>,<span class="number">101</span>,<span class="number">102</span>);</span><br></pre></td></tr></table></figure><h4 id="2-2-6、查看测试结果"><a href="#2-2-6、查看测试结果" class="headerlink" title="2.2.6、查看测试结果"></a>2.2.6、查看测试结果</h4><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210607145251369.png" alt="image-20210607145251369"></p><p>&emsp;&emsp;此时如果关闭MyCat，进行重启，再次插入数据，则MyCat会将105之后的数据丢掉，重新获取，从200开始。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210607145549676.png" alt="image-20210607145549676"></p><h3 id="2-3、时间戳方式"><a href="#2-3、时间戳方式" class="headerlink" title="2.3、时间戳方式"></a>2.3、时间戳方式</h3><h4 id="2-3-1、修改-server-xml-文件"><a href="#2-3-1、修改-server-xml-文件" class="headerlink" title="2.3.1、修改 server.xml 文件"></a>2.3.1、修改 server.xml 文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- sequnceHandlerType 需要配置为 2，表示使用时间戳方式。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 全局序列类型： 0-本地文件， 1-数据库方式， 2-时间戳方式。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">system</span>&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sequnceHandlerType&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="tag">&lt;/<span class="name">system</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-3-2、修改-sequence-time-conf-properties"><a href="#2-3-2、修改-sequence-time-conf-properties" class="headerlink" title="2.3.2、修改 sequence_time_conf.properties"></a>2.3.2、修改 sequence_time_conf.properties</h4><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210607150751353.png" alt="image-20210607150751353"></p><h4 id="2-3-3、修改schema-xml文件"><a href="#2-3-3、修改schema-xml文件" class="headerlink" title="2.3.3、修改schema.xml文件"></a>2.3.3、修改schema.xml文件</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;table name=&quot;table_time&quot; dataNode=&quot;dn1,dn2&quot; primaryKey=&quot;id&quot; autoIncrement=&quot;true&quot; rule=&quot;mod-long&quot; /&gt;</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210607151106388.png" alt="image-20210607151106388"></p><h4 id="2-3-4、重启MyCat，插入测试数据"><a href="#2-3-4、重启MyCat，插入测试数据" class="headerlink" title="2.3.4、重启MyCat，插入测试数据"></a>2.3.4、重启MyCat，插入测试数据</h4><p>&emsp;&emsp;这里需要注意的是，放置id的字段必须是 bigint 或超过18位的字符串，否则会报错。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_time(<span class="keyword">id</span> <span class="built_in">bigint</span> auto_increment primary <span class="keyword">key</span>,xm <span class="built_in">varchar</span>(<span class="number">32</span>));</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_time(<span class="keyword">id</span>,xm) <span class="keyword">values</span>(<span class="keyword">next</span> <span class="keyword">value</span> <span class="keyword">for</span> MYCATSEQ_GLOBAL，<span class="string">&#x27;lisi&#x27;</span>) ;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table_time(<span class="keyword">id</span>,xm) <span class="keyword">values</span>(<span class="keyword">next</span> <span class="keyword">value</span> <span class="keyword">for</span> MYCATSEQ_GLOBAL，<span class="string">&#x27;zhangsan&#x27;</span>) ;</span><br></pre></td></tr></table></figure><h4 id="2-3-5、查看测试结果-1"><a href="#2-3-5、查看测试结果-1" class="headerlink" title="2.3.5、查看测试结果"></a>2.3.5、查看测试结果</h4><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210607154334288.png" alt="image-20210607154334288"></p><h1 id="六、基于-HA-机制的-MyCat-高可用"><a href="#六、基于-HA-机制的-MyCat-高可用" class="headerlink" title="六、基于 HA 机制的 MyCat 高可用"></a>六、基于 HA 机制的 MyCat 高可用</h1><p>&emsp;&emsp;在上面的操作中，我们已经实现了mysql机器的高可用，可以动态切换master，但是如果 MyCat 崩溃了呢？我们应该如何处理呢？所以此时就需要搭建 MyCat 的高可用集群了。</p><p>&emsp;&emsp;在MyCat 的权威指南中，介绍了多种高可用的方案，在这里我们讲解一种使用最多的方案，使用HAProxy+Keepalived配合使用来实现myact的高可用。HAproxy实现了MyCat 多节点的集群高可用和负载均衡，而HAProxy自身的高可用则可以通过Keepalived来实现。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210607154943933.png" alt="image-20210607154943933"></p><h2 id="1、规划部署方案"><a href="#1、规划部署方案" class="headerlink" title="1、规划部署方案"></a>1、规划部署方案</h2><table><thead><tr><th align="center">编号</th><th align="center">角色</th><th align="center">IP 地址</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">MyCat1</td><td align="center">192.168.66.131</td></tr><tr><td align="center">2</td><td align="center">MyCat2</td><td align="center">192.168.66.132</td></tr><tr><td align="center">3</td><td align="center">HAProxy（master）</td><td align="center">192.168.66.133</td></tr><tr><td align="center">4</td><td align="center">Keepalived（master）</td><td align="center">192.168.66.133</td></tr><tr><td align="center">5</td><td align="center">HAProxy（backup）</td><td align="center">192.168.66.134</td></tr><tr><td align="center">6</td><td align="center">Keepalived（backup）</td><td align="center">192.168.66.134</td></tr></tbody></table><h2 id="2、部署MyCat"><a href="#2、部署MyCat" class="headerlink" title="2、部署MyCat"></a>2、部署MyCat</h2><p>&emsp;&emsp;在上面的操作之后，我们已经部署了MyCat1，所以我们还需要部署一套MyCat2。</p><h3 id="2-1、解压MyCat"><a href="#2-1、解压MyCat" class="headerlink" title="2.1、解压MyCat"></a>2.1、解压MyCat</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxf Mycat-server-1.6.7.5-release-20200410174409-linux.tar.gz -C /usr/local</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210601221930172.png" alt="image-20210601221930172"></p><h3 id="2-2、拷贝配置"><a href="#2-2、拷贝配置" class="headerlink" title="2.2、拷贝配置"></a>2.2、拷贝配置</h3><p>&emsp;&emsp;将MyCat1中的所有配置【conf目录】拷贝至MyCat2。</p><h3 id="2-3、启动MyCat"><a href="#2-3、启动MyCat" class="headerlink" title="2.3、启动MyCat"></a>2.3、启动MyCat</h3><p>&emsp;&emsp;为了使MyCat可以在任意位置被访问，所以需要配置环境变量，结果如图则为成功！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">增加环境变量</span></span><br><span class="line">vi /etc/profile</span><br><span class="line">export MYCAT_HOME=/usr/local/mycat</span><br><span class="line">export PATH=$PATH:$MYCAT_HOME/bin</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">让添加的配置生效</span></span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;开放 MyCat1 和 MyCat2 的外部访问端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=8066/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><h3 id="2-4、测试是否可以访问"><a href="#2-4、测试是否可以访问" class="headerlink" title="2.4、测试是否可以访问"></a>2.4、测试是否可以访问</h3><p>&emsp;&emsp;启动MyCat2，测试是否可以访问，是否异常等。</p><h2 id="3、安装配置-HAProxy"><a href="#3、安装配置-HAProxy" class="headerlink" title="3、安装配置 HAProxy"></a>3、安装配置 HAProxy</h2><h3 id="3-1、解压与编译-HAProxy"><a href="#3-1、解压与编译-HAProxy" class="headerlink" title="3.1、解压与编译 HAProxy"></a>3.1、解压与编译 HAProxy</h3><p>&emsp;&emsp;在133和134两台机器上解压HAProxy。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 解压安装包</span></span><br><span class="line">tar -zxf haproxy-1.8.25.tar.gz -C /usr/local</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入解压后的目录</span></span><br><span class="line">cd /usr/local/haproxy-1.8.25</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看内核版本</span></span><br><span class="line">uname -r</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进行编译</span></span><br><span class="line">make TARGET=linux310 PREFIX=/usr/local/haproxy ARCH=x86_64</span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译完成后，进行安装</span></span><br><span class="line">make install PREFIX=/usr/local/haproxy</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210607171957835.png" alt="image-20210607171957835"></p><h3 id="3-2、配置haproxy-conf"><a href="#3-2、配置haproxy-conf" class="headerlink" title="3.2、配置haproxy.conf"></a>3.2、配置haproxy.conf</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装完成后， 创建目录、 创建HAProxy配置文件</span></span><br><span class="line">mkdir -p /usr/data/haproxy/ &amp;&amp; vim /usr/local/haproxy/haproxy.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置文件中插入以下配置信息,并保存</span></span><br><span class="line">global</span><br><span class="line">    log 127.0.0.1 local0</span><br><span class="line">    #log 127.0.0.1 local1 notice</span><br><span class="line">    #log loghost local0 info</span><br><span class="line">    maxconn 4096</span><br><span class="line">    chroot /usr/local/haproxy</span><br><span class="line">    pidfile /usr/data/haproxy/haproxy.pid</span><br><span class="line">    uid 99</span><br><span class="line">    gid 99</span><br><span class="line">    daemon</span><br><span class="line">    #debug</span><br><span class="line">    #quiet</span><br><span class="line">defaults</span><br><span class="line">log global</span><br><span class="line">mode tcp</span><br><span class="line">    option abortonclose</span><br><span class="line">    option redispatch</span><br><span class="line">    retries 3</span><br><span class="line">    maxconn 2000</span><br><span class="line">    timeout connect 5000</span><br><span class="line">    timeout client 50000</span><br><span class="line">    timeout server 50000</span><br><span class="line">listen proxy_status</span><br><span class="line">    bind :48066</span><br><span class="line">        mode tcp</span><br><span class="line">        balance roundrobin</span><br><span class="line">        server mycat_1 192.168.66.131:8066 check inter 10s</span><br><span class="line">        server mycat_2 192.168.66.132:8066 check inter 10s</span><br><span class="line">frontend admin_stats</span><br><span class="line">bind :7777</span><br><span class="line">        mode http</span><br><span class="line">        stats enable</span><br><span class="line">        option httplog</span><br><span class="line">        maxconn 10</span><br><span class="line">        stats refresh 30s</span><br><span class="line">        stats uri /admin</span><br><span class="line">        stats auth admin:123123</span><br><span class="line">        stats hide-version</span><br><span class="line">        stats admin if TRUE</span><br></pre></td></tr></table></figure><h3 id="3-3、启动验证"><a href="#3-3、启动验证" class="headerlink" title="3.3、启动验证"></a>3.3、启动验证</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动HAProxy</span></span><br><span class="line">/usr/local/haproxy/sbin/haproxy -f /usr/local/haproxy/haproxy.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看HAProxy进程</span></span><br><span class="line">ps -ef|grep haproxy</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 开放7777端口</span></span><br><span class="line">firewall-cmd --zone=public --add-port=7777/tcp --permanent</span><br><span class="line">firewall-cmd --zone=public --add-port=48066/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 打开浏览器访问</span></span><br><span class="line">http://192.168.66.133:7777/admin</span><br><span class="line">http://192.168.66.134:7777/admin</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 验证负载均衡，通过HAProxy访问Mycat</span></span><br><span class="line">mysql -umycat -p123456 -h 192.168.66.134 -P 48066</span><br><span class="line">mysql -umycat -p123456 -h 192.168.66.133 -P 48066</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210607221825982.png" alt="image-20210607221825982"></p><p>&emsp;&emsp;出现两个绿色的条，说明已经部署成功了，在两台机器上都部署HAProxy。</p><h2 id="4、安装配置Keepalived"><a href="#4、安装配置Keepalived" class="headerlink" title="4、安装配置Keepalived"></a>4、安装配置Keepalived</h2><h3 id="4-1、解压并编译Keepalived"><a href="#4-1、解压并编译Keepalived" class="headerlink" title="4.1、解压并编译Keepalived"></a>4.1、解压并编译Keepalived</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装依赖插件</span></span><br><span class="line">yum install -y gcc openssl-devel popt-devel</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压安装包到/usr/local</span></span><br><span class="line">tar -zxf keepalived-1.4.5.tar.gz -C /usr/<span class="built_in">local</span>/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入解压后的目录， 进行配置， 进行编译</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/keepalived-1.4.5 &amp;&amp; ./configure --prefix=/usr/<span class="built_in">local</span>/keepalived</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行编译， 完成后进行安装</span></span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h3 id="4-2、修改配置文件"><a href="#4-2、修改配置文件" class="headerlink" title="4.2、修改配置文件"></a>4.2、修改配置文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 拷贝配置文件</span></span><br><span class="line">cp /usr/local/keepalived-1.4.5/keepalived/etc/init.d/keepalived /etc/init.d/</span><br><span class="line">mkdir /etc/keepalived</span><br><span class="line">cp /usr/local/keepalived/etc/keepalived/keepalived.conf /etc/keepalived/</span><br><span class="line">cp /usr/local/keepalived-1.4.5/keepalived/etc/sysconfig/keepalived /etc/sysconfig/</span><br><span class="line">cp /usr/local/keepalived/sbin/keepalived /usr/sbin/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改配置文件</span></span><br><span class="line">vim /etc/keepalived/keepalived.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改的位置和内容</span></span><br><span class="line">global_defs &#123;</span><br><span class="line">   notification_email &#123;</span><br><span class="line">     acassen@firewall.loc</span><br><span class="line">     failover@firewall.loc</span><br><span class="line">     sysadmin@firewall.loc</span><br><span class="line">   &#125;</span><br><span class="line">   notification_email_from Alexandre.Cassen@firewall.loc</span><br><span class="line">   smtp_server 127.0.0.1</span><br><span class="line">   smtp_connect_timeout 30</span><br><span class="line">   router_id LVS_DEVEL</span><br><span class="line">   vrrp_skip_check_adv_addr</span><br><span class="line">   vrrp_strict</span><br><span class="line">   vrrp_garp_interval 0</span><br><span class="line">   vrrp_gna_interval 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER #备机需要修改此配置 backof</span><br><span class="line">    interface ens33</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.66.200/24 dev ens33 label ens33:3</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3、启动验证"><a href="#4-3、启动验证" class="headerlink" title="4.3、启动验证"></a>4.3、启动验证</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动Keepalived</span></span><br><span class="line">service keepalived start</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 验证Keepalived启动状态</span></span><br><span class="line">service keepalived status</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 登录验证</span></span><br><span class="line">mysql -umycat -p123456 -h 192.168.66.200 -P 48066</span><br></pre></td></tr></table></figure><h3 id="4-4、测试高可用"><a href="#4-4、测试高可用" class="headerlink" title="4.4、测试高可用"></a>4.4、测试高可用</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 关闭一台MyCat，登录验证，依然可以正常使用</span></span><br><span class="line">mysql -umycat -p123456 -h 192.168.66.200 -P 48066</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210608110510300.png" alt="image-20210608110510300"></p><h1 id="七、MyCat-安全设置"><a href="#七、MyCat-安全设置" class="headerlink" title="七、MyCat 安全设置"></a>七、MyCat 安全设置</h1><h2 id="1、权限配置"><a href="#1、权限配置" class="headerlink" title="1、权限配置"></a>1、权限配置</h2><p>&emsp;&emsp;目前 MyCat 对于中间件的连接控制并没有做太复杂的控制，目前只做了中间件逻辑库级别的读<br>写权限控制。是通过 server.xml 的 user 标签进行配置。  </p><h3 id="1-1、修改server-xml文件"><a href="#1-1、修改server-xml文件" class="headerlink" title="1.1、修改server.xml文件"></a>1.1、修改server.xml文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;mycat&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>TESTDB<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>user<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>TESTDB<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;readOnly&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>标签属性</th><th>说明</th></tr></thead><tbody><tr><td>name</td><td>应用连接中间件逻辑库的用户名</td></tr><tr><td>password</td><td>该用户对应的密码</td></tr><tr><td>schemas</td><td>应用当前连接的逻辑库中所对应的逻辑表。 schemas 中可以配置一个或多个</td></tr><tr><td>readOnly</td><td>应用连接中间件逻辑库所具有的权限。 true 为只读， false 为读写都有，默认为 false</td></tr></tbody></table><h3 id="1-2、测试user用户"><a href="#1-2、测试user用户" class="headerlink" title="1.2、测试user用户"></a>1.2、测试user用户</h3><p>&emsp;&emsp;我们之前已经使用了mycat用户，在没有配置 readOnly 时，可以进行读写操作。此时我们测试user用户，观察发现只读，不能进行写操作。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210608113455754.png" alt="image-20210608113455754"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders(<span class="keyword">id</span>,order_type,customer_id,amount) <span class="keyword">VALUES</span> (<span class="number">999</span>,<span class="number">199</span>,<span class="number">100</span>,<span class="number">100100</span>);</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210608113614327.png" alt="image-20210608113614327"></p><h2 id="2、privileges-标签权限控制"><a href="#2、privileges-标签权限控制" class="headerlink" title="2、privileges 标签权限控制"></a>2、privileges 标签权限控制</h2><p>&emsp;&emsp;在 user 标签下的 privileges 标签可以对逻辑库（schema）、表（table）进行精细化的 DML 权限控制。<br>&emsp;&emsp;privileges 标签下的 check 属性，如为 true 开启权限检查，为 false 不开启，默认为 false。<br>&emsp;&emsp;由于 MyCat 一个用户的 schemas 属性可配置多个逻辑库（schema） ，所以 privileges 的下级节点 schema 节点同样可配置多个，对多库多表进行细粒度的 DML 权限控制。  </p><h3 id="2-1、修改server-xml文件"><a href="#2-1、修改server-xml文件" class="headerlink" title="2.1、修改server.xml文件"></a>2.1、修改server.xml文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;mycat&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>TESTDB<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">privileges</span> <span class="attr">check</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;TESTDB&quot;</span> <span class="attr">dml</span>=<span class="string">&quot;1111&quot;</span> &gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">dml</span>=<span class="string">&quot;0000&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">privileges</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">DML 权限</th><th align="center">增加（insert）</th><th align="center">更新（update）</th><th align="center">查询（select）</th><th align="center">删除（select）</th></tr></thead><tbody><tr><td align="center">0000</td><td align="center">禁止</td><td align="center">禁止</td><td align="center">禁止</td><td align="center">禁止</td></tr><tr><td align="center">0010</td><td align="center">禁止</td><td align="center">禁止</td><td align="center">可以</td><td align="center">禁止</td></tr><tr><td align="center">1110</td><td align="center">可以</td><td align="center">禁止</td><td align="center">禁止</td><td align="center">禁止</td></tr><tr><td align="center">1111</td><td align="center">可以</td><td align="center">可以</td><td align="center">可以</td><td align="center">可以</td></tr></tbody></table><h3 id="2-2、测试权限是否生效"><a href="#2-2、测试权限是否生效" class="headerlink" title="2.2、测试权限是否生效"></a>2.2、测试权限是否生效</h3><p>&emsp;&emsp;我们上面将<code>mycat</code>用户对orders这张表的权限设置为既不能读也不能写，重启MyCat测试效果。如下图，我们看到<code>mycat</code>用户没办法进行读写，提示这个用户没有权限。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210608135932078.png" alt="image-20210608135932078"></p><h2 id="3、SQL-拦截"><a href="#3、SQL-拦截" class="headerlink" title="3、SQL 拦截"></a>3、SQL 拦截</h2><p>&emsp;&emsp;firewall 标签用来定义防火墙。firewall 下 whitehost 标签用来定义 IP 白名单，blacklist 用来定义SQL 黑名单。 </p><h3 id="3-1、白名单"><a href="#3-1、白名单" class="headerlink" title="3.1、白名单"></a>3.1、白名单</h3><p>&emsp;&emsp;我们可以通过设置白名单， 实现某主机某用户可以访问 Mycat，而其他主机用户禁止访问。</p><h4 id="3-1-1、修改server-xml文件"><a href="#3-1-1、修改server-xml文件" class="headerlink" title="3.1.1、修改server.xml文件"></a>3.1.1、修改server.xml文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置只有192.168.66.131主机可以通过mycat用户访问 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">firewall</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">whitehost</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">host</span> <span class="attr">host</span>=<span class="string">&quot;192.168.66.131&quot;</span> <span class="attr">user</span>=<span class="string">&quot;mycat&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">whitehost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">firewall</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210608141415733.png" alt="image-20210608141415733"></p><h4 id="3-1-2、测试访问效果"><a href="#3-1-2、测试访问效果" class="headerlink" title="3.1.2、测试访问效果"></a>3.1.2、测试访问效果</h4><p>&emsp;&emsp;如下图，重启使用<code>mycat</code>账户能够登陆访问，而使用<code>user</code>账户无法登陆。同时，如果使用<code>mycat</code>账户在其他ip进行登陆时，也会登陆失败。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210608141533696.png" alt="image-20210608141533696"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210608141745815.png" alt="image-20210608141745815"></p><h3 id="3-2、黑名单"><a href="#3-2、黑名单" class="headerlink" title="3.2、黑名单"></a>3.2、黑名单</h3><p>&emsp;&emsp;我们可以通过设置黑名单， 实现 MyCat 对具体 SQL 操作的拦截， 如增删改查等操作的拦截。  </p><h4 id="3-2-1、修改server-xml文件"><a href="#3-2-1、修改server-xml文件" class="headerlink" title="3.2.1、修改server.xml文件"></a>3.2.1、修改server.xml文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置禁止mycat用户进行删除操作 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">firewall</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">whitehost</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">host</span> <span class="attr">host</span>=<span class="string">&quot;192.168.66.131&quot;</span> <span class="attr">user</span>=<span class="string">&quot;mycat&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">whitehost</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">blacklist</span> <span class="attr">check</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;deleteAllow&quot;</span>&gt;</span>false<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">blacklist</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">firewall</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210608144037568.png" alt="image-20210608144037568"></p><table><thead><tr><th align="center">配置项</th><th align="center">缺省值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">selelctAllow</td><td align="center">true</td><td align="center">是否允许执行 SELECT 语句</td></tr><tr><td align="center">deleteAllow</td><td align="center">true</td><td align="center">是否允许执行 DELETE 语句</td></tr><tr><td align="center">updateAllow</td><td align="center">true</td><td align="center">是否允许执行 UPDATE 语句</td></tr><tr><td align="center">insertAllow</td><td align="center">true</td><td align="center">是否允许执行 INSERT 语句</td></tr><tr><td align="center">createTableAllow</td><td align="center">true</td><td align="center">是否允许创建表</td></tr><tr><td align="center">setAllow</td><td align="center">true</td><td align="center">是否允许使用 SET 语法</td></tr><tr><td align="center">alterTableAllow</td><td align="center">true</td><td align="center">是否允许执行 Alter Table 语句</td></tr><tr><td align="center">dropTableAllow</td><td align="center">true</td><td align="center">是否允许修改表</td></tr><tr><td align="center">commitAllow</td><td align="center">true</td><td align="center">是否允许执行 commit 操作</td></tr><tr><td align="center">rollbackAllow</td><td align="center">true</td><td align="center">是否允许执行 roll back 操作</td></tr></tbody></table><h4 id="3-2-2、测试访问效果"><a href="#3-2-2、测试访问效果" class="headerlink" title="3.2.2、测试访问效果"></a>3.2.2、测试访问效果</h4><p>&emsp;&emsp;如下图，我们登陆之后，执行删除sql语句，发现被拦截。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210608144229772.png" alt="image-20210608144229772"></p><h1 id="八、MyCat-监控工具"><a href="#八、MyCat-监控工具" class="headerlink" title="八、MyCat 监控工具"></a>八、MyCat 监控工具</h1><p>&emsp;&emsp;Mycat-web 是 MyCat 可视化运维的管理和监控平台，弥补了 MyCat 在监控上的空白，帮助 MyCat 分担统计任务和配置管理任务。 Mycat-web 引入了 ZooKeeper 作为配置中心，可以管理多个节点。Mycat-web 主要管理和监控 MyCat 的流量、连接、活动线程和内存等，具备 IP 白名单、邮件告警等模块，还可以统计 SQL 并分析慢 SQL 和高频 SQL 等。为优化 SQL 提供依据。  </p><h2 id="1、安装-ZooKeeper"><a href="#1、安装-ZooKeeper" class="headerlink" title="1、安装 ZooKeeper"></a>1、安装 ZooKeeper</h2><p>&emsp;&emsp; ZooKeeper的安装参考【<a href="http://cheng_qiwei.gitee.io/blog/2021/03/15/Linux%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6/">链接</a>】</p><h2 id="2、Mycat-web安装操作"><a href="#2、Mycat-web安装操作" class="headerlink" title="2、Mycat-web安装操作"></a>2、Mycat-web安装操作</h2><h3 id="1-1、解压mycat-web文件夹到-usr-local目录下"><a href="#1-1、解压mycat-web文件夹到-usr-local目录下" class="headerlink" title="1.1、解压mycat-web文件夹到/usr/local目录下"></a>1.1、解压mycat-web文件夹到/usr/local目录下</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxf Mycat-web-1.0-SNAPSHOT-20160617163048-linux.tar.gz -C /usr/local</span><br></pre></td></tr></table></figure><h3 id="1-2、进入mycat-web的目录下运行启动命令"><a href="#1-2、进入mycat-web的目录下运行启动命令" class="headerlink" title="1.2、进入mycat-web的目录下运行启动命令"></a>1.2、进入mycat-web的目录下运行启动命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/mycat-web/ &amp;&amp; ./start.sh &amp;</span><br></pre></td></tr></table></figure><h3 id="1-3、开放端口8082"><a href="#1-3、开放端口8082" class="headerlink" title="1.3、开放端口8082"></a>1.3、开放端口8082</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=8082/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><h3 id="1-4、访问Mycat-web"><a href="#1-4、访问Mycat-web" class="headerlink" title="1.4、访问Mycat-web"></a>1.4、访问Mycat-web</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">通过地址访问服务</span><br><span class="line">http://192.168.66.131:8082/http://cheng_qiwei.gitee.io/blog/img/</span><br><span class="line">添加ZooKeeper之后即可观察到下图页面，可以进行其他相关操作，这里不再赘述</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210608155529942.png" alt="image-20210608155529942"></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安装 </tag>
            
            <tag> MyCat </tag>
            
            <tag> 操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL主从复制</title>
      <link href="/blog/2021/05/21/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
      <url>/blog/2021/05/21/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL主从复制"><a href="#MySQL主从复制" class="headerlink" title="MySQL主从复制"></a>MySQL主从复制</h1><h1 id="一、为什么要做主从复制？"><a href="#一、为什么要做主从复制？" class="headerlink" title="一、为什么要做主从复制？"></a>一、为什么要做主从复制？</h1><ol><li>读写分离。在业务复杂的系统中，有这么一个情景，有一句sql语句需要锁表，导致暂时不能使用读的服务，那么就很影响运行中的业务，使用主从复制，让主库负责写，从库负责读，这样，即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运作；</li><li>做数据的热备；</li><li>架构的扩展。业务量越来越大，I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问的频率，提高单个机器的I/O性能。</li></ol><h1 id="二、主从复制的原理"><a href="#二、主从复制的原理" class="headerlink" title="二、主从复制的原理"></a>二、主从复制的原理</h1><p>&emsp;&emsp;MySQL 默认采用异步复制方式，这样从节点不用一直访问主服务器来更新自己的数据，数据的更新可以在远程连接上进行，从节点可以复制主数据库中的所有数据库或者特定的数据库，或者特定的表。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210526152857598.png" alt="image-20210526152857598"></p><blockquote><p>具体复制步骤：</p><ol><li>在Slave服务器上执行start slave命令开启主从复制开关，开始进行主从复制；</li><li>Slave服务器的IO线程会通过在master上已经授权的复制用户权限请求连接Master服务器【username、password、ip、port】，并请求从执行bin log日志文件中的指定位置【file名称和position号】之后开始发送bin log日志内容；</li><li>从库的IO线程和主库的dump线程建立连接，其上负责复制的IO线程会根据Slave服务器的IO线程请求的信息分批读取指定bin log日志文件指定位置之后的bin log日志信息，然后返回给Slave端的IO线程。返回的信息中除了bin log日志内容外，还有在Master服务器端记录的IO线程；</li><li>当Slave服务器的IO线程获取到Master服务器上IO线程发送的日志内容、日志文件及位置点后，会将bin log日志内容依次写到Slave端自身的Relay Log（即中继日志）文件（Mysql-relay-bin.xxx）的最末端，并将新的bin log文件名和位置记录到master-info文件中，以便下一次读取master端新bin log日志时能告诉Master服务器从新bin log日志的指定文件及位置开始读取新的bin log日志内容；</li><li>Slave服务器端的SQL线程会实时检测本地Relay log 中IO线程新增的日志内容，然后及时把Relay log 文件中的内容解析成sql语句，并在自身Slave服务器上按解析SQL语句的位置顺序执行应用这样SQL语句，并在relay-log.info中记录当前应用中继日志的文件名和位置点。已经应用过的Relay log会被purge清理。</li></ol></blockquote><p>简单来讲：</p><blockquote><p>1、从库会生成两个线程。一个是I/O线程，一个是SQL线程；</p><p>2、I/O线程的作用是：请求主库的bin log日志，并将获得的bin log日志写入本地的relay-log（中继日志）文件中；</p><p>3、主库会生成一个log dump线程，用来给从库I/O线程传递bin log；</p><p>4、SQL线程则会读取保存的relay-log，并解析成SQL语句逐一执行（这个过程也称为重放）。</p></blockquote><h1 id="三、主从复制操作"><a href="#三、主从复制操作" class="headerlink" title="三、主从复制操作"></a>三、主从复制操作</h1><p>&emsp;&emsp;主从复制可以分为一主一从、一主多从、多主多从等。本节演示的是一主一从的操作。</p><h2 id="1、修改配置文件"><a href="#1、修改配置文件" class="headerlink" title="1、修改配置文件"></a>1、修改配置文件</h2><h3 id="1-1、保证两部机器能够ping通"><a href="#1-1、保证两部机器能够ping通" class="headerlink" title="1.1、保证两部机器能够ping通"></a>1.1、保证两部机器能够ping通</h3><p>&emsp;&emsp;本次使用两台虚拟机的数据库来进行操作。两台机器的配置如下：</p><table><thead><tr><th align="center">机器类型</th><th align="center">IP</th><th align="center">PORT</th></tr></thead><tbody><tr><td align="center">主机</td><td align="center">192.168.66.129</td><td align="center">3306</td></tr><tr><td align="center">从机</td><td align="center">192.168.66.130</td><td align="center">3306</td></tr></tbody></table><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210527000012385.png" alt="image-20210527000012385"></p><h3 id="1-2、修改配置文件"><a href="#1-2、修改配置文件" class="headerlink" title="1.2、修改配置文件"></a>1.2、修改配置文件</h3><h4 id="1-2-1、修改master配置文件vi-etc-my-cnf"><a href="#1-2-1、修改master配置文件vi-etc-my-cnf" class="headerlink" title="1.2.1、修改master配置文件vi /etc/my.cnf"></a>1.2.1、修改<code>master</code>配置文件<code>vi /etc/my.cnf</code></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">mysql服务唯一id，不同的mysql服务必须拥有全局唯一的id</span></span><br><span class="line">server-id=1</span><br><span class="line"><span class="meta">#</span><span class="bash">启动二进制日志</span></span><br><span class="line">log-bin=mysql-bin</span><br><span class="line"><span class="meta">#</span><span class="bash">设置不要复制的数据库</span></span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line">binlog-ignore-db=information-schema</span><br><span class="line"><span class="meta">#</span><span class="bash">设置需要复制的数据库</span></span><br><span class="line">binlog-do-db=mytest</span><br><span class="line"><span class="meta">#</span><span class="bash">设置binlog的格式row（在binlog里面记录在哪个行上做了修改，逻辑语法）、statement（保存操作时的语句）、mixed（两种方式混合使用）</span></span><br><span class="line">binlog_format=statement</span><br></pre></td></tr></table></figure><h4 id="1-2-2、修改slave配置文件vi-etc-my-cnf"><a href="#1-2-2、修改slave配置文件vi-etc-my-cnf" class="headerlink" title="1.2.2、修改slave配置文件vi /etc/my.cnf"></a>1.2.2、修改<code>slave</code>配置文件<code>vi /etc/my.cnf</code></h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#服务器唯一id</span></span><br><span class="line">server-id=2</span><br><span class="line"><span class="comment">#启动中继日志</span></span><br><span class="line">relay-log=mysql-relay</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;修改完成后，需要重启主机和从机的mysql</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysql restart</span><br></pre></td></tr></table></figure><h2 id="2、授权账户"><a href="#2、授权账户" class="headerlink" title="2、授权账户"></a>2、授权账户</h2><p>&emsp;&emsp;登录master的mysql服务，授权账户主从复制权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 授权主从复制权限</span><br><span class="line">grant replication slave on *.* to &#x27;root&#x27;@&#x27;%&#x27; identified by &#x27;Root_123&#x27;;</span><br><span class="line">-- 在进行授权的时候，如果提示密码的问题，把密码验证取消</span><br><span class="line">set global validate_password_policy=0;</span><br><span class="line">set global validate_password_length=1;</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210527001610045.png" alt="image-20210527001610045"></p><h2 id="3、查看主机状态"><a href="#3、查看主机状态" class="headerlink" title="3、查看主机状态"></a>3、查看主机状态</h2><p>&emsp;&emsp;使用<code>show master status</code>查询master状态</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210527002003154.png" alt="image-20210527002003154"></p><p>&emsp;&emsp;这里File和Position的值在下面的slave服务中会使用到；</p><p>&emsp;&emsp;我们可以通过<code>start master</code>、<code>stop master</code>、<code>reset master</code>等命令操作master，但是操作之后的master状态值可能发生变化。</p><h2 id="4、执行主从复制"><a href="#4、执行主从复制" class="headerlink" title="4、执行主从复制"></a>4、执行主从复制</h2><h3 id="4-1、slave执行主从复制命令"><a href="#4-1、slave执行主从复制命令" class="headerlink" title="4.1、slave执行主从复制命令"></a>4.1、slave执行主从复制命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CHANGE MASTER TO MASTER_HOST=&#x27;192.168.66.129&#x27;,MASTER_USER=&#x27;root&#x27;,MASTER_PASSWORD=&#x27;Root_123&#x27;,MASTER_LOG_FILE=&#x27;mysql-bin.000001&#x27;,MASTER_LOG_POS=429;</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210527002242562.png" alt="image-20210527002242562"></p><h3 id="4-2、查看从机状态"><a href="#4-2、查看从机状态" class="headerlink" title="4.2、查看从机状态"></a>4.2、查看从机状态</h3><p>&emsp;&emsp;使用命令查看从机状态，此时发现 I/O 线程和 SQL 线程都是停止的。此时需要启动它们。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">show slave status\G;</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动线程</span></span><br><span class="line">start slave;</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210527002326955.png" alt="image-20210527002326955"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210527002643485.png" alt="image-20210527002643485"></p><p>&emsp;&emsp;这里可能会出现异常，例如I/O线程为NO，这种情况有可能是以下几个：</p><blockquote><p>1、mysql5.6以上版本使用唯一uuid表示符，数据迁移是使用的物理备份，uuid会重复，修改uuid不一致即可。这个是最有可能的原因。拷贝虚拟机之后就会出现这种情况。</p><p>修改 /usr/local/mysql-5.7.28/data 路径下的 auto.cnf 文件即可。</p><p>2、确认server-id 是否唯一， mysql 有可能并没有加载my.cnf 文件中的server-id。</p><p>3、这种原因有可能是主库重启造成的二进制文件位置从库于主库不一致。</p><p>需要手动将这些文件二进制日志mysql-bin.00000x,mysql-bin.index删除，rm -rf 掉 在重启数据库。</p></blockquote><p>&emsp;&emsp;此时，主从复制基本部署完毕。关于slave，也可以通过<code>start slave</code>、<code>stop slave</code>、<code>reset slave</code>等命令操作slave。</p><h2 id="5、测试主从复制"><a href="#5、测试主从复制" class="headerlink" title="5、测试主从复制"></a>5、测试主从复制</h2><h3 id="5-1、测试建库"><a href="#5-1、测试建库" class="headerlink" title="5.1、测试建库"></a>5.1、测试建库</h3><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210527003940415.png" alt="image-20210527003940415"></p><h3 id="5-2、测试建表"><a href="#5-2、测试建表" class="headerlink" title="5.2、测试建表"></a>5.2、测试建表</h3><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210527004219989.png" alt="image-20210527004219989"></p><h3 id="5-3、测试插入数据"><a href="#5-3、测试插入数据" class="headerlink" title="5.3、测试插入数据"></a>5.3、测试插入数据</h3><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210527004353664.png" alt="image-20210527004353664"></p><h3 id="5-4、注意事项"><a href="#5-4、注意事项" class="headerlink" title="5.4、注意事项"></a>5.4、注意事项</h3><p>&emsp;&emsp;当master执行的语句被同步到slave时，如果slave存在对应的语句在约束上与master同步过来的语句冲突时，同步会失败，在<code>/var/log/mysqld.log</code>中可以看到错误。所以一般来说从库不允许写入，只能读取。</p><h1 id="四、双主双从复制的操作"><a href="#四、双主双从复制的操作" class="headerlink" title="四、双主双从复制的操作"></a>四、双主双从复制的操作</h1><h2 id="1、修改配置文件-1"><a href="#1、修改配置文件-1" class="headerlink" title="1、修改配置文件"></a>1、修改配置文件</h2><h3 id="1-1、保证四部机器能够ping通"><a href="#1-1、保证四部机器能够ping通" class="headerlink" title="1.1、保证四部机器能够ping通"></a>1.1、保证四部机器能够ping通</h3><p>&emsp;&emsp;本次使用四台虚拟机的数据库来进行操作。四台机器的配置如下：</p><table><thead><tr><th align="center">机器类型</th><th align="center">IP</th><th align="center">PORT</th></tr></thead><tbody><tr><td align="center">主机</td><td align="center">192.168.66.131</td><td align="center">3306</td></tr><tr><td align="center">主机从机</td><td align="center">192.168.66.132</td><td align="center">3306</td></tr><tr><td align="center">备机</td><td align="center">192.168.66.133</td><td align="center">3306</td></tr><tr><td align="center">备机从机</td><td align="center">192.168.66.134</td><td align="center">3306</td></tr></tbody></table><h3 id="1-2、停止原来的主从复制"><a href="#1-2、停止原来的主从复制" class="headerlink" title="1.2、停止原来的主从复制"></a>1.2、停止原来的主从复制</h3><p>&emsp;&emsp;在开始配置之前，我们先将之前配置的主从复制停掉并重置，如果没有，则跳过这一步。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">停止从服务器复制</span></span><br><span class="line">stop slave;</span><br><span class="line"><span class="meta">#</span><span class="bash">重置主服务器主机配置</span></span><br><span class="line">reset master;</span><br></pre></td></tr></table></figure><h3 id="1-3、修改配置文件"><a href="#1-3、修改配置文件" class="headerlink" title="1.3、修改配置文件"></a>1.3、修改配置文件</h3><p>修改每台仪器的<code>my.cnf</code>文件<code>[vim /etc/my.cnf]</code></p><h4 id="1-3-1、Master1-主机-配置"><a href="#1-3-1、Master1-主机-配置" class="headerlink" title="1.3.1、Master1[主机]配置"></a>1.3.1、Master1[主机]配置</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">mysql服务唯一id，不同的mysql服务必须拥有全局唯一的id</span></span><br><span class="line">server-id=1</span><br><span class="line"><span class="meta">#</span><span class="bash">启动二进制日志</span></span><br><span class="line">log-bin=mysql-bin</span><br><span class="line"><span class="meta">#</span><span class="bash">设置不要复制的数据库</span></span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line">binlog-ignore-db=information-schema</span><br><span class="line"><span class="meta">#</span><span class="bash">设置需要复制的数据库</span></span><br><span class="line">binlog-do-db=mytest</span><br><span class="line"><span class="meta">#</span><span class="bash">设置binlog的格式row（在binlog里面记录在哪个行上做了修改，逻辑语法）、statement（保存操作时的语句）、mixed（两种方式混合使用）</span></span><br><span class="line">binlog_format=statement</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在作为从数据库的时候， 有写入操作也要更新二进制日志文件</span></span><br><span class="line">log-slave-updates</span><br><span class="line"><span class="meta">#</span><span class="bash">表示自增长字段每次递增的量，指自增字段的起始值，其默认值是1， 取值范围是1 .. 65535</span></span><br><span class="line">auto-increment-increment=2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示自增长字段从哪个数开始，指字段一次递增多少，他的取值范围是1 .. 65535</span></span><br><span class="line">auto-increment-offset=1</span><br></pre></td></tr></table></figure><h4 id="1-3-2、Master2-备机-配置"><a href="#1-3-2、Master2-备机-配置" class="headerlink" title="1.3.2、Master2[备机]配置"></a>1.3.2、Master2[备机]配置</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">主服务器唯一ID</span></span><br><span class="line">server-id=3</span><br><span class="line"><span class="meta">#</span><span class="bash">启用二进制日志</span></span><br><span class="line">log-bin=mysql-bin</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置不要复制的数据库(可设置多个)</span></span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line">binlog-ignore-db=information_schema</span><br><span class="line"><span class="meta">#</span><span class="bash">设置需要复制的数据库</span></span><br><span class="line">binlog-do-db=mytest</span><br><span class="line"><span class="meta">#</span><span class="bash">设置logbin格式</span></span><br><span class="line">binlog_format=STATEMENT</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在作为从数据库的时候，有写入操作也要更新二进制日志文件</span></span><br><span class="line">log-slave-updates</span><br><span class="line"><span class="meta">#</span><span class="bash">表示自增长字段每次递增的量，指自增字段的起始值，其默认值是1，取值范围是1 .. 65535</span></span><br><span class="line">auto-increment-increment=2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示自增长字段从哪个数开始，指字段一次递增多少，他的取值范围是1 .. 65535</span></span><br><span class="line">auto-increment-offset=2</span><br></pre></td></tr></table></figure><h4 id="1-3-3、Slave1-主机从机-配置"><a href="#1-3-3、Slave1-主机从机-配置" class="headerlink" title="1.3.3、Slave1[主机从机]配置"></a>1.3.3、Slave1[主机从机]配置</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">从服务器唯一ID</span></span><br><span class="line">server-id=2</span><br><span class="line"><span class="meta">#</span><span class="bash">启用中继日志</span></span><br><span class="line">relay-log=mysql-relay</span><br></pre></td></tr></table></figure><h4 id="1-3-4、Slave2-备机从机-配置"><a href="#1-3-4、Slave2-备机从机-配置" class="headerlink" title="1.3.4、Slave2[备机从机]配置"></a>1.3.4、Slave2[备机从机]配置</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">从服务器唯一ID</span></span><br><span class="line">server-id=4</span><br><span class="line"><span class="meta">#</span><span class="bash">启用中继日志</span></span><br><span class="line">relay-log=mysql-relay</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;修改完成后，需要重启双主机和双从机的mysql</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysql restart</span><br></pre></td></tr></table></figure><h2 id="2、授权账户-1"><a href="#2、授权账户-1" class="headerlink" title="2、授权账户"></a>2、授权账户</h2><h3 id="2-1、获取主机信息"><a href="#2-1、获取主机信息" class="headerlink" title="2.1、获取主机信息"></a>2.1、获取主机信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 授权主从复制权限</span><br><span class="line">grant replication slave on *.* to &#x27;root&#x27;@&#x27;%&#x27; identified by &#x27;123456&#x27;;</span><br><span class="line">-- 在进行授权的时候，如果提示密码的问题，把密码验证取消</span><br><span class="line">set global validate_password_policy=0;</span><br><span class="line">set global validate_password_length=1;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查询Master1的状态</span></span><br><span class="line">show master status;</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210602233656164.png" alt="image-20210602233656164"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210602233721649.png" alt="image-20210602233721649"></p><h3 id="2-2、授权从机"><a href="#2-2、授权从机" class="headerlink" title="2.2、授权从机"></a>2.2、授权从机</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 主机授权主机从机</span></span><br><span class="line">CHANGE MASTER TO MASTER_HOST=&#x27;192.168.66.131&#x27;,MASTER_USER=&#x27;root&#x27;,MASTER_PASSWORD=&#x27;123456&#x27;,MASTER_LOG_FILE=&#x27;mysql-bin.000002&#x27;,MASTER_LOG_POS=610;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 备机授权备机从机</span></span><br><span class="line">CHANGE MASTER TO MASTER_HOST=&#x27;192.168.66.133&#x27;,MASTER_USER=&#x27;root&#x27;,MASTER_PASSWORD=&#x27;123456&#x27;,MASTER_LOG_FILE=&#x27;mysql-bin.000001&#x27;,MASTER_LOG_POS=442;</span><br></pre></td></tr></table></figure><p>查看状态并启动线程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">show slave status\G;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">启动线程</span></span><br><span class="line">start slave;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;保证Slave_IO_Running和Slave_SQL_Running是Yes即可，异常情况参考一主一从的处理。</p><h3 id="2-3、双主机相互授权"><a href="#2-3、双主机相互授权" class="headerlink" title="2.3、双主机相互授权"></a>2.3、双主机相互授权</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 主机授权备机</span></span><br><span class="line">CHANGE MASTER TO MASTER_HOST=&#x27;192.168.66.131&#x27;,MASTER_USER=&#x27;root&#x27;,MASTER_PASSWORD=&#x27;123456&#x27;,MASTER_LOG_FILE=&#x27;mysql-bin.000002&#x27;,MASTER_LOG_POS=610;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 备机授权主机</span></span><br><span class="line">CHANGE MASTER TO MASTER_HOST=&#x27;192.168.66.133&#x27;,MASTER_USER=&#x27;root&#x27;,MASTER_PASSWORD=&#x27;123456&#x27;,MASTER_LOG_FILE=&#x27;mysql-bin.000001&#x27;,MASTER_LOG_POS=442;</span><br></pre></td></tr></table></figure><p>查看状态并启动线程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">show slave status\G;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">启动线程</span></span><br><span class="line">start slave;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;保证Slave_IO_Running和Slave_SQL_Running是Yes即可，异常情况参考一主一从的处理。</p><h2 id="3、测试双主双从复制"><a href="#3、测试双主双从复制" class="headerlink" title="3、测试双主双从复制"></a>3、测试双主双从复制</h2><p>&emsp;&emsp;Master1 主机新建库、新建表、 insert 记录， Master2 和从机复制 。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210603001143525.png" alt="image-20210603001143525"></p><h1 id="五、MySQL主从复制的复制方式"><a href="#五、MySQL主从复制的复制方式" class="headerlink" title="五、MySQL主从复制的复制方式"></a>五、MySQL主从复制的复制方式</h1><p>&emsp;&emsp;MySQL的主从复制并不完美，多多少少存在一部分缺陷。MySQL的主从复制的复制方式有以下几种：</p><blockquote><ol><li>基于SQL语句的复制（SBR）；</li><li>基于行的复制（RBR）；</li><li>混合模式的复制（MBR）；</li><li>全局事务标识符GTID。</li></ol></blockquote><h2 id="1、基于SQL语句的复制-SBR"><a href="#1、基于SQL语句的复制-SBR" class="headerlink" title="1、基于SQL语句的复制 SBR"></a>1、基于SQL语句的复制 SBR</h2><p>&emsp;&emsp;基于SQL语句的方式是最古老的方式，也是目前默认的复制方式，后来的三种是MySQL 5以后才出现的复制方式。</p><h3 id="1-1、SBR方式的优点"><a href="#1-1、SBR方式的优点" class="headerlink" title="1.1、SBR方式的优点"></a>1.1、SBR方式的优点</h3><blockquote><ol><li>历史悠久，技术成熟；</li><li>bin log文件较小；</li><li>bin log文件包含所有数据的更改信息，可以审视数据库的安全情况；</li><li>bin log可以用于实时还原而不止复制；</li><li>主从数据库版本可以不一致，从库版本可以比主库高。</li></ol></blockquote><h3 id="1-2、SBR方式的缺点"><a href="#1-2、SBR方式的缺点" class="headerlink" title="1.2、SBR方式的缺点"></a>1.2、SBR方式的缺点</h3><blockquote><ol><li>不是所有UPDATE语句都能够被复制，尤其包含不确定操作的时候；</li><li>复制需要进行全表扫描的UPDATE时（没有索引），需要比 RBR 请求更多的行级锁；</li><li>对于一些复杂的语句，在从服务器上消耗资源的情况会更加严重，而在 RBR 中，只会对那个发生变化的记录产生影响；</li><li>数据表必须几乎和主服务器保持一致，否则会导致复制出错；</li><li>执行复杂语句如果出错时，会消耗更多资源。</li></ol></blockquote><h2 id="2、基于行的复制-RBR"><a href="#2、基于行的复制-RBR" class="headerlink" title="2、基于行的复制 RBR"></a>2、基于行的复制 RBR</h2><h3 id="2-1、RBR方式的优点"><a href="#2-1、RBR方式的优点" class="headerlink" title="2.1、RBR方式的优点"></a>2.1、RBR方式的优点</h3><blockquote><ol><li>任何情况下都能够被复制；</li><li>和其他大多数数据库系统的复制技术是一样的；</li><li>多数情况下，从库的表如果有主键的话，复制的效率会高很多。</li></ol></blockquote><h3 id="2-2、RBR方式的缺点"><a href="#2-2、RBR方式的缺点" class="headerlink" title="2.2、RBR方式的缺点"></a>2.2、RBR方式的缺点</h3><blockquote><ol><li>bin log文件相比较SBR来讲大了很多；</li><li>复杂的回滚时，bin log中会包含大量数据；</li><li>无法从bin log中看到都复制了写什么的语句；</li><li>主库上执行UPDATE语句时，所有的变化都会写到bin log上，而SBR只会写一次，从而导致频繁的bin log并发写问题。</li></ol></blockquote><h2 id="3、混合模式的复制-MBR"><a href="#3、混合模式的复制-MBR" class="headerlink" title="3、混合模式的复制 MBR"></a>3、混合模式的复制 MBR</h2><p>&emsp;&emsp;混合模式就是由MySQL自身选择RBR还是SBR，能够充分发挥两种方式的优点，一般情况下都是使用该方式实现主从复制。但是，该情况下不能操作系统变量。</p><h2 id="4、全局事务标识符-GTID"><a href="#4、全局事务标识符-GTID" class="headerlink" title="4、全局事务标识符 GTID"></a>4、全局事务标识符 GTID</h2><p>&emsp;&emsp;GTID，也叫全局事务ID，它保证为每一个在主上提交的事务在复制集群中可以生成一个唯一的ID。GITD由两部分组成的，分别是source_id 和transaction_id，GTID =source_id:transaction_id，其中source_id就是执行事务的主库的server-uuid值，server-uuid值是在mysql服务首次启动生成的，保存在数据库的数据目录中，在数据目录中有一个auto.conf文件，这个文件保存了server-uuid值（唯一的）。而事务ID则是从1开始自增的序列，表示这个事务是在主库上执行的第几个事务，Mysql会保证这个事务和GTID是一比一的关系。</p><p>&emsp;&emsp;基于GTID的复制是从Mysql5.6开始支持的一种新的复制方式，此方式与传统基于日志的方式存在很大的差异，在原来的基于日志的复制中，<strong>从服务器连接到主服务器并告诉主服务器要从哪个二进制日志的偏移量开始执行增量同步，这时我们如果指定的日志偏移量不对，这与可能造成主从数据的不一致</strong>，而基于GTID的复制会避免。</p><p>&emsp;&emsp;在基于GTID的复制中，首先从服务器会告诉主服务器已经在从服务器执行完了哪些事务的GTID值，然后<strong>主库会有把所有没有在从库上执行的事务，发送到从库上进行执行，并且使用GTID的复制可以保证同一个事务只在指定的从库上执行一次，这样可以避免由于偏移量的问题造成数据不一致</strong>。</p><h3 id="4-1、GTID方式的优点"><a href="#4-1、GTID方式的优点" class="headerlink" title="4.1、GTID方式的优点"></a>4.1、GTID方式的优点</h3><blockquote><ol><li>很方便的进行故障转移，因为GTID是全局唯一的标识符，所以就很简单知道哪些事务在从服务器没有执行，在多个从服务器也没必要进行多个日志偏移量配置了；</li><li>从库和主库的数据一致性。</li></ol></blockquote><h3 id="4-2、GTID方式的缺点"><a href="#4-2、GTID方式的缺点" class="headerlink" title="4.2、GTID方式的缺点"></a>4.2、GTID方式的缺点</h3><blockquote><ol><li>故障处理比日志处理复杂;</li><li>执行语句的一些限制。</li></ol></blockquote><h1 id="六、MySQL主从复制的延迟问题"><a href="#六、MySQL主从复制的延迟问题" class="headerlink" title="六、MySQL主从复制的延迟问题"></a>六、MySQL主从复制的延迟问题</h1><h2 id="1、为什么会出现延迟？"><a href="#1、为什么会出现延迟？" class="headerlink" title="1、为什么会出现延迟？"></a>1、为什么会出现延迟？</h2><p>&emsp;&emsp;既然是延迟，那么就说明是哪里执行慢了、跟不上了导致的延迟。所以我们就需要从主从复制的流程来进行分析：</p><blockquote><ul><li>mysql的主从复制都是单线程的操作，主库对所有DDL和DML产生的日志写进bin log，由于bin log是顺序写，所以效率很高；</li><li>master和slave之间的数据传输依靠了内部网络或专线，一般来说也是比较快的；</li><li>slave读取master的数据写入relay log是追加日志，属于顺序io效率并不低；</li><li>slave的sql thread线程将主库的DDL和DML操作事件在slave中重放。DML和DDL的IO操作是随机的，不是顺序，所以成本要高很多；</li><li>另一方面，由于sql thread也是单线程的，当主库的并发较高时，产生的DML数量超过slave的SQL thread所能处理的速度，或者当slave中有大型query语句产生了锁等待，那么延时就产生了。</li></ul></blockquote><p>&emsp;&emsp;从上面的分析来看，延迟主要体现在<code>sql thread</code>处理数据入库阶段。</p><h2 id="2、如何查看同步延迟状态？"><a href="#2、如何查看同步延迟状态？" class="headerlink" title="2、如何查看同步延迟状态？"></a>2、如何查看同步延迟状态？</h2><p>&emsp;&emsp;在从服务器上通过执行 show slave status 查看具体的参数，有几个参数比较重要：</p><blockquote><p><strong>master_log_file：slave中的IO线程正在读取的主服务器二进制日志文件的名称</strong></p><p> <strong>read_master_log_pos：在当前的主服务器二进制日志中，slave中的IO线程已经读取的位置</strong></p><p> <strong>relay_log_file：sql线程当前正在读取和执行的中继日志文件的名称</strong></p><p> <strong>relay_log_pos：在当前的中继日志中，sql线程已经读取和执行的位置</strong></p><p> <strong>relay_master_log_file：由sql线程执行的包含多数近期事件的主服务器二进制日志文件的名称</strong></p><p> <strong>slave_io_running：IO线程是否被启动并成功的连接到主服务器上</strong></p><p> <strong>slave_sql_running：sql线程是否被启动</strong></p><p> <strong>seconds_behind_master：从属服务器sql线程和从属服务器IO线程之间的事件差距，单位以秒计</strong></p></blockquote><p> &emsp;&emsp;在浙西参数中有一个最最重要的参数需要我们引起注意，那就是<code>seconds_behind_master</code>，这个参数就表示当前备库延迟了多长时间，那么这个值是如何计算的呢？</p><p> 在进行主从复制的时候，需要注意以下几个关键的时刻：</p><ul><li>主库A执行完成一个事务，写入binlog，我们把这个时刻记为T1；</li><li>主库A将binlog传给备库B,我们把备库B接受完这个binlog的时刻记为T2；</li><li>备库B执行完成这个事务，我们把这个时刻记为T3。</li></ul><p>&emsp;&emsp;所谓的主备延迟就是同一个事务，在备库执行完成的时间和主库执行完成的时间之间的差值，也就是T3-T1。SBM在进行计算的时候也是按照这样的方式，每个事务的binlog中都有一个时间字段，用于记录主库写入的时间，备库取出当前正在执行的事务的时间字段的值，计算它与当前系统时间的差值，得到SBM。</p><h2 id="3、主从复制产生延迟的原因"><a href="#3、主从复制产生延迟的原因" class="headerlink" title="3、主从复制产生延迟的原因"></a>3、主从复制产生延迟的原因</h2><p>&emsp;&emsp;根据上面我们的分析，我们可以来总结一下主从复制产生延迟的原因：</p><h3 id="3-1、服务器性能"><a href="#3-1、服务器性能" class="headerlink" title="3.1、服务器性能"></a>3.1、服务器性能</h3><p>&emsp;&emsp;在某些环境中，slave 所在的服务器性能会比 master 对应服务器的性能差。此时如果 slave 的资源不足就会影响其同步效率。</p><h3 id="3-2、查询压力过大"><a href="#3-2、查询压力过大" class="headerlink" title="3.2、查询压力过大"></a>3.2、查询压力过大</h3><p>&emsp;&emsp;slave 作为读库，会提供一部分读的压力。而当 slave 的查询压力过大时，会消耗大量CPU资源，这就会影响同步的速度了。</p><h3 id="3-3、大事务的执行"><a href="#3-3、大事务的执行" class="headerlink" title="3.3、大事务的执行"></a>3.3、大事务的执行</h3><p>&emsp;&emsp;当执行一个大事务时，如果在 master 上面执行花费了 10 分钟，而bin log需要等待事务完成后，才会传入 slave，此时 slave 开始执行时就已经延迟了 10 分钟。</p><h3 id="3-4、随机io"><a href="#3-4、随机io" class="headerlink" title="3.4、随机io"></a>3.4、随机io</h3><p>&emsp;&emsp;master的对于bin log的写操作是追加日志，属于顺序写，slave单线程去master顺序读bin log，slave取到bin log之后在本地执行。mysql的主从复制都是<strong>单线程</strong>的操作，但是由于master是顺序写，所以效率很高，而slave也是顺序读取master的日志，此时的效率也是比较高的，但是当数据拉取回来之后，sql thread处理数据变成了随机的操作，而不是顺序的，所以此时成本会提高。</p><h3 id="3-5、线程抢占"><a href="#3-5、线程抢占" class="headerlink" title="3.5、线程抢占"></a>3.5、线程抢占</h3><p>&emsp;&emsp;slave 在同步数据的同时，可能和其他查询的线程发生锁抢占的情况，此时也会发生延迟。</p><h3 id="3-6、其他情况"><a href="#3-6、其他情况" class="headerlink" title="3.6、其他情况"></a>3.6、其他情况</h3><p>&emsp;&emsp;当master的TPS并发非常高的时候，产生的DDL数量超过了一个线程所能承受的范围的时候，那么也可能带来延迟。</p><p>&emsp;&emsp;在进行bin log日志传输的时候，如果网络带宽也不是很好，那么网络延迟也可能造成数据同步延迟。</p><h1 id="七、如何解决复制延迟"><a href="#七、如何解决复制延迟" class="headerlink" title="七、如何解决复制延迟"></a>七、如何解决复制延迟</h1><h2 id="1、硬件方面的优化"><a href="#1、硬件方面的优化" class="headerlink" title="1、硬件方面的优化"></a>1、硬件方面的优化</h2><p>&emsp;&emsp;采用更好的服务器（CPU、SSD等），硬件强劲、延迟肯定会变小。但是，需要花费的金钱也会随之提升。</p><h2 id="2、架构方面的优化"><a href="#2、架构方面的优化" class="headerlink" title="2、架构方面的优化"></a>2、架构方面的优化</h2><blockquote><ol><li>业务的持久化层的实现采用分库架构，mysql服务可平行扩展，分散压力；</li><li>单个库达到某个数据量时执行读写分离，一主多从，主写从读，分散压力。这样从库压力比主库高，保护主库；</li><li>服务的基础架构在业务和mysql之间加入缓存层，可以减少mysql的读的压力。但是需要注意的是，如果数据经常要发生修改，那么这种设计是不合理的，因为需要频繁的去更新缓存中的数据，保持数据的一致性，导致缓存的命中率很低，所以此时就要慎用缓存了；</li><li>使用比主库更好的硬件设备作为 slave 从库，从库压力小，延迟自然会变小。</li></ol></blockquote><h2 id="3、从库配置的优化"><a href="#3、从库配置的优化" class="headerlink" title="3、从库配置的优化"></a>3、从库配置的优化</h2><h3 id="3-1、修改sync-binlog的参数的值"><a href="#3-1、修改sync-binlog的参数的值" class="headerlink" title="3.1、修改sync_binlog的参数的值"></a>3.1、修改sync_binlog的参数的值</h3><p>&emsp;&emsp;我们先了解一下binlog的写盘的流程：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210531160301862.png" alt="image-20210531160301862"></p><p>&emsp;&emsp;从图中可以看到，每个线程有自己的bin log cache，但是共用同一份bin log。</p><blockquote><p>图中的write，指的就是把日志写入到文件系统的page cache，并没有把数据持久化到磁盘，所以速度快；</p><p>图中的fsync，才是将数据持久化到磁盘的操作。一般情况下，我们认为fsync才占用磁盘的IOPS。 </p></blockquote><p>&emsp;&emsp;而write和fsync的时机就是由参数sync_binlog来进行控制的。</p><blockquote><p> 1、当sync_binlog=0的时候，表示每次提交事务都只write，不fsync</p><p> 2、当sync_binlog=1的时候，表示每次提交事务都执行fsync</p><p> 3、当sync_binlog=N的时候，表示每次提交事务都write，但积累N个事务后才fsync。</p></blockquote><p>&emsp;&emsp;一般在公司的大部分应用场景中，我们建议将此参数的值设置为1，因为这样的话能够保证数据的安全性。但是如果出现主从复制的延迟问题，可以考虑将此值设置为100~1000中的某个数值，非常不建议设置为0，因为设置为0的时候没有办法控制丢失日志的数据量，但是如果是对安全性要求比较高的业务系统，这个参数产生的意义就不是那么大了。</p><h3 id="3-2、禁用-slave-的bin-log"><a href="#3-2、禁用-slave-的bin-log" class="headerlink" title="3.2、禁用 slave 的bin log"></a>3.2、禁用 slave 的bin log</h3><p>&emsp;&emsp;当从库的数据在做同步的时候，有可能从库的bin log也会进行记录，此时的话肯定也会消耗io的资源，因此可以考虑将其关闭。但是需要注意，如果你搭建的集群是级联的模式的话，那么此时的bin log也会发送到另外一台从库里方便进行数据同步，此时的话，这个配置项也不会起到太大的作用。</p><h3 id="3-3、设置innodb-flush-log-at-trx-commit-属性"><a href="#3-3、设置innodb-flush-log-at-trx-commit-属性" class="headerlink" title="3.3、设置innodb_flush_log_at_trx_commit 属性"></a>3.3、设置innodb_flush_log_at_trx_commit 属性</h3><p>&emsp;&emsp;这个属性用来表示每一次的事务提交是否需要把日志都写入磁盘，这是很浪费时间的，一共有三个属性值，分别是0（每次写到服务缓存，一秒钟刷写一次），1（每次事务提交都刷写一次磁盘），2（每次写到os缓存，一秒钟刷写一次），一般情况下我们推荐设置成2，这样就算mysql的服务宕机了，卸载os缓存中的数据也会进行持久化。</p><h1 id="八、MTS解决主从复制的延迟问题"><a href="#八、MTS解决主从复制的延迟问题" class="headerlink" title="八、MTS解决主从复制的延迟问题"></a>八、MTS解决主从复制的延迟问题</h1><p>&emsp;&emsp;在mysql5.6版本之后引入了一个概念，就是我们通常说的<code>MTS</code> 【Multi Thread Slave】（并行复制），如下图：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/%E5%B9%B6%E8%A1%8C%E5%A4%8D%E5%88%B6.png"></p><p>&emsp;&emsp;通过上图我们可以发现其实所谓的<code>MTS-并行复制</code>，就是在中间添加了一个分发的环节，也就是说原来的<code>sql thread</code>变成了现在的coordinator组件，当日志来了之后，coordinator负责读取日志信息以及分发事务，真正的日志执行的过程是放在了worker线程上，由多个线程并行的去执行。</p><h2 id="1、MTS配置"><a href="#1、MTS配置" class="headerlink" title="1、MTS配置"></a>1、MTS配置</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-- 查看并行的slave的线程的个数，默认是0-表示单线程</span><br><span class="line">show global variables like &#x27;slave_parallel_workers&#x27;;</span><br><span class="line">-- 根据实际情况保证开启多少线程</span><br><span class="line">set global slave_parallel_workers = 4;</span><br><span class="line">-- 设置并发复制的方式，默认是一个线程处理一个库，值为database</span><br><span class="line">show global variables like &#x27;%slave_parallel_type%&#x27;;</span><br><span class="line">-- 停止slave</span><br><span class="line">stop slave;</span><br><span class="line">-- 设置属性值</span><br><span class="line">set global slave_parallel_type=&#x27;logical_check&#x27;;</span><br><span class="line">-- 开启slave</span><br><span class="line">start slave</span><br><span class="line">-- 查看线程数</span><br><span class="line">show full processlist;</span><br></pre></td></tr></table></figure><h2 id="2、关于并行复制的思考"><a href="#2、关于并行复制的思考" class="headerlink" title="2、关于并行复制的思考"></a>2、关于并行复制的思考</h2><p><strong>2.1、在并行操作的时候，可能会有并发的事务问题，slave在执行的时候可以按照轮询的方式发送给各个worker吗？</strong></p><p>&emsp;&emsp;不行。因为事务被分发给worker以后，不同的worker就开始独立执行了，但是，由于CPU的不同调度策略，很可能第二个事务最终比第一个事务先执行，而如果刚刚好他们修改的是同一行数据，那么因为执行顺序的问题，可能导致主备的数据不一致。</p><p><strong>2.2、同一个事物的多个更新语句，能不能分给不同的worker来执行？</strong></p><p>&emsp;&emsp;不行。一个事务更新了表t1和表t2中的各一行，如果这两条更新语句被分到不同worker的话，虽然最终的结果是主备一致的，但如果表t1执行完成的瞬间，备库上有一个查询，就会看到这个事务更新了一半的结果，破坏了事务逻辑的隔离性。</p><p>&emsp;&emsp;根据上面两个问题，我们可以总结coordinator在进行分发的时候，需要遵循的策略：</p><blockquote><p>1、不能造成更新覆盖。这就要求更新同一行的两个事务，必须被分发到同一个worker中。</p><p>2、同一个事务不能被拆开，必须放到同一个worker中。</p></blockquote><h2 id="3、MTS的实现原理"><a href="#3、MTS的实现原理" class="headerlink" title="3、MTS的实现原理"></a>3、MTS的实现原理</h2><p>&emsp;&emsp;正由于在分发的时候必须要满足我们上面说的两条规则，所以当我们进行分发的时候要在每一个worker上定义一个hash表，用来保存当前这个work正在执行的事务所涉及到的表。hash表的key值按照不同的粒度需要存储不同的值：</p><p> 按库分发：key值是数据库的名字，这个比较简单</p><p> 按表分发：key值是库名+表名</p><p> 按行分发：key值是库名+表名+唯一键</p><p>&emsp;&emsp;接下来，我们来看看各个版本的MYS是如何实现的。</p><h3 id="3-1、MySQL-5-6-版本的并行复制策略"><a href="#3-1、MySQL-5-6-版本的并行复制策略" class="headerlink" title="3.1、MySQL 5.6 版本的并行复制策略"></a>3.1、MySQL 5.6 版本的并行复制策略</h3><p>&emsp;&emsp;MySQL在5.6版本开始就已经支持了并行复制，只是支持的粒度是按库并行。这也是为什么现在的版本中可以选择类型为database。</p><p>&emsp;&emsp;而这个策略的并行效果，取决于压力模型。如果在主库上有多个DB，并且各个DB的压力均衡，使用这个策略的效果会很好，但是如果主库的所有表都放在同一DB上，那么所有的操作都会分发给一个worker，变成单线程操作了，那么这个策略的效果就不好了，因此在实际的生产环境中，用的并不是特别多。</p><h3 id="3-2、MariaDB的并行复制策略"><a href="#3-2、MariaDB的并行复制策略" class="headerlink" title="3.2、MariaDB的并行复制策略"></a>3.2、MariaDB的并行复制策略</h3><p>&emsp;&emsp;MariaDB的并行复制策略是：</p><blockquote><p> 1、能够在同一组里提交的事务，一定不会修改同一行；</p><p> 2、master上可以并行执行的事务，slave上也一定是可以并行执行的。</p></blockquote><p> &emsp;&emsp;在实现上，mariaDB是这么做的：</p><blockquote><p>1、在一组里面一起提交的事务，有一个相同的commit_id,下一组就是commit_id+1;</p><p> 2、commit_id直接写到binlog里面；</p><p> 3、传到slave应用的时候，相同commit_id的事务会分发到多个worker执行；</p><p> 4、这一组全部执行完成后，coordinator再去取下一批。</p></blockquote><p>&emsp;&emsp;这是mariaDB的并行复制策略，大体上看起来是没有问题的，但是你仔细观察的话会发现他并没有实现“真正的模拟主库并发度”这个目标，在主库上，一组事务在commit的时候，下一组事务是同时处于“执行中”状态的。</p><p>&emsp;&emsp;我们真正想要达到的并行复制应该是如下图1的状态，也就是说当第一组事务提交的是，下一组事务是运行的状态，当第一组事务提交完成之后，下一组事务会立刻变成commit状态。 但是按照mariaDB的并行复制策略，那么备库上的执行状态会变成如下图2。</p><p>&emsp;&emsp;可以看到，图2跟上面图1的最大区别在于，slave上执行的时候必须要等第一组事务执行完成之后，第二组事务才能开始执行，这样系统的吞吐量就不够了。而且这个方案很容易被大事务拖后腿，如果trx2是一个大事务，那么在备库应用的时候，trx1和trx3执行完成之后，就只能等trx2完全执行完成，下一组才能开始执行，这段时间，只有一个worker线程在工作，是对资源的浪费。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/mariaDB1.png" alt="mariaDB1"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/mariaDB2.png" alt="mariaDB2"></p><h3 id="3-3、MySQL-5-7-的并行复制策略"><a href="#3-3、MySQL-5-7-的并行复制策略" class="headerlink" title="3.3、MySQL 5.7 的并行复制策略"></a>3.3、MySQL 5.7 的并行复制策略</h3><p>&emsp;&emsp;在MySQL5.7版本，它的并行复制策略是根据mariaDB的并行复制策略，做了相应的优化调整后，提供了自己的并行复制策略，并且可以通过参数slave-parallel-type来控制并行复制的策略：</p><blockquote><p>1、当配置的值为DATABASE的时候，表示使用5.6版本的按库并行策略；</p><p> 2、当配置的值为LOGICAL_CLOCK的时候，表示使用跟MariaDB相同的策略。</p></blockquote><p>此时，大家需要思考一个问题：<strong>同时处于执行状态的所有事务，是否可以并行？</strong></p><p>答案：不行，因为多个执行中的事务是有可能出现锁冲突的，锁冲突之后就会产生锁等待问题。在mariaDB中，所有处于commit状态的事务是可以并行，因为如果能commit的话就说明已经没有锁的问题，但是大家回想下，我们mysql的日志提交是两阶段提交，如下图，其实只要处于prepare状态就已经表示没有锁的问题了。</p><p>&emsp;&emsp;在MySQL5.7的时候采用的是基于组提交的并行复制，换句话说，slave服务器的回放与主机是一致的，即主库是如何并行执行的那么slave就如何怎样进行并行回放，这点其实是参考了mariaDB的并行复制。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4.png"></p><p>总结：MySQL5.7的并行复制策略的思想是：</p><p>1、同时处于prepare状态的事务，在slave执行是可以并行的；</p><p>2、处于prepare状态的事务，与处于commit状态的事务之间，在slave上执行也是可以并行的。</p><p>基于这样的处理机制，我们可以将大部分的日志处于prepare状态，因此可以设置：</p><p>1、binlog_group_commit_sync_delay 参数，表示延迟多少微秒后才调用 fsync；</p><p>2、binlog_group_commit_sync_no_delay_count 参数，表示累积多少次以后才调用 fsync。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 主从复制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL锁与日志</title>
      <link href="/blog/2021/05/15/MySQL%E9%94%81%E4%B8%8E%E6%97%A5%E5%BF%97/"/>
      <url>/blog/2021/05/15/MySQL%E9%94%81%E4%B8%8E%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL锁与日志"><a href="#MySQL锁与日志" class="headerlink" title="MySQL锁与日志"></a>MySQL锁与日志</h1><h1 id="一、MySQL锁机制"><a href="#一、MySQL锁机制" class="headerlink" title="一、MySQL锁机制"></a>一、MySQL锁机制</h1><h2 id="1、锁的定义"><a href="#1、锁的定义" class="headerlink" title="1、锁的定义"></a>1、锁的定义</h2><p>&emsp;&emsp;<font color='red'><strong>锁是协调多个进程或线程并发访问某一资源的一种机制</strong></font>。在数据库当中，除了传统的计算资源（CPU、RAM、I/O等等）的争用之外，<strong>数据也是一种供许多用户共享访问的资源</strong>，如何保证数据并发访问的一致性、有效性，是所有数据库必须解决的一个问题，锁的冲突也是影响数据和库并发访问性能的一个重要因素。  </p><h2 id="2、锁的分类"><a href="#2、锁的分类" class="headerlink" title="2、锁的分类"></a>2、锁的分类</h2><h3 id="2-1、按操作来分"><a href="#2-1、按操作来分" class="headerlink" title="2.1、按操作来分"></a>2.1、按操作来分</h3><ul><li>读锁(共享锁)：针对同一份数据,多个读取操作可以同时进行而不互相影响；</li><li>写锁(排它锁)：当前写操作没有完成前,会阻断其他写锁和读锁。</li></ul><h3 id="2-2、按粒度来分"><a href="#2-2、按粒度来分" class="headerlink" title="2.2、按粒度来分"></a>2.2、按粒度来分</h3><ul><li>表锁</li><li>行锁</li><li>页锁  </li></ul><h2 id="3、表锁"><a href="#3、表锁" class="headerlink" title="3、表锁"></a>3、表锁</h2><p>&emsp;&emsp;表锁更偏向MyISAM存储引擎，开销小，加锁快，无死锁，锁定粒度大，发生锁冲突的概率最高，并发最低。</p><h3 id="3-1、表锁测试"><a href="#3-1、表锁测试" class="headerlink" title="3.1、表锁测试"></a>3.1、表锁测试</h3><h4 id="3-1-1、创建两张表"><a href="#3-1-1、创建两张表" class="headerlink" title="3.1.1、创建两张表"></a>3.1.1、创建两张表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`person`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"><span class="string">`name`</span> <span class="built_in">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=MYISAM <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`person`</span>(<span class="keyword">NAME</span>) <span class="keyword">VALUES</span>(<span class="string">&#x27;孙悟空&#x27;</span>),(<span class="string">&#x27;猪八戒&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="3-1-2、查看表的锁定状态，发现都没有被锁"><a href="#3-1-2、查看表的锁定状态，发现都没有被锁" class="headerlink" title="3.1.2、查看表的锁定状态，发现都没有被锁"></a>3.1.2、查看表的锁定状态，发现都没有被锁</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">open</span> <span class="keyword">tables</span>;</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210520172504133.png" alt="image-20210520172504133"></p><h4 id="3-1-3、对表加锁"><a href="#3-1-3、对表加锁" class="headerlink" title="3.1.3、对表加锁"></a>3.1.3、对表加锁</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lock</span> <span class="keyword">table</span> person <span class="keyword">read</span>, person write;</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210520172751720.png" alt="image-20210520172751720"></p><h4 id="3-1-4、对表解锁"><a href="#3-1-4、对表解锁" class="headerlink" title="3.1.4、对表解锁"></a>3.1.4、对表解锁</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unlock</span> <span class="keyword">tables</span>;</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210520172917273.png" alt="image-20210520172917273"></p><h3 id="3-2、表锁中的读锁对MySQL性能的影响"><a href="#3-2、表锁中的读锁对MySQL性能的影响" class="headerlink" title="3.2、表锁中的读锁对MySQL性能的影响"></a>3.2、表锁中的读锁对MySQL性能的影响</h3><p>&emsp;&emsp;我们打开两个窗口，使用两个窗口来演示。首先，我们先在窗口1对person表进行读锁（共享锁）锁定，然后对其进行操作，结果如下：</p><table><thead><tr><th align="center">操作</th><th>窗口1</th><th>窗口2</th></tr></thead><tbody><tr><td align="center">初始化操作</td><td>连接数据源，对person表使用读锁锁定</td><td>连接数据源</td></tr><tr><td align="center">是否能够查询person表</td><td>可以</td><td>可以</td></tr><tr><td align="center">是否能够查询其他表</td><td>不可以，因为当前person表还未解锁，不能操作其他</td><td>可以</td></tr><tr><td align="center">修改person表</td><td>不可以，因为是操作了读锁，所以不能进行写操作</td><td>更新时会进入阻塞状态，要等待读锁解锁之后才能执行更新（锁等待）</td></tr></tbody></table><p><strong>初始化操作：</strong></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210520222221668.png" alt="image-20210520222221668"></p><p><strong>查询person表：</strong></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210520222338982.png" alt="image-20210520222338982"></p><p><strong>查询其他表：</strong></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210520222659149.png" alt="image-20210520222659149"></p><p><strong>修改person表：</strong></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210520223414925.png" alt="image-20210520223414925"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210520223641590.png" alt="image-20210520223641590"></p><h3 id="3-3、表锁中的写锁对MySQL性能的影响"><a href="#3-3、表锁中的写锁对MySQL性能的影响" class="headerlink" title="3.3、表锁中的写锁对MySQL性能的影响"></a>3.3、表锁中的写锁对MySQL性能的影响</h3><p>&emsp;&emsp;我们打开两个窗口，使用两个窗口来演示。首先，我们先在窗口1对person表进行写锁（独占锁、排它锁）锁定，然后对其进行操作，结果如下：</p><table><thead><tr><th>操作</th><th>窗口1</th><th>窗口2</th></tr></thead><tbody><tr><td>初始化操作</td><td>连接数据源，对person表使用写锁锁定</td><td>连接数据源</td></tr><tr><td>是否能够查询其它表</td><td>不可以，因为当前person表还未解锁，不能操作其他</td><td>可以</td></tr><tr><td>是否能够查询person表</td><td>可以</td><td>查询时会进入阻塞状态，要等待读锁解锁之后才能执行查询获取结果（锁等待）</td></tr><tr><td>修改person表</td><td>可以</td><td>更新时会进入阻塞状态，要等待读锁解锁之后才能执行更新（锁等待）</td></tr></tbody></table><p><strong>初始化操作：</strong></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210520223956256.png" alt="image-20210520223956256"></p><p><strong>查询其它表：</strong></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210520224254399.png" alt="image-20210520224254399"></p><p><strong>查询person表：</strong></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210520224405445.png" alt="image-20210520224405445"></p><p><strong>修改person表：</strong></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210520224503307.png" alt="image-20210520224503307"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210520224541999.png" alt="image-20210520224541999"></p><h3 id="3-4、表锁总结"><a href="#3-4、表锁总结" class="headerlink" title="3.4、表锁总结"></a>3.4、表锁总结</h3><p>&emsp;&emsp;在日常操作中，我们可以通过命令<code>show status like &#39;table%&#39;</code>来对表锁进行分析。这其中，我们需要关注两个参数，其一是<code>Table_locks_immediate </code>，它表示产生表级锁定的次数，另一个 <code>Table_locks_waited  </code> 则表示的是出现表级锁定争用而发生等待的次数 。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210520225158923.png" alt="image-20210520225158923"></p><p>&emsp;&emsp;MyISAM在执行查询时，会自动给涉及的所有表加上读锁，在执行增删改操作时，会自动给涉及的表添加写锁。综合上面的测试，我们知道，读锁会阻塞写，但不会阻塞读，而写锁会把读写都阻塞。正是由于这种特性，所以MyISAM不适合作为写为主表的引擎，因为频繁更新会使查询很难获得锁，从而造成永久阻塞。</p><h2 id="4、行锁与事务"><a href="#4、行锁与事务" class="headerlink" title="4、行锁与事务"></a>4、行锁与事务</h2><p> &emsp;&emsp;InnoDB与MyISAM的最大的不同有两点：<strong>一是支持事务（TRANSACTION）；二是采用了行级锁。</strong>行锁更偏向InnoDB<strong>存储引擎</strong>,<strong>开销大</strong>, <strong>加锁慢</strong>, <strong>会出现死锁</strong>；<strong>锁定粒度最小</strong>, <strong>发生锁冲突的概率最低</strong>,<strong>并发度也最高</strong>。但是行锁的使用条件是：<strong>只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁</strong>！<br>&emsp;&emsp;所以在实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。</p><h3 id="4-1、事务"><a href="#4-1、事务" class="headerlink" title="4.1、事务"></a>4.1、事务</h3><h4 id="4-1-1、事务（Transaction）及其ACID属性"><a href="#4-1-1、事务（Transaction）及其ACID属性" class="headerlink" title="4.1.1、事务（Transaction）及其ACID属性"></a>4.1.1、事务（Transaction）及其ACID属性</h4><p>&emsp;&emsp;事务是<strong>由一组SQL语句组成的逻辑处理单元</strong>，事务具有四个属性，通常称为事务的ACID属性。</p><ul><li><strong>原子性</strong>（Actomicity）：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。</li><li><strong>一致性</strong>（Consistent）：在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以操持完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。</li><li><strong>隔离性</strong>（Isolation）：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。</li><li><strong>持久性</strong>（Durable）：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。</li></ul><h4 id="4-1-2、事务的隔离级别"><a href="#4-1-2、事务的隔离级别" class="headerlink" title="4.1.2、事务的隔离级别"></a>4.1.2、事务的隔离级别</h4><p>&emsp;&emsp;并发事务处理会带来一系列问题，所以事物与事物之间需要进行适当的隔离，但是隔离是存在级别的，并不是隔离的越高级越好，**隔离越高级，性能越差 **。 </p><table><thead><tr><th>级别</th><th>名字</th><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th><th>实现方式</th><th>数据库默认隔离级别</th></tr></thead><tbody><tr><td>1</td><td>读未提交</td><td>read uncommitted</td><td>是</td><td>是</td><td>是</td><td>每次都是读取最新的数据</td><td></td></tr><tr><td>2</td><td>读已提交</td><td>read committed</td><td>否</td><td>是</td><td>是</td><td>每次读取之前创建的read view，通过MVCC控制</td><td>Oracle和SQL Server</td></tr><tr><td>3</td><td>可重复读</td><td>repeatable read</td><td>否</td><td>否</td><td>是</td><td>每次读取之前创建的read view，通过MVCC控制</td><td>MySQL默认</td></tr><tr><td>4</td><td>串行化</td><td>serializable</td><td>否</td><td>否</td><td>否</td><td>加锁</td><td></td></tr></tbody></table><p><strong>不同隔离级别所解决的问题：</strong></p><p>读已提交：解决脏读（一个事物读到了其他事物未提交的数据）<br>可重复读：解决不可重复读（一个事物多次读取到别人已提交的数据）<br>串行化：解决幻读（一个事物的修改操作，发现新增加了修改的数据）  </p><h3 id="4-2、事物的操作"><a href="#4-2、事物的操作" class="headerlink" title="4.2、事物的操作"></a>4.2、事物的操作</h3><p>&emsp;&emsp;MySQL有两种事务提交方式：</p><blockquote><p>自动提交事务</p><p>手动提交事务</p></blockquote><p>&emsp;&emsp;手动提交事务的sql语句：</p><table><thead><tr><th>功能</th><th>SQL语句</th></tr></thead><tbody><tr><td>开启事务</td><td>start transaction</td></tr><tr><td>提交事务</td><td>commit</td></tr><tr><td>回滚事务</td><td>rollback</td></tr></tbody></table><p>&emsp;&emsp;这里使用<code>start transaction</code>是临时开启事物，执行提交或回滚事物时就结束，如果需要永久开启事物手动提交，则：</p><table><thead><tr><th>功能</th><th>SQL语句</th></tr></thead><tbody><tr><td>查看MySQL是否开启自动提交事务</td><td>select @@autocommit;</td></tr><tr><td>取消事物自动提交</td><td>SET autocommit = 0;</td></tr><tr><td>开启事物自动提交</td><td>ET autocommit = 1;</td></tr></tbody></table><h3 id="4-3、行锁的演示"><a href="#4-3、行锁的演示" class="headerlink" title="4.3、行锁的演示"></a>4.3、行锁的演示</h3><p>&emsp;&emsp;我们打开两个窗口，使用两个窗口来演示。</p><table><thead><tr><th align="center">操作</th><th>窗口1</th><th>窗口2</th></tr></thead><tbody><tr><td align="center">初始化操作</td><td>连接数据源，关闭自动提交</td><td>连接数据源，关闭自动提交</td></tr><tr><td align="center">修改account表同一行</td><td>修改表，但不执行提交操作</td><td>不能更新，会被阻塞，需要等待窗口1执行提交操作</td></tr><tr><td align="center"></td><td>执行提交</td><td>更新操作结果</td></tr><tr><td align="center">修改account表不同行</td><td>可以修改，但需要执行提交才能在其他窗口看到结果</td><td>可以修改，但需要执行提交才能在其他窗口看到结果</td></tr></tbody></table><p><strong>初始化操作：</strong></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210522171226894.png" alt="image-20210522171226894"></p><p><strong>测试修改同一行数据：</strong></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210522171437873.png" alt="image-20210522171437873"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210522171531495.png" alt="image-20210522171531495"></p><p><strong>测试修改不同行数据：</strong></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210522171751003.png" alt="image-20210522171751003"></p><h3 id="4-4、无索引导致的行锁升级为表锁"><a href="#4-4、无索引导致的行锁升级为表锁" class="headerlink" title="4.4、无索引导致的行锁升级为表锁"></a>4.4、无索引导致的行锁升级为表锁</h3><p>&emsp;&emsp;刚刚测试的修改，我们使用了id作为条件，由于id在表创建时就被指定为主键索引，所以可以使用行锁，但是name这个字段就没有为其创建索引，所以我们在此测试一下修改name条件的效果：此时执行进入阻塞状态，锁由行锁升级为表锁。所以无索引或锁失效都会导致行锁升级为表锁。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210522172424023.png" alt="image-20210522172424023"></p><h3 id="4-5、间隙锁"><a href="#4-5、间隙锁" class="headerlink" title="4.5、间隙锁"></a><font color='red'>4.5、间隙锁</font></h3><h4 id="4-5-1、什么是间隙锁"><a href="#4-5-1、什么是间隙锁" class="headerlink" title="4.5.1、什么是间隙锁"></a>4.5.1、什么是间隙锁</h4><p>&emsp;&emsp;当我们用范围条件而不是相等条件检索数据时，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁，对于键值在条件范围内但并不存在的记录，称为 “ 间隙 ”，而InnoDB在范围查询的时候，会对这样的“ 间隙 ”加锁，这种锁机制就是间隙锁。</p><h4 id="4-5-2、间隙锁的演示"><a href="#4-5-2、间隙锁的演示" class="headerlink" title="4.5.2、间隙锁的演示"></a>4.5.2、间隙锁的演示</h4><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210522214950395.png" alt="image-20210522214950395"></p><p>&emsp;&emsp;如图所示：id = 3 的数据暂时不存在，我们先用窗口1执行修改语句，修改id 有2到4的金额为1000。那么此时，我们往该表中插入id = 3的数据，我们会发现，执行阻塞中……，当我们commit了修改的sql后，插入的方法也就执行成功了。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210522215546064.png" alt="image-20210522215546064"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210522215629031.png" alt="image-20210522215629031"></p><h4 id="4-5-3、间隙锁的危害"><a href="#4-5-3、间隙锁的危害" class="headerlink" title="4.5.3、间隙锁的危害"></a>4.5.3、间隙锁的危害</h4><p>&emsp;&emsp;在Query的执行过程中通过范围查找，会锁定整个范围内的索引值，即使这个值不存在。从而会造成在锁定这个范围的时候锁定插入值范围内的所有数据。在<strong>某些场景下可能会对性能产生一定影响</strong>。</p><h4 id="面试题：如何锁定一行数据"><a href="#面试题：如何锁定一行数据" class="headerlink" title="面试题：如何锁定一行数据"></a><font color='red'>面试题：如何锁定一行数据</font></h4><p>&emsp;&emsp;在查询的时候添加<code>for search</code>，对于改行的其它操作会被阻塞,直到锁定的行提交commit。</p><h1 id="二、日志与MVCC"><a href="#二、日志与MVCC" class="headerlink" title="二、日志与MVCC"></a>二、日志与MVCC</h1><h2 id="1、日志"><a href="#1、日志" class="headerlink" title="1、日志"></a>1、日志</h2><p>&emsp;&emsp;MySQL中有六种日志文件，分别是：重做日志（redo log）、回滚日志（undo log）、二进制日志（binlog）、错误日志（errorlog）、慢查询日志（slow query log）、一般查询日志（general log），中继日志（relay log）。<br>&emsp;&emsp;在这其中重做日志和回滚日志与事务操作息息相关，二进制日志也与事务操作有一定的关系。这三种日志，对理解MySQL中的事务操作有着重要的意义。</p><h3 id="1-1、bin-log日志"><a href="#1-1、bin-log日志" class="headerlink" title="1.1、bin log日志"></a>1.1、bin log日志</h3><p>&emsp;&emsp;bin log日志，又称为二进制日志、归档日志，是<strong>server层面的日志</strong>。它最主要的作用有两点：其一是<strong>用于主从复制</strong>，从库利用主库上的binlog进行重播，实现主从同步。其二是用于<strong>数据库基于时间点的还原</strong>。bin log<strong>没有crash-safe能力</strong>。</p><p>&emsp;&emsp;bin log日志，是属于逻辑格式的日志，我们可以简单认为就是执行过的事务中的sql语句。当然，其还包括了执行的sql语句（增删改）反向的信息【insert –&gt; delete】。</p><p><strong>crash-safe能力：</strong></p><p>&emsp;&emsp;如果MySQL 进程异常重启了，系统会自动去检查日志，将未写入到MySQL的数据从日志中恢复到MySQL中去的能力，就称为crash-safe能力。</p><h3 id="1-2、redo-log日志"><a href="#1-2、redo-log日志" class="headerlink" title="1.2、redo log日志"></a>1.2、redo log日志</h3><p>&emsp;&emsp;redo log是<strong>InnoDB存储引擎的日志</strong>，又称重做日志文件。它用于<strong>记录事务操作的变化</strong>，记录的是数据修改之后的值，不管事务是否提交都会记录下来。在实例和介质失败（media failure）时，redo log文件就能派上用场，如数据库突然停止，InnoDB存储引擎会使用redo log恢复到停止前的时刻，以此来<strong>保证事务的持久性</strong>。所以，redo log 并不是等到事务提交才会落盘，而是在事务的执行过程中，就开始写入。有了redo log日志，就可以保证MySQL异常重启时数据不丢失，具有crash-safe能力。</p><p>&emsp;&emsp;redo log默认是由两个文件组成ib_logfile0&amp;ib_logfile1，这个文件数量及大小都可以设置。redo log 中有一个重要的参数<strong>check point（检查点）</strong>当一个文件写满之后，就会往另一个文件写入，当两个文件都写满了之后，就会重新往第一个文件写入，此时就会触发check point，此时数据库就会停止数据库更新语句的执行，转而进行redo log 日志同步到磁盘的操作。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/2105240001.png" alt="2105240001"></p><h4 id="1-2-1、redo-log刷盘"><a href="#1-2-1、redo-log刷盘" class="headerlink" title="1.2.1、redo log刷盘"></a>1.2.1、redo log刷盘</h4><p>&emsp;&emsp;MariaDB/MySQL是工作在用户空间的，它们的log buffer要写入磁盘需要经过操作系统内核空间的os buffer，再调用fsync()将OS buffer中的日志刷到磁盘上的log file中。</p><p><img src="http://yrlzero.gitee.io/images/linux/MySQL/redo-logbuffer.jpg" alt="img"></p><p>&emsp;&emsp;如右图所示，redo log的刷盘存在三种方式，可以通过<code>innodb_flush_log_at_trx_commit</code>参数进行调整，主要控制innodb将log buffer中的数据写入日志文件并flush磁盘的时间点，值分别为0，1，2，我们可以执行<code>SHOW VARIABLES LIKE &#39;innodb_flush_log_at_trx_commit&#39;</code>查询，MySQL默认值为1。</p><table><thead><tr><th>值</th><th>刷盘方式</th><th>总结</th></tr></thead><tbody><tr><td>0</td><td>在提交事务时，InnoDB不会立即触发将缓存日志写到磁盘文件的操作，而是每秒触发一次缓存日志回写磁盘操作，并调用操作系统fsync()刷新IO缓存。</td><td>保证了数据的持久性。当然，我们可以将这个配置项设置为1以外的值来换取更高的性能，但是在系统崩溃的时候，将会丢失1秒的数据。</td></tr><tr><td>1</td><td>在每个事务提交时，InnoDB立即将缓存中的redo日志回写到日志文件，并调用操作系统fsync()刷新IO缓存。</td><td>MySQL进程崩溃的时候，就会丢失最后1秒的事务。</td></tr><tr><td>2</td><td>在每个事务提交时，InnoDB立即将缓存中的redo日志回写到日志文件，但并不马上调用fsync()来刷新IO缓存，而是每秒只做一次磁盘IO缓存刷新操作。</td><td>只有在<strong>操作系统</strong>崩溃或者断电的时候才会丢失最后1秒的数据。InnoDB在做恢复的时候会忽略这个值。</td></tr></tbody></table><h4 id="1-2-2、relo-log两阶段事务提交"><a href="#1-2-2、relo-log两阶段事务提交" class="headerlink" title="1.2.2、relo log两阶段事务提交"></a><font color='red'>1.2.2、relo log两阶段事务提交</font></h4><p>&emsp;&emsp;MySQL为了保证redo log和bin log两份日志最终恢复到数据库的时候数据一致，所以redo log采用的是两阶段的提交机制。其主要流程如下：</p><blockquote><ol><li>执行器调用存储引擎接口，存储引擎将修改更新到内存中后，将修改操作写到redo log里面，此时redo log处于prepare状态；</li><li>存储引擎告知执行器执行完毕，执行器开始将操作写入到bin log中，写完后调用存储引擎的接口提交事务；</li><li>存储引擎将redo log的状态置为commit。</li></ol></blockquote><p><img src="http://cheng_qiwei.gitee.io/blog/img/2020070821053019.png" alt="2020070821053019"></p><p><strong>两阶段提交的重要性：</strong></p><p>&emsp;&emsp;如果没有使用两阶段的提交机制，可能会造成用日志恢复出来的数据和原来数据不一致的情况。</p><p><strong>情况1：先写入redo log，再写入bin log；</strong></p><p>&emsp;&emsp;假设先写完redo log之后就直接commit，那么此时如果系统崩溃了，在系统重启后，还是能够把数据恢复过来，但是由于此时bin log并没有记录这个语句，所以如果需要使用bin log来进行备份时，恢复过来的数据就会缺少此次修改，导致与原数据不一致。</p><p><strong>情况2：先写入bin log，再写入redo log；</strong></p><p>&emsp;&emsp;如果当前先写完bin log之后系统崩溃了，那么在系统重启之后，由于redo log没有保存，所以此时数据恢复过来之后会没有恢复这次修改。但是bin log却记录了这个语句，导致当使用bin log恢复数据时，就会多出一个事物，导致数据与源数据库不一致。</p><h3 id="1-3、redo-log与bin-log的不同"><a href="#1-3、redo-log与bin-log的不同" class="headerlink" title="1.3、redo log与bin log的不同"></a>1.3、redo log与bin log的不同</h3><blockquote><p>redo log是属于innoDB层面；<br>binlog属于MySQL Server层面的，这样在数据库用别的存储引擎时可以达到一致性的要求。</p><p>redo log是物理日志，记录该数据页更新的内容；<br>binlog是逻辑日志，记录的是这个更新语句的原始逻辑</p><p>redo log是循环写，日志空间大小固定；<br>binlog是追加写，是指一份写到一定大小的时候会更换下一个文件，不会覆盖。</p><p>binlog在事务提交后才会写入，可以作为恢复数据使用，主从复制搭建，在事务进行中数据修改前写入，然后才对缓存中的数据进行修改;<br>redo log作为异常宕机或者介质故障后的数据恢复使用。</p></blockquote><h2 id="2、MVCC"><a href="#2、MVCC" class="headerlink" title="2、MVCC"></a>2、MVCC</h2><h3 id="2-1、什么是MVCC？"><a href="#2-1、什么是MVCC？" class="headerlink" title="2.1、什么是MVCC？"></a>2.1、什么是MVCC？</h3><p>&emsp;&emsp;MVCC，全称Multi-Version Concurrency Control，即<strong>多版本并发控制</strong>。MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。MVCC在MySQL InnoDB中的实现主要是为了<strong>提高数据库并发性能</strong>，用更好的方式去处理读写冲突，做到即使有读写冲突时，也能做到不加锁，<strong>非阻塞并发读</strong>。</p><h3 id="2-2、什么是当前读和快照读？"><a href="#2-2、什么是当前读和快照读？" class="headerlink" title="2.2、什么是当前读和快照读？"></a>2.2、什么是当前读和快照读？</h3><p>&emsp;&emsp;在了解MVCC多版本并发控制之前，我们必须先了解一下，什么是MySQL InnoDB下的当前读和快照读?</p><p>&emsp;&emsp;当前读，就是它读取的是记录的最新版本，读取时还要<strong>保证其他并发事务不能修改当前记录，会对读取的记录进行加锁</strong>。像select lock in share mode(共享锁), select … for update ; update, insert ,delete(排他锁)这些操作都是一种当前读。</p><p>&emsp;&emsp;快照读，就是<strong>不加锁的非阻塞读</strong>，如：不加锁的select操作。之所以出现快照读的情况，是基于<strong>提高并发性能的考虑</strong>。快照读的实现是基于多版本并发控制，即MVCC,可以认为MVCC是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销。但既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本。此外，<strong>快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读</strong>。</p><p>&emsp;&emsp;总结：MVCC就是为了实现读-写冲突不加锁，而这个读指的就是快照读, 而非当前读，当前读实际上是一种加锁的操作，是悲观锁的实现。</p><h3 id="2-3、当前读、快照读、MVCC关系"><a href="#2-3、当前读、快照读、MVCC关系" class="headerlink" title="2.3、当前读、快照读、MVCC关系"></a>2.3、当前读、快照读、MVCC关系</h3><p>&emsp;&emsp;MVCC多版本并发控制指的是维持一个数据的多个版本，使得读写操作没有冲突，快照读是MySQL为实现MVCC的一个非阻塞读功能。MVCC模块在MySQL中的具体实现是由三个隐式字段，undo日志、read view三个组件来实现的。</p><h3 id="2-4、MVCC的好处"><a href="#2-4、MVCC的好处" class="headerlink" title="2.4、MVCC的好处"></a>2.4、MVCC的好处</h3><p><strong>数据库并发场景有三种，分别为：</strong></p><ul><li>读-读：不存在任何问题，也不需要并发控制</li><li>读-写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读</li><li>写-写：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失</li></ul><p><strong>MVCC带来的好处是：</strong></p><p>&emsp;&emsp;多版本并发控制（MVCC）是一种用来解决读-写冲突的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 所以MVCC可以为数据库解决以下问题：</p><ul><li>在<strong>并发读写数据库</strong>时，可以做到在<strong>读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能</strong></li><li>同时还可以<strong>解决脏读，幻读，不可重复读等事务隔离问题</strong>，但<strong>不能解决更新丢失问题</strong></li></ul><h2 id="3、MVCC的实现原理"><a href="#3、MVCC的实现原理" class="headerlink" title="3、MVCC的实现原理"></a>3、MVCC的实现原理</h2><p>&emsp;&emsp;我们上面说到：MVCC模块在MySQL中的具体实现是由三个隐式字段，undo日志、read view三个组件来实现的。那么，我们接下来就从三个隐式字段聊起。</p><h3 id="3-1、MVCC的三个隐式字段"><a href="#3-1、MVCC的三个隐式字段" class="headerlink" title="3.1、MVCC的三个隐式字段"></a>3.1、MVCC的三个隐式字段</h3><table><thead><tr><th>字段名称</th><th>占用字节</th><th>说明</th></tr></thead><tbody><tr><td>DB_TRX_ID</td><td>6byte</td><td>最近修改事务ID，记录最后一次操作（首次创建、最后一个更新）这条记录的事务id</td></tr><tr><td>DB_ROLL_PTR</td><td>7byte</td><td>回滚指针，指向这条记录的上一个版本（存储于rollback segment）</td></tr><tr><td>DB_ROW_ID</td><td>6byte</td><td>隐藏主键，当表没有主键或者唯一键时，会自动创建该隐藏的自增id</td></tr></tbody></table><h3 id="3-2、read-view"><a href="#3-2、read-view" class="headerlink" title="3.2、read view"></a>3.2、read view</h3><ul><li>Read View是事务进行<strong>快照读操作的时候生产的读视图</strong>，在该事务执行快照读的那一刻，会生成一个数据系统当前的快照，记录并维护系统当前活跃事务的id，事务的id值是递增的。</li><li>其实Read View的最大作用是<strong>用来做可见性判断</strong>的，也就是说当某个事务在执行快照读的时候，对该记录创建一个Read View的视图，把它当作<strong>条件去判断当前事务能够看到哪个版本的数据</strong>，有可能读取到的是最新的数据，也有可能读取的是当前行记录的undo log中某个版本的数据</li><li>Read View遵循的可见性算法主要是将要被修改的数据的最新记录中的DB_TRX_ID（当前事务id）取出来，与系统当前其他活跃事务的id去对比，如果DB_TRX_ID跟Read View的属性做了比较，不符合可见性，那么就通过DB_ROLL_PTR回滚指针去取出undolog中的DB_TRX_ID做比较，即遍历链表中的DB_TRX_ID，直到找到满足条件的DB_TRX_ID，这个DB_TRX_ID所在的旧记录就是当前事务能看到的最新老版本数据。</li></ul><h3 id="3-3、read-view-生成时机"><a href="#3-3、read-view-生成时机" class="headerlink" title="3.3、read view 生成时机"></a>3.3、read view 生成时机</h3><p>&emsp;&emsp;对于read view的生成时机，在不同隔离级别下是不同的。</p><blockquote><p>RC-读已提交：每次读取数据前，都生成read view<br>RR-可重复读：在第一次读取数据前，生成read view</p></blockquote><p>&emsp;&emsp;<strong>总结：在RC（读已提交）隔离级别下，是每个快照读都会生成并获取最新的Read View；而在RR（可重复读）隔离级别下，则是同一个事务中的第一个快照读才会创建Read View，之后的快照读获取的都是同一个Read View.</strong></p><h3 id="3-4、Read-View的全局属性"><a href="#3-4、Read-View的全局属性" class="headerlink" title="3.4、Read View的全局属性"></a>3.4、Read View的全局属性</h3><p> <code>trx_list</code>：一个数值列表，用来维护Read View生成时刻系统正活跃的事务ID</p><p> <code>up_limit_id</code>：记录trx_list列表中事务ID最小的ID，以下用min_trx_id 来表示方便理解</p><p> <code>low_limit_id</code>：Read View生成时刻系统尚未分配的下一个事务ID，以下用max_trx_id来表示方便理解</p><p> <code>create_trx_id</code>：当前事务id</p><h3 id="3-5、数据可见性判断"><a href="#3-5、数据可见性判断" class="headerlink" title="3.5、数据可见性判断"></a>3.5、数据可见性判断</h3><p> 情况一：<code>DB_TRX_ID</code>与<code>create_trx_id</code>相等</p><ul><li><p>表明该数据是当前事务修改的记录</p><p>当出现数据事务id不等于当前事务id时，根据undo log中的数据版本链往上追溯进行判断.</p><p>情况二：<code>DB_TRX_ID</code> &lt;<code>min_trx_id</code></p></li><li><p>当前<code>DB_TRX_ID</code>(记录的事务id)小于<code>min_trx_id</code>(最小活跃事务id)，这表明这条记录在其他活跃事务事前已经提交，所以数据对于当前事务可见。</p></li></ul><p>情况三：<code>DB_TRX_ID</code> &gt;= <code>max_trx_id</code></p><ul><li>当前DB_TRX_ID (记录的事务id)大于<code>max_trx_id</code>(未分配事务id)，这表明在当前事务开启之后又有新的事务开启，并且修改提交了该数据，所以数据对于当前事务不可见。</li></ul><p>情况四：<code>min_trx_id</code> &lt;= <code>DB_TRX_ID</code> &lt; <code>max_trx_id</code>，数据在两者之间需要分情况分析</p><ul><li>在区间内，<code>DB_TRX_ID</code> 也在<code>trx_list</code>中，那么当前事务不能读取。这表明该行数据是与当前事务一起开启的事务提交后生成的数据，所以数据对当前事务不可见。</li><li>在区间内，但是<code>DB_TRX_ID</code> 不在<code>trx_list</code>中，在区间内表明之前存在多个开启事务，不在<code>DB_TRX_ID</code> 表明在之前的多个热点事务中，id处于中间的某个事务提交，所以当前的事务读取的行数据为之前提交的事务数据，所以数据对于当前事务可见。</li><li>总得来说就是判断<code>DB_TRX_ID</code> 是否在活跃事务中，如果在，则代表在Read View生成时刻，这个事务还是活跃状态，还没有commit，未修改的数据，当前事务也是看不到；如果不在，则说明这个事务在Read View生成之前就已经开始commit，那么修改的结果是能够看见的。</li></ul><h3 id="3-6、purge与read-view"><a href="#3-6、purge与read-view" class="headerlink" title="3.6、purge与read view"></a>3.6、purge与read view</h3><p>&emsp;&emsp;为了节省磁盘空间，innodb有专门的<code>purge</code>线程来清理delete_bit为true的记录。为了不影响mvcc的正常工作，<code>purge</code>线程自己维护一个read view；如果某个记录的delete_bit为true，同时它的DB_TRX_ID（事务id）存在于<code>purge</code>线程的read view中，那么该记录可以被安全删除。</p><h3 id="3-7、MVCC的演示"><a href="#3-7、MVCC的演示" class="headerlink" title="3.7、MVCC的演示"></a>3.7、MVCC的演示</h3><p><img src="http://cheng_qiwei.gitee.io/blog/img/MVCC%E6%B5%81%E7%A8%8B%E6%BC%94%E7%A4%BA.png" alt="MVCC流程演示"></p><p>&emsp;&emsp;我们根据作图的操作，可以画出右边的版本链，当<code>session-4</code>【可重复读】第一次执行查询时，会生成read view，read view里面组成有：活跃的事务id列表-[100,200]，最大使用id[已使用的或活跃的]-300。在数据可见性判断中，就会变成右下角的图：min_id变成活跃事务id列表的最小id，在当前为100，max_id变成最大使用id +1，为301。那么此时进行查询，从版本链上面往下走，第一个记录的版本号是300，上面的部分还未执行，所以不存在。按照上面的规则，300在min_id和max_id之间，所以需要判断其是否在活跃的事务id列表内，发现并不存在，所以判定其为完成的事务，可以被查询，所以返回李磊3。当进行第二次、第三次……不管多少次，只要还在当前事务内，就会一直使用第一次生成的read view。所以此时第二次查询的起始点就是第三行，100，由于其在100~301之间，所以需要判断其是否在活跃列表上，发现在，说明事务还未提交，所以不可见，同理，第四个也是一样的情况，不可见，所以返回的结果还是李磊3。</p><p>&emsp;&emsp;而当隔离级别为读已提交时，由于每次查询都会生成新的read view，如上图，当<code>session-5</code>在查询时，由于是读已提交，所以在当前位置会获取新的read view，此时min_id变成活跃事务id列表的最小id，在当前为200，max_id变成最大使用id + 1，为301。那么查询版本链，此时从第一行开始，200，在范围内且在列表上，不可见；第二行200，同理不可见；第三行100，小于min_id，说明为已提交事务，可见，返回李磊1-2。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 锁 </tag>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL原理与优化</title>
      <link href="/blog/2021/05/10/MySQL%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
      <url>/blog/2021/05/10/MySQL%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL原理与优化"><a href="#MySQL原理与优化" class="headerlink" title="MySQL原理与优化"></a>MySQL原理与优化</h1><h1 id="一、Linux安装与配置MySQL"><a href="#一、Linux安装与配置MySQL" class="headerlink" title="一、Linux安装与配置MySQL"></a>一、Linux安装与配置MySQL</h1><p>安装链接：<a href="http://cheng_qiwei.gitee.io/blog/2021/03/15/Linux%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6/#Linux%E5%AE%89%E8%A3%85MySQL">链接</a></p><h2 id="1、设置MySQL字符集"><a href="#1、设置MySQL字符集" class="headerlink" title="1、设置MySQL字符集"></a>1、设置MySQL字符集</h2><p>&emsp;&emsp;以前的MySQL安装之后，可能会出现字符集的问题，我们可以使用命令查看当前的字符集</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;%char%&#x27;</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210506162622237.png" alt="image-20210506162622237"></p><p>&emsp;&emsp;如果出现字符集不符合的情况，可以修改<code>/etc/my.cnf </code>文件，添加如下配置，然后重启MySQL即可。</p><blockquote><p>[client]<br>default-character-set=utf8<br>[MySQLd]<br>character_set_server=utf8<br>character_set_client=utf8<br>collation-server=utf8_general_ci<br>[MySQL]<br>default-character-set=utf8  </p></blockquote><h2 id="2、设置大小写不敏感"><a href="#2、设置大小写不敏感" class="headerlink" title="2、设置大小写不敏感"></a>2、设置大小写不敏感</h2><p>&emsp;&emsp;MySQL默认设置大小写是敏感的，我们可以使用命令进行查看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;%lower_case_table_names%&#x27;;</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210506164217165.png" alt="image-20210506164217165"></p><table><thead><tr><th>属性设置</th><th>描述</th></tr></thead><tbody><tr><td>0</td><td>大小写敏感</td></tr><tr><td>1</td><td>大小写不敏感。 创建的表， 数据库都是以小写形式存放在磁盘上， 对于 sql 语句都是转换为 小写对表和 DB 进行查找</td></tr><tr><td>2</td><td>创建的表和 DB 依据语句上格式存放， 凡是查找都是转换为小写进行</td></tr></tbody></table><p>&emsp;&emsp;注意： 如果要设置属性为大小写不敏感， 要在重启数据库实例之前就需要将原来的数据库和表转换为小写， 否则将找不到数据库名。 在进行数据库参数设置之前， 需要掌握这个参数带来的影响， 切不可盲目设置。  </p><h2 id="3、关于sql-mode"><a href="#3、关于sql-mode" class="headerlink" title="3、关于sql_mode"></a>3、关于sql_mode</h2><p>&emsp;&emsp;sql_mode 定义了对 MySQL 中 sql 语句语法的校验规则！<br>&emsp;&emsp;sql_mode 是个很容易被忽视的变量， 默认值是空值， 在这种设置下是可以允许一些非法操作的， 比如允许一些非法数据的插入。 在生产环境必须将这个值设置为严格模式， 所以开发、 测试环境的数据库也必须要设置， 这样在开发测试阶段就可以发现问题。  </p><h3 id="3-1、sql-mode描述"><a href="#3-1、sql-mode描述" class="headerlink" title="3.1、sql_mode描述"></a>3.1、sql_mode描述</h3><table><thead><tr><th>sql_mode</th><th>描述</th></tr></thead><tbody><tr><td>ONLY_FULL_GROUP_BY</td><td>对于 GROUP BY 聚合操作， 如果在 SELECT 中的列， 没有在 GROUP BY 中出现， 那么这个 SQL 是不合法的， 因为列不在 GROUP BY 从句中</td></tr><tr><td>NO_AUTO_VALUE_ON_ZERO</td><td>该值影响自增长列的插入。 默认设置下， 插入 0 或 NULL 代表生成下一个自增 长值。 如果用户 希望插入的值为 0， 而该列又是自增长的， 那么这个选项就有 用了</td></tr><tr><td>STRICT_TRANS_TABLES</td><td>在该模式下， 如果一个值不能插入到一个事务表中， 则中断当前的操作， 对非 事务表不做限制</td></tr><tr><td>NO_ZERO_IN_DATE</td><td>在严格模式下， 不允许日期和月份为零</td></tr><tr><td>NO_ZERO_DATE</td><td>设置该值， mysql 数据库不允许插入零日期， 插入零日期会抛出错误而不是警告</td></tr><tr><td>ERROR_FOR_DIVISION_BY_ZERO</td><td>在 INSERT 或 UPDATE 过程中， 如果数据被零除， 则产生错误而非警告。 如 果 未给出该模式， 那么数据被零除时 MySQL 返回 NULL</td></tr><tr><td>NO_AUTO_CREATE_USER</td><td>禁止 GRANT 创建密码为空的用户</td></tr><tr><td>NO_ENGINE_SUBSTITUTION</td><td>如果需要的存储引擎被禁用或未编译， 那么抛出错误。 不设置此值时， 用默认 的存储引擎替代， 并抛出一个异常</td></tr><tr><td>PIPES_AS_CONCAT</td><td>将”||”视为字符串的连接操作符而非或运算符， 这和 Oracle 数据库是一样的， 也和字符串的拼接函数 Concat 相类似</td></tr><tr><td>ANSI_QUOTES</td><td>启用 ANSI_QUOTES 后， 不能用双引号来引用字符串， 因为它被解释为识别符</td></tr><tr><td>ORACLE</td><td>设 置 等 同 于 PIPES_AS_CONCAT, ANSI_QUOTES, IGNORE_SPACE,NO_KEY_OPTIONS, NO_TABLE_OPTIONS, NO_FIELD_OPTIONS,NO_AUTO_CREATE_USER</td></tr></tbody></table><h3 id="3-2、查看命令"><a href="#3-2、查看命令" class="headerlink" title="3.2、查看命令"></a>3.2、查看命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT @@sql_mode;</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210506165004526.png" alt="image-20210506165004526"></p><h3 id="3-3、修改sql-mode"><a href="#3-3、修改sql-mode" class="headerlink" title="3.3、修改sql_mode"></a>3.3、修改sql_mode</h3><p>&emsp;&emsp;修改<code>/etc/my.cnf </code>文件，添加如下配置，然后重启MySQL即可。</p><blockquote><p> [MySQLd] </p><p> sql_mode=””</p></blockquote><h1 id="二、MySQL逻辑架构"><a href="#二、MySQL逻辑架构" class="headerlink" title="二、MySQL逻辑架构"></a>二、MySQL逻辑架构</h1><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210506165253370.png" alt="image-20210506165253370"></p><h2 id="1、架构介绍"><a href="#1、架构介绍" class="headerlink" title="1、架构介绍"></a>1、架构介绍</h2><h3 id="1-1、连接层"><a href="#1-1、连接层" class="headerlink" title="1.1、连接层"></a>1.1、连接层</h3><p>&emsp;&emsp;最上层是一些客户端和连接服务， 包含本地 sock 通信和大多数基于客户端/服务端工具实现的类似于 tcp/ip 的通信。 主要完成一些类似于连接处理、 授权认证、 及相关的安全方案。 在该层上引入了线程池的概念， 为通过认证安全接入的客户端提供线程。 同样在该层上可以实现基于 SSL 的安全链接。 服务器也会为安全接入的每个客户端验证它所具有的操作权限。</p><h3 id="1-2、服务层"><a href="#1-2、服务层" class="headerlink" title="1.2、服务层"></a>1.2、服务层</h3><table><thead><tr><th>组件名称</th><th>组件功能</th></tr></thead><tbody><tr><td>Management Serveices &amp; Utilities</td><td>系统管理和控制工具</td></tr><tr><td>SQL Interface:</td><td>SQL 接口。 接受用户的 SQL 命令， 并且返回用户需要查询的结果。 比如 select from 就是调用 SQL Interface</td></tr><tr><td>Parser</td><td>解析器。 SQL 命令传递到解析器的时候会被解析器验证和解析</td></tr><tr><td>Optimizer</td><td>查询优化器。 SQL 语句在查询之前会使用查询优化器对查询进行优化， 比如有 where 条件时， 优化器来决定先投影还是先过滤。</td></tr><tr><td>Cache 和 Buffer</td><td>查询缓存。 如果查询缓存有命中的查询结果， 查询语句就可以直接去查询缓存中取 数据。 这个缓存机制是由一系列小缓存组成的。 比如表缓存， 记录缓存， key 缓存， 权限缓存等</td></tr></tbody></table><h3 id="1-3、引擎层"><a href="#1-3、引擎层" class="headerlink" title="1.3、引擎层"></a>1.3、引擎层</h3><p>&emsp;&emsp;存储引擎层， 存储引擎真正的负责了 MySQL 中数据的存储和提取， 服务器通过 API 与存储引擎进行通信。 不同的存储引擎具有的功能不同， 这样我们可以根据自己的实际需要进行选取。常用的引擎有InnoDB和MyIsam。</p><h3 id="1-4、存储层"><a href="#1-4、存储层" class="headerlink" title="1.4、存储层"></a>1.4、存储层</h3><p>&emsp;&emsp;数据存储层， 主要是将数据存储在运行于裸设备的文件系统之上， 并完成与存储引擎的交互。  </p><h2 id="2、MySQL-的查询流程"><a href="#2、MySQL-的查询流程" class="headerlink" title="2、MySQL 的查询流程"></a>2、MySQL 的查询流程</h2><p>&emsp;&emsp;首先 MySQL 客户端通过协议与 MySQL 服务器建连接，发送查询语句，先检查查询缓存，如果命中，直接返回结果，否则进行语句解析，也就是说，在解析查询之前，服务器会先访问查询缓存(query cache)——它存储 SELECT 语句以及相应的查询结果集。 如果某个<strong>查询结果已经位于缓存中， 服务器就不会再对查询进行解析、优化以及执行</strong>。 它仅仅将缓存中的结果返回给用户即可， 这将大大提高系统的性能。<br>&emsp;&emsp;语法解析器和预处理：首先 MySQL 通过关键字将 SQL 语句进行解析，并生成一棵对应的“解析树”，如下图。MySQL 解析器将使用 MySQL 语法规则验证和解析查询； 预处理器则根据一些 MySQL 规则进一步检查解析数是否合法。<br>&emsp;&emsp;查询优化器是当解析树被认为是合法的了， 并且由优化器将其转化成执行计划。 一条查询可以有很多种执行方式，最后都返回相同的结果。 优化器的作用就是找到这其中最好的执行计划。<br>&emsp;&emsp;最后， MySQL 默认使用的 BTREE 索引， 并且一个大致方向是:无论怎么折腾 sql， 至少在目前来说， MySQL 最多只用到表中的一个索引。 </p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210506172721523.png" alt="image-20210506172721523"></p><h2 id="3、SQL的执行流程"><a href="#3、SQL的执行流程" class="headerlink" title="3、SQL的执行流程"></a>3、SQL的执行流程</h2><p>我们在编写sql的顺序是：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210506172605646.png" alt="image-20210506172605646"></p><p>&emsp;&emsp;随着 MySQL 版本的更新换代， 其优化器也在不断的升级， 优化器会分析不同执行顺序产生的性能消耗不同而动态调整执行顺序。 下面是经常出现的查询顺序：  </p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210506172646322.png" alt="image-20210506172646322"></p><h2 id="4、数据引擎"><a href="#4、数据引擎" class="headerlink" title="4、数据引擎"></a>4、数据引擎</h2><h3 id="4-1、查看所有数据引擎"><a href="#4-1、查看所有数据引擎" class="headerlink" title="4.1、查看所有数据引擎"></a>4.1、查看所有数据引擎</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show engines</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210506173533993.png" alt="image-20210506173533993"></p><h3 id="4-2、查看默认数据引擎"><a href="#4-2、查看默认数据引擎" class="headerlink" title="4.2、查看默认数据引擎"></a>4.2、查看默认数据引擎</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;%storage_engine%&#x27;</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210506173622282.png" alt="image-20210506173622282"></p><h3 id="4-3、MyISAM-和-InnoDB"><a href="#4-3、MyISAM-和-InnoDB" class="headerlink" title="4.3、MyISAM 和 InnoDB"></a>4.3、MyISAM 和 InnoDB</h3><table><thead><tr><th align="center">对比项</th><th align="left">MyISAM</th><th>InnoDB</th></tr></thead><tbody><tr><td align="center">外键</td><td align="left">不支持</td><td>支持</td></tr><tr><td align="center">事务</td><td align="left">不支持</td><td>支持</td></tr><tr><td align="center">行表锁</td><td align="left">表锁， 即使操作一条记录也会锁住整个表， 不适合高并发的操作</td><td>行锁,操作时只锁某一行， 不对其它行有影响， 适合高并发的操作</td></tr><tr><td align="center">缓存</td><td align="left">只缓存索引， 不缓存真实数据</td><td>不仅缓存索引还要缓存真实数据， 对内存要求较高， 而且内 存大小对性能有决定性的影响</td></tr><tr><td align="center">关注点</td><td align="left">读性能</td><td>并发写、 事务、 资源</td></tr><tr><td align="center">默认安装</td><td align="left">Y</td><td>Y</td></tr><tr><td align="center">默认使用</td><td align="left">N</td><td>Y</td></tr><tr><td align="center">自带系统表使用</td><td align="left">Y</td><td>N</td></tr></tbody></table><h2 id="5、Buffer-Pool"><a href="#5、Buffer-Pool" class="headerlink" title="5、Buffer Pool"></a>5、Buffer Pool</h2><h3 id="5-1、什么的Buffer-Pool"><a href="#5-1、什么的Buffer-Pool" class="headerlink" title="5.1、什么的Buffer Pool"></a>5.1、什么的Buffer Pool</h3><p><img src="http://cheng_qiwei.gitee.io/blog/img/210523001.png" alt="210523001"></p><p>&emsp;&emsp;Buffer Pool 是一块<strong>内存区域</strong>，里面<strong>缓存了磁盘上面的真实数据</strong>。我们系统对数据库的增删改操作，其实主要就是对buffer pool这个内存数据结构的缓存数据进行操作的。</p><p>&emsp;&emsp;首先，由于Buffer Pool本质其实就是数据库的一个内存组件，你可以理解为它就是一片内存数据结构，所以这个内存数据结构肯定是有一定的大小的，而<strong>Buffer Pool的默认内存大小为128M</strong>，当然Buffer Pool的大小也是可以修改的，但是，我们最好是要根据我们系统的条件来调整其大小，从而发挥其更好的性能。</p><h3 id="5-2、Buffer-Pool的结构"><a href="#5-2、Buffer-Pool的结构" class="headerlink" title="5.2、Buffer Pool的结构"></a>5.2、Buffer Pool的结构</h3><p>&emsp;&emsp;Buffer Pool主要是由<strong>数据页和三条链构成</strong>。而其中的数据页，是由<strong>缓存页和缓存页描述信息</strong>构成。缓存页存放着从数据页上面读取的信息，都是16KB。而缓存信息描述页，则是保存<strong>缓存页所属的表空间、数据页编号、地址等信息等</strong>。结构如图所示，每个描述页大小是缓存页的5%左右，大约是800个字节。正由于这个描述信息，所以假设我们设置Buffer Pool的内存大小为128M，则正常情况下会稍高于这个值，多的部分就是用于存放缓存页描述信息。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/210523002.png" alt="210523002"></p><h3 id="5-3、free链"><a href="#5-3、free链" class="headerlink" title="5.3、free链"></a>5.3、free链</h3><p>&emsp;&emsp;关于free链，它的作用就是<strong>帮助我们找到空闲的缓存页</strong>。free链是一个双向链表，每个节点保存了Buffer Pool中的<strong>空闲缓存页的描述信息快</strong>。当然，除了缓存描述信息块以外，free链还存储了一个<strong>基础节点</strong>，里面记录了有多少个空闲的缓存页和头尾节点。</p><p>&emsp;&emsp;当我们加载数据的时候，会从free链中找到空闲的缓存页，然后把数据页的表空间号和数据页号写入描述信息块；加载数据到缓存页后，会把缓存页对应的描述信息块从free链中移除。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/210523003.png" alt="210523003"></p><h3 id="5-4、flush链"><a href="#5-4、flush链" class="headerlink" title="5.4、flush链"></a>5.4、flush链</h3><p>&emsp;&emsp;关于flush链，它的作用就是<strong>帮助我们找到脏缓存页</strong>。这里的脏缓存页，就是指<strong>被更新过的缓存页，数据和磁盘上的不一致，需要将更新刷回磁盘的缓存页</strong>。和上面的free链一样，flush链也是一条双向链表，结构也是和free链表一致。</p><p>&emsp;&emsp;数据的更新，一般不会直接更新磁盘的数据，而是更新缓存页上的数据，更新之后就会将其描述信息加入flush链表上，当后台线程在MySQL不是很繁忙的时候，就会将flush链表上的数据刷入磁盘，然后将该页从flush链表上移除。</p><p>&emsp;&emsp;</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/210523004.png" alt="210523004"></p><h3 id="5-5、LRU链"><a href="#5-5、LRU链" class="headerlink" title="5.5、LRU链"></a><font color='red'>5.5、LRU链</font></h3><p>&emsp;&emsp;当我们查询越来越多的时候，此时，我们的Buffer Pool也就会慢慢被填满，那么，当Buffer Pool满了之后，就需要淘汰一些缓存页。此时就需要有一些策略来淘汰一些不常用的缓存页。Buffer Pool是基于LRU方法来进行缓存页管理的。LRU【Least Recently Used】也就是最近最少使用。</p><h4 id="5-5-1、传统的LRU淘汰法"><a href="#5-5-1、传统的LRU淘汰法" class="headerlink" title="5.5.1、传统的LRU淘汰法"></a>5.5.1、传统的LRU淘汰法</h4><p>&emsp;&emsp;在传统情况下，缓存页在被使用后，有两种情况：</p><p>&emsp;&emsp;a、当缓存页本身已经存在于缓冲池中，那么此时就是将其放置到LRU链的头部，不需要淘汰其他缓存页。如图：当获取了6号页中的数据时，将6号页放到链表头部即可。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/210523005.png" alt="210523005"></p><p>&emsp;&emsp;b、当缓存页不在缓冲池中，此时，会将其从磁盘读入对应的数据也，并将其放置在链表头部，同时，淘汰掉链表的尾部节点。如图：如果要访问的数据在 60 号页中，60 号页不在缓冲池中，此时加载进来放到链表的头部，同时淘汰掉末尾的 17 号缓存页。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/210523006.png" alt="210523006"></p><p>&emsp;&emsp;我们基于传统的LRU淘汰法，我们会发现存在两个问题：<strong>预读失效和缓冲池污染</strong>。要解决这两个问题，首先我们要先了解一下什么是磁盘预读和局部性原理。</p><h4 id="5-5-2、局部性原理和磁盘预读"><a href="#5-5-2、局部性原理和磁盘预读" class="headerlink" title="5.5.2、局部性原理和磁盘预读"></a>5.5.2、局部性原理和磁盘预读</h4><p>&emsp;&emsp;由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘1/0，为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会<strong>磁盘预读</strong>，即使只需要一个字节，磁盘也会<strong>从这个位置开始，顺序向后读取一定长度的数据放入内存</strong>。</p><p>&emsp;&emsp;而这样操作的理论依据是计算机中著名的局部性原理：<strong>当一个数据被使用时，其附近的数据也通常会马上被使用</strong>，程序运行期间所需要的数据通常比较集中。</p><h4 id="5-5-3、预读失效和缓冲池污染"><a href="#5-5-3、预读失效和缓冲池污染" class="headerlink" title="5.5.3、预读失效和缓冲池污染"></a>5.5.3、预读失效和缓冲池污染</h4><p><strong>预读失效</strong></p><p>&emsp;&emsp;上面我们提到了缓冲池的预读机制可能会预先加载相邻的数据页。假如加载了 20、21 相邻的两个数据页，如果只有页号为 20 的缓存页被访问了，而另一个缓存页却没有被访问。此时两个缓存页都在链表的头部，但是为了加载这两个缓存页却淘汰了末尾的缓存页，而被淘汰的缓存页却是经常被访问的。这种情况就是预读失效，被预先加载进缓冲池的页，并没有被访问到，这种情况是不是很不合理。</p><p><strong>缓冲池污染</strong><br>&emsp;&emsp;还有一种情况是当执行一条 SQL 语句时，如果扫描了大量数据或是进行了全表扫描，此时缓冲池中就会加载大量的数据页，从而将缓冲池中已存在的所有页替换出去，这种情况同样是不合理的。这就是缓冲池污染，并且还会导致 MySQL 性能急剧下降。</p><h4 id="5-5-4、LRU升级版"><a href="#5-5-4、LRU升级版" class="headerlink" title="5.5.4、LRU升级版"></a>5.5.4、LRU升级版</h4><p>&emsp;&emsp;我们通过上面的分析，发现传统的LRU方法并不能满足缓冲池的空间管理。因此，MySQL基于LRU设计了冷热数据分离的处理方案。这个方案，就是将LRU链分为两部分，一部分为热数据区域，一部分为冷数据区域，他们的占比为5/8和3/8，如下图所示：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/210523007.png" alt="210523007"></p><p>&emsp;&emsp;当我们的数据页第一次被加载到缓冲池中，会先将其放置到冷数据区域的头部，当1s后该缓存页再次被访问时，就会将其加入热数据区域的头部。而之所以这么设计，就是为了防止扫描全表的时候，将整个LRU链大换血导致缓冲池污染，这些大批量的扫描就只存放于冷数据区域，从而不会影响热数据区域的数据页。当然，对于热数据区域的数据访问，也并非是每访问一次就插入一次链表头。MySQL中优化为热数据区域的后75%的部分被访问后才会将其移动到链表头部，对于前面25%的部分是不会移动的。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/210523008.png" alt="210523008"></p><h1 id="三、索引优化分析"><a href="#三、索引优化分析" class="headerlink" title="三、索引优化分析"></a>三、索引优化分析</h1><h2 id="1、常见的七种Join查询"><a href="#1、常见的七种Join查询" class="headerlink" title="1、常见的七种Join查询"></a>1、常见的七种Join查询</h2><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210507230215647.png" alt="image-20210507230215647"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//取A和B的交集</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A <span class="keyword">inner</span> <span class="keyword">join</span> B <span class="keyword">on</span> A.key = B.key;</span><br><span class="line">//取A和A和B的交集</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A <span class="keyword">left</span> <span class="keyword">join</span> B <span class="keyword">on</span> A.key = B.key;</span><br><span class="line">//取B和A和B的交集</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A <span class="keyword">right</span> <span class="keyword">join</span> B <span class="keyword">on</span> A.key = B.key;</span><br><span class="line">//取B在A中的相对补集</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A <span class="keyword">left</span> <span class="keyword">join</span> B <span class="keyword">on</span> A.key = B.key <span class="keyword">where</span> B.key <span class="keyword">is</span> <span class="literal">null</span>;</span><br><span class="line">//取A在B中的相对补集</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A <span class="keyword">right</span> <span class="keyword">join</span> B <span class="keyword">on</span> A.key = B.key <span class="keyword">where</span> A.key <span class="keyword">is</span> <span class="literal">null</span>;</span><br><span class="line">//取A和B的并集</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A <span class="keyword">left</span> <span class="keyword">join</span> B <span class="keyword">on</span> A.key = B.key</span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A <span class="keyword">right</span> <span class="keyword">join</span> B <span class="keyword">on</span> A.key = B.key;</span><br><span class="line">//取A和B的差集</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A <span class="keyword">left</span> <span class="keyword">join</span> B <span class="keyword">on</span> A.key = B.key <span class="keyword">where</span> B.key <span class="keyword">is</span> <span class="literal">null</span></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A <span class="keyword">right</span> <span class="keyword">join</span> B <span class="keyword">on</span> A.key = B.key <span class="keyword">where</span> A.key <span class="keyword">is</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h2 id="2、索引"><a href="#2、索引" class="headerlink" title="2、索引"></a>2、索引</h2><h3 id="2-1、什么是索引？"><a href="#2-1、什么是索引？" class="headerlink" title="2.1、什么是索引？"></a>2.1、什么是索引？</h3><p>&emsp;&emsp;MySQL 官方对索引的定义为：索引（Index）是帮助 MySQL 高效获取数据的<font color='red'>数据结构</font>。 此时我们可以得到<strong>索引的本质：索引是数据结构</strong>。 简单理解为<font color='red'>排好序且可以快速查找的数据结构</font>。  </p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210508143449058.png" alt="image-20210508143449058"></p><h3 id="2-2、索引的优缺点"><a href="#2-2、索引的优缺点" class="headerlink" title="2.2、索引的优缺点"></a>2.2、索引的优缺点</h3><ul><li>优点</li></ul><p>&emsp;&emsp;a、大大减少了服务器需要扫描的数据量；</p><p>&emsp;&emsp;b、帮助服务器避免排序和临时表；</p><p>&emsp;&emsp;c、将随机io转变成顺序io。</p><ul><li>缺点</li></ul><p>&emsp;&emsp;a、虽然索引大大提高了查询速度，但同时却会降低更新表（增删改）的速度。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息；</p><p>&emsp;&emsp;b、实际上索引也是一张表， 该表保存了主键与索引字段， 并指向实体表的记录， 所以索引列也是要占用空间的。  </p><h3 id="2-3、索引的分类"><a href="#2-3、索引的分类" class="headerlink" title="2.3、索引的分类"></a>2.3、索引的分类</h3><h4 id="2-3-1、单列索引"><a href="#2-3-1、单列索引" class="headerlink" title="2.3.1、单列索引"></a>2.3.1、单列索引</h4><p>&emsp;&emsp;单列索引，即一个索引只包含单个列， 一个表可以有多个单列索引 。 而单列索引又可以分成三种：</p><h5 id="2-3-1-1、普通索引"><a href="#2-3-1-1、普通索引" class="headerlink" title="2.3.1.1、普通索引"></a>2.3.1.1、普通索引</h5><p>&emsp;&emsp;普通索引是最基本的索引类型，没有什么限制，且允许空值和重复值。</p><h5 id="2-3-1-2、唯一索引"><a href="#2-3-1-2、唯一索引" class="headerlink" title="2.3.1.2、唯一索引"></a>2.3.1.2、唯一索引</h5><p>&emsp;&emsp;唯一索引列中的值必须是唯一的，允许存在一个空值。多个空值仍然会视为重复。</p><h5 id="2-3-1-3、主键索引"><a href="#2-3-1-3、主键索引" class="headerlink" title="2.3.1.3、主键索引"></a>2.3.1.3、主键索引</h5><p>&emsp;&emsp;主键索引，主键索引是特殊的唯一索引，不允许存在空值。 </p><h4 id="2-3-2、复合索引"><a href="#2-3-2、复合索引" class="headerlink" title="2.3.2、复合索引"></a>2.3.2、复合索引</h4><p>&emsp;&emsp;复合索引，也就是多列索引，由多列组合创建的索引，使用的时候遵循最左前缀原则。</p><h4 id="2-3-3、全文索引"><a href="#2-3-3、全文索引" class="headerlink" title="2.3.3、全文索引"></a>2.3.3、全文索引</h4><p>&emsp;&emsp;全文索引只有MyISAM引擎支持，且只能在CHAR,VARCHAR,TEXT类型字段上使用全文索引，主要用于做文章的关键字搜索的。</p><h4 id="2-3-4、空间索引"><a href="#2-3-4、空间索引" class="headerlink" title="2.3.4、空间索引"></a>2.3.4、空间索引</h4><p>&emsp;&emsp;空间索引是对空间数据类型的字段建立的索引。</p><h3 id="2-4、索引的操作"><a href="#2-4、索引的操作" class="headerlink" title="2.4、索引的操作"></a>2.4、索引的操作</h3><table><thead><tr><th>操作</th><th>命令</th></tr></thead><tbody><tr><td>创建</td><td>CREATE [UNIQUE ] INDEX [indexName] ON table_name(column))</td></tr><tr><td>删除</td><td>DROP INDEX [indexName] ON mytable</td></tr><tr><td>查看</td><td>SHOW INDEX FROM table_name</td></tr><tr><td>使 用 Alter 命令</td><td>ALTER TABLE tbl_name ADD PRIMARY KEY (column_list) : 该语句添加一个主键， 这意味着索引值必须是唯一 的， 且不能为 NULL</td></tr><tr><td></td><td>ALTER TABLE tbl_name ADD PRIMARY KEY (column_list)</td></tr><tr><td></td><td>ALTER TABLE tbl_name ADD INDEX index_name (column_list): 添加普通索引， 索引值可出现多次</td></tr><tr><td></td><td>ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list):该语句指定了索引为 FULLTEXT ， 用于全文索引</td></tr></tbody></table><h3 id="2-5、索引的创建时机"><a href="#2-5、索引的创建时机" class="headerlink" title="2.5、索引的创建时机"></a>2.5、索引的创建时机</h3><h4 id="2-5-1、适合创建索引的时机"><a href="#2-5-1、适合创建索引的时机" class="headerlink" title="2.5.1、适合创建索引的时机"></a>2.5.1、适合创建索引的时机</h4><blockquote><ol><li>主键自动建立唯一索引；</li><li>频繁作为查询条件的字段应该创建索引；</li><li>查询中与其它表关联的字段，外键关系建立索引；</li><li>对于单键和组合索引的选择问题，组合索引的性价比比较高；</li><li>查询中排序的字段应该创建索引，排序字段若通过索引去访问将大大提高排序速度；</li><li>查询中需要统计或分组的字段应该创建索引。</li></ol></blockquote><h4 id="2-5-2、不适合创建索引的时机"><a href="#2-5-2、不适合创建索引的时机" class="headerlink" title="2.5.2、不适合创建索引的时机"></a>2.5.2、不适合创建索引的时机</h4><blockquote><ol><li>频繁更新的字段不适合创建索引；</li><li>where条件中不常使用的字段不适合创建索引；</li><li>表数据比较少的时候可以不创建索引；</li><li>数据重复且发布比较均匀的的字段不适合建索引（唯一性太差的字段不适合建立索引），例如性别，真假值；</li><li>过滤性不好的不适合建索引 。</li></ol></blockquote><h2 id="3、MySQL的索引结构"><a href="#3、MySQL的索引结构" class="headerlink" title="3、MySQL的索引结构"></a>3、MySQL的索引结构</h2><p>附：各种树的测试网站：【<a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">链接</a>】</p><p>&emsp;&emsp;索引是一种<strong>支持快速查找的数据结构</strong>，在运用中往往还要求能够支持<strong>顺序查询</strong>，而常见的数据结构有很多，比如数组，链表，二叉树，散列表，二叉搜索树，平衡搜索二叉树，红黑树，跳表等。仅仅从数据结构那么为什么选择B+Tree呢？</p><h3 id="3-1、为什么其它数据结构不适合"><a href="#3-1、为什么其它数据结构不适合" class="headerlink" title="3.1、为什么其它数据结构不适合"></a>3.1、为什么其它数据结构不适合</h3><p>&emsp;&emsp;首先对于数组，链表这种线性表来说，适合存储数据，而不是查找数据，同样，对于普通二叉树来说，数据存储没有特定规律，所以也不适合。</p><h4 id="3-1-1、Hash索引【不能满足业务需求】"><a href="#3-1-1、Hash索引【不能满足业务需求】" class="headerlink" title="3.1.1、Hash索引【不能满足业务需求】"></a>3.1.1、Hash索引【不能满足业务需求】</h4><p>&emsp;&emsp;哈希结构在单条数据的等值查询是性能非常优秀，但是<strong>只能用来搜索等值的查询</strong>， 对于范围查询，模糊查询（最左前缀原则）都不支持，所以不能很好的支持业务需求；所以MySQL并没有显式支持Hash索引，而是根据数据的访问频次和模式自动的为热点数据页建立哈希索引，称之为自适应哈希索引。</p><p>&emsp;&emsp;同时由于哈希函数的随机性，Hash索引通常都是<strong>随机的内存访问，对于缓存不友好</strong>，会造成频繁的磁盘IO。</p><h4 id="3-1-2、二叉树和平衡二叉树【退化链表和过于严格】"><a href="#3-1-2、二叉树和平衡二叉树【退化链表和过于严格】" class="headerlink" title="3.1.2、二叉树和平衡二叉树【退化链表和过于严格】"></a>3.1.2、二叉树和平衡二叉树【退化链表和过于严格】</h4><p>&emsp;&emsp;使用二叉搜索树，如果左子树不为空，则左子树上所有节点均小于根节点，右子树节点均大于根节点；由其属性不难看出，这种树非常适合数据查找。不过它有个致命的缺点是<strong>二叉搜索树的树型取决于数据的输入顺序</strong>，极端情况下会退化成链表。例如：顺序的情况下。</p><p>&emsp;&emsp;由于二叉树的问题，所以平衡二叉树就出现了。它在保证数据顺序的基础上，又能维持树型，保证每个节点的左右子树高度相差不超过1。但同时，也是因为要一直维持这种严格的平衡状态，所以使得插入数据时可能要<strong>进行大量的数据移动</strong>，导致几乎每次插入和删除节点都会破坏树的平衡性，使得树的性能大打折扣。</p><h4 id="3-1-3、红黑树【高度过高，磁盘IO频繁】"><a href="#3-1-3、红黑树【高度过高，磁盘IO频繁】" class="headerlink" title="3.1.3、红黑树【高度过高，磁盘IO频繁】"></a>3.1.3、红黑树【高度过高，磁盘IO频繁】</h4><p>&emsp;&emsp;红黑树和其他二叉搜索树类似， 都是在进行插入和删除操作时通过特定操作保持二叉查找树的性质，从而获得较高的查找性能。与此同时，红黑树的平衡性并不像平衡搜索二叉树一样严格，但是能够拥有和平衡二叉树相近的性能。但是，红黑树也就只有两叉，数据量一上来之后，<strong>深度过大，数据检索时IO频繁</strong>，所以并不适合MySQL。</p><h4 id="3-1-4、-平衡多路查找树B-Tree【不支持顺序查询】"><a href="#3-1-4、-平衡多路查找树B-Tree【不支持顺序查询】" class="headerlink" title="3.1.4、 平衡多路查找树B-Tree【不支持顺序查询】"></a>3.1.4、 平衡多路查找树B-Tree【不支持顺序查询】</h4><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210510170040132.png" alt="image-20210510170040132"></p><p>&emsp;&emsp;针对上面的问题，我们推出了B-Tree。B-Tree是一种自平衡的多叉搜索树，一个节点可以拥有两个以上的子节点。适合读写相对大的数据块的存储系统，例如磁盘。由于MySQL索引一般都存储在内存中，如果使用B-Tree作为索引的话，索引和数据存储在一块，分布在各个节点中；而内存资源往往比较宝贵，<strong>一定内存的情况下可以存储的索引数量相对有限</strong>，毕竟每条数据的大小一般远大于索引列的大小，导致内存使用率不高。同时，数据查询过程往往会有顺序查询，而B-Tree和红黑树对于顺序查询并不友好。</p><h3 id="3-2、为什么MySQL选择B-Tree作为索引结构"><a href="#3-2、为什么MySQL选择B-Tree作为索引结构" class="headerlink" title="3.2、为什么MySQL选择B+Tree作为索引结构"></a>3.2、为什么MySQL选择B+Tree作为索引结构</h3><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210509223519469.png" alt="image-20210509223519469"></p><p>&emsp;&emsp;首先，B+Tree是在B Tree的基础上演变过来的，而与B Tree不同的是，B+Tree的<strong>数据页只存储在叶子节点</strong>上，同时<strong>叶子节点之间通过指针相连，为双向链表结构</strong>。B+Tree的优点总结起来有四个：</p><blockquote><ol><li>充分利用空间局部性原理，适合磁盘存储；</li><li>树的高度很低，能够在存储大量数据的情况下，进行较少的磁盘IO【下文有详细介绍】；</li><li>能够很好的支持单值、范围查询、有序性查询；</li><li>索引和数据分开存储，让更多的索引存储在内存中。</li></ol></blockquote><p><strong>问题1：为什么说B+Tree的树高很低？而一棵InnerDB的B+Tree最大能够保存多少数据？</strong></p><p>&emsp;&emsp;要了解这个问题，我们首先要了解一下MySQL的存储。</p><p>&emsp;&emsp;MySQL中的数据存储通常以Page为单位，俗称数据页，每个Page对应B+Tree的一个节点。页是InnoDB磁盘管理的最小单位，默认每个数据页的大小为16kb，我们也可以通过参数innodb_page_size将页的大小设置成其他值。</p><p>&emsp;&emsp;数据库的页大小和操作系统类似，是指存放数据时，每一块连续区域数据的大小。比如一个1M的数据存放在数据库中时， 需要大概64个页来存放（1024=64*16）。如果是在操作系统上安装的数据库，最好将数据库页大小设置为操作系统页大小的倍数，才是最佳设置。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210509225943410.png" alt="image-20210509225943410"></p><p>&emsp;&emsp;那么在正常情况下，我们默认一个Page是16KB，一个id主键我们使用BigInt[8个字节，8B]，每个Page中的数据间通过指针指向该区间对应的Page，默认是6个字节[6B]，每一个数据我们默认为1KB，所以每一条索引的数据会占用<strong>8+6=14B</strong>，所以一个Page能够存储的索引数据量有：<code>16 * 1024 / 14 ≈ 1170</code>个，一个Page能够存储的数据量为：<code>16 * 1024 / 1024 = 16</code>个，那么假如这棵树有三层，那么就能够存储的数据量为：<code>1170 * 1170 * 16 = 21902400</code>个，大约两千万条数据左右，所以说，<strong>B+Tree的树高很低（最多也就三层，三次IO操作即可），能够保存大概两千万条数据</strong>。</p><p>**问题2：为什么说 B+树比 B-树更适合实际应用中操作系统的文件索引和数据库索引？  **</p><p>&emsp;&emsp;首先，<strong>B+树的磁盘读写代价更低</strong>，B+树的内部结点并没有指向关键字具体信息的指针。 因此其内部结点相对 B 树更小。 如果把所有同一内部结点的关键字存放在同一盘块中， 那么盘块所能容纳的关键字数量也越多。 一次性读入内存中的需要查找的关键字也就越多。 相对来说 IO 读写次数也就降低了。  这里我们可以参考上面的例子，B+Tree三层就可以存储两千万左右的数据，而如果使用B Tree，则只能存储<code>15*15*15=3375</code>个左右的数据，远低于B+Tree。</p><p>&emsp;&emsp;其次，<strong>B+树的查询效率更加稳定</strong>，由于非终结点并不是最终指向文件内容的结点， 而只是叶子结点中关键字的索引。 所以任何关键字的查找必须走一条从根结点到叶子结点的路。 所有关键字查询的路径长度相同， 导致每一个数据的查询效率相当。  </p><h3 id="3-3、MySQL中索引的实现"><a href="#3-3、MySQL中索引的实现" class="headerlink" title="3.3、MySQL中索引的实现"></a>3.3、MySQL中索引的实现</h3><h4 id="3-3-1、MyISAM存储引擎中索引的实现"><a href="#3-3-1、MyISAM存储引擎中索引的实现" class="headerlink" title="3.3.1、MyISAM存储引擎中索引的实现"></a>3.3.1、MyISAM存储引擎中索引的实现</h4><p>&emsp;&emsp;首先，我们如果创建一张使用MyISAM索引的表时，此时data目录中会出现对应该表的三个文件，分别是：</p><blockquote><p>.Frm文件：表的定义文件</p><p>.MYD文件：数据文件</p><p>.MYI文件：索引文件</p></blockquote><p>&emsp;&emsp;我们从上面的文件上，可以得知MyISAM中数据文件和索引文件是分开的，那么我们可以观察下图，每一个叶子节点的data域保存的是数据记录的地址，假设此时需要查询 id = 40 的数据，那么此时就会根据索引文件去查询40这个数据，得到0x34这个地址，然后再通过这个地址去MYD中加载对应地址的记录。 </p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210510230331345.png" alt="image-20210510230331345"></p><p>&emsp;&emsp;那么，如果当存在多个索引时，操作方式同上，所以在MyISAM存储引擎中，主键索引和辅助索引是同级别的，没有主次之分。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/20200516185926534.png" alt="20200516185926534.png"></p><h4 id="3-3-2、InnoDB存储引擎中索引的实现"><a href="#3-3-2、InnoDB存储引擎中索引的实现" class="headerlink" title="3.3.2、InnoDB存储引擎中索引的实现"></a>3.3.2、InnoDB存储引擎中索引的实现</h4><p>&emsp;&emsp;同样，我们如果创建一张使用InnoDB索引的表时，此时data目录中会出现对应该表的两个文件，分别是：</p><blockquote><p>.Frm文件：表的定义文件</p><p>.Ibd文件：数据和索引的存储文件。数据以主键进行聚集存储，把真正的数据保存到叶子节点上</p></blockquote><p><img src="http://cheng_qiwei.gitee.io/blog/img/20200516190622724.png"></p><p>&emsp;&emsp;我们通过上图来看，InnoDB和MyISAM两者的区别就是InnoDB的叶子节点data域保存的是真实数据，这样就减少了获取数据地址之后还要再进行一次查询的IO操作。同时，在主键索引的叶子节点保存的是真实数据，而其他辅助索引的叶子节点的data域保存的是主键索引关键字的值【默认为主键】，例如：根据下图所示，假设我们需要查询Name=C的数据，那么MySQL会先在辅助索引中查询到C对应的主键关键字的值是9，然后再通过9到主键索引中获取真实数据。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/20200516201940584.png"></p><h3 id="3-4、聚簇索引和非聚簇索引"><a href="#3-4、聚簇索引和非聚簇索引" class="headerlink" title="3.4、聚簇索引和非聚簇索引"></a>3.4、聚簇索引和非聚簇索引</h3><p>&emsp;&emsp;<strong>聚簇索引</strong>并不是一种单独的索引类型，而是一种<strong>数据存储方式</strong>。当表有了聚簇索引的时候，表的<strong>数据行都存放在索引树的叶子页中</strong>。无法把数据行放到两个不同的地方，所以一张表只允许有一个聚簇索引。InnoDB的聚簇索引实际上是将索引和数据保存中同一个B-Tree中。InnoDB默认通过<strong>主键聚集数据</strong>，如果没有定义主键，InnoDB会选择一个<strong>唯一的的非空索引</strong>代替。如果没有这样的索引，InnoDB会<strong>隐式定义一个主键来作为聚簇索引</strong>。</p><p>&emsp;&emsp;当使用主键作为聚簇索引时，主键最好不要使用uuid，因为uuid的值太过离散，不适合排序且可能出现新增加记录的uuid，会插入在索引树中间的位置，导致<strong>索引树调整复杂度变大，消耗更多的时间和资源</strong>。而且，主键值占用的存储空间越大，辅助索引中保存的主键值也会跟着变大，占用存储空间，也会<strong>影响到IO操作读取到的数据</strong>。</p><p>&emsp;&emsp;<strong>非聚簇索引</strong>，又叫二级索引。二级索引的叶子节点中保存的不是指向行的物理指针，而是行的主键值。当通过二级索引查找行，存储引擎需要在二级索引中找到相应的叶子节点，获得行的主键值，然后使用主键去聚簇索引中查找数据行，这需要两次B-Tree查找。MyISAM默认使用非聚簇索引。</p><h3 id="3-5、回表"><a href="#3-5、回表" class="headerlink" title="3.5、回表"></a>3.5、回表</h3><p>&emsp;&emsp;不管是MyISAM还是InnoDB的普通索引，这种先通过索引扫描出数据所在行的唯一信息【主键，聚簇索引的唯一值、地址等等】，再通过这个唯一信息获取索引中未提供的数据，这种操作称为回表。</p><h3 id="3-6、InnoDB的页分裂和页合并"><a href="#3-6、InnoDB的页分裂和页合并" class="headerlink" title="3.6、InnoDB的页分裂和页合并"></a>3.6、InnoDB的页分裂和页合并</h3><h4 id="3-6-1、页的内部原理"><a href="#3-6-1、页的内部原理" class="headerlink" title="3.6.1、页的内部原理"></a>3.6.1、页的内部原理</h4><p>&emsp;&emsp;页可以空或者充满（100%），当你插入数据时，如果数据的大小能够放进页中，那么他们是按照顺序将页填满的，而如果当前页满，则下一行记录将会被插入下一页中。同时，上一页的指针也会指向下一页，在这种机制下可以做到快速的顺序扫描（如范围扫描）。同时，我们可以从下图看到，页中还维护了一个非常重要的属性：<code>MERGE_THRESHOLD</code>。该参数的默认值是50%页的大小，它在InnoDB的合并操作中扮演了很重要的角色。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/202105170001.jpg" alt="202105170001"></p><h4 id="3-6-2、页合并"><a href="#3-6-2、页合并" class="headerlink" title="3.6.2、页合并"></a>3.6.2、页合并</h4><p>&emsp;&emsp;当我们删除了一行数据时，实际上这条数据并没有直接就被删除，而是被标记（flaged）为删除，同时它的空间允许其他记录声明使用。当这个页中的数据删除到低于<code>MERGE_THRESHOLD</code>设定的值时，该页便会开始寻找前后的页，看看两个页能否合并以优化空间使用。如下图：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210517113029924.png" alt="image-20210517113029924"></p><h4 id="3-6-3、页分裂"><a href="#3-6-3、页分裂" class="headerlink" title="3.6.3、页分裂"></a>3.6.3、页分裂</h4><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210517115750111.png" alt="image-20210517115750111"></p><p>&emsp;&emsp;我们在前面也说到，当页填充至100%时，下一页会继续接管新的记录。但是，当当前页无法接纳新的记录，而下一页也满了，那么此时数据该怎么办？我们来看看InnoDB的操作（简化版）：</p><blockquote><ol><li>创建新页；</li><li>判断当前页可以从哪里进行分裂；</li><li>移动数据行；</li><li>重新定义页之间的关系。</li></ol></blockquote><p>&emsp;&emsp;说通俗一点，就是创建一个新的页，适当的移动部分数据行到新的页，最后更改指针的指向来保证正确的顺序。</p><h2 id="4、Explain-性能分析"><a href="#4、Explain-性能分析" class="headerlink" title="4、Explain 性能分析"></a>4、Explain 性能分析</h2><p>&emsp;&emsp;使用 EXPLAIN 关键字可以模拟优化器执行 SQL 查询语句， 从而知道 MySQL 是如何处理你的 SQL 语句的。 分析你的查询语句或是表结构的性能瓶颈。<br>&emsp;&emsp;用法： Explain+SQL 语句。  </p><p>&emsp;&emsp;Explain返回的内容有：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210511172505166.png" alt="image-20210511172505166"></p><h3 id="4-1、id"><a href="#4-1、id" class="headerlink" title="4.1、id"></a>4.1、id</h3><p>&emsp;&emsp;id是select 查询的序列号，包含一组数字， 表示查询中执行 select 子句或操作表的顺序。  id总共会出现三种情况：id相同、id不同、id有相同有不同。一个sql语句的查询，查询的次数越少越好[id越小越好]。</p><h4 id="4-1-1、id相同的情况下，执行顺序由上而下；"><a href="#4-1-1、id相同的情况下，执行顺序由上而下；" class="headerlink" title="4.1.1、id相同的情况下，执行顺序由上而下；"></a>4.1.1、id相同的情况下，执行顺序由上而下；</h4><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210512164208752.png" alt="image-20210512164208752"></p><h4 id="4-1-2、id不同，如果是子查询，id序号会递增，此时，id越大优先级越高越先执行；"><a href="#4-1-2、id不同，如果是子查询，id序号会递增，此时，id越大优先级越高越先执行；" class="headerlink" title="4.1.2、id不同，如果是子查询，id序号会递增，此时，id越大优先级越高越先执行；"></a>4.1.2、id不同，如果是子查询，id序号会递增，此时，id越大优先级越高越先执行；</h4><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210512164421846.png" alt="image-20210512164421846"></p><h4 id="4-1-3、id有相同也有不同，id相同说明为同一组，执行顺序由上而下，id不同，则id越大优先级越高越先执行。"><a href="#4-1-3、id有相同也有不同，id相同说明为同一组，执行顺序由上而下，id不同，则id越大优先级越高越先执行。" class="headerlink" title="4.1.3、id有相同也有不同，id相同说明为同一组，执行顺序由上而下，id不同，则id越大优先级越高越先执行。"></a>4.1.3、id有相同也有不同，id相同说明为同一组，执行顺序由上而下，id不同，则id越大优先级越高越先执行。</h4><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210512164742849.png" alt="image-20210512164742849"></p><p><font color='red'>注意：这里的<code>&lt;DERIVED&gt;</code>指的是衍生表，这里的2代表的是衍生表是来自id = 2 的结果。</font></p><h3 id="4-2、select-type"><a href="#4-2、select-type" class="headerlink" title="4.2、select_type"></a>4.2、select_type</h3><p>&emsp;&emsp;select_type  代表这个查询的类型，例如：普通查询、联合查询、子查询等等…</p><table><thead><tr><th align="center">select_type 属性</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">SIMPLE</td><td align="center">简单的 select 查询,查询中不包含子查询或者 UNION</td></tr><tr><td align="center">PRIMARY</td><td align="center">查询中若包含任何复杂的子部分， 最外层查询则被标记为 Primary</td></tr><tr><td align="center">DERIVED</td><td align="center">在 FROM 列表中包含的子查询被标记为 DERIVED(衍生) MySQL 会递归执行这些子查询, 把结果放在临时表里。</td></tr><tr><td align="center">SUBQUERY</td><td align="center">在SELECT或WHERE列表中包含了子查询</td></tr><tr><td align="center">DEPEDENT SUBQUERY</td><td align="center">在SELECT或WHERE列表中包含了子查询,子查询基于外层</td></tr><tr><td align="center">UNCACHEABLE SUBQUERY</td><td align="center">无法使用缓存的子查询</td></tr><tr><td align="center">UNION</td><td align="center">若第二个SELECT出现在UNION之后， 则被标记为UNION； 若UNION包含在FROM子句的子查询中,外层SELECT将被标记为： DERIVED</td></tr><tr><td align="center">UNION RESULT</td><td align="center">从UNION表获取结果的SELECT</td></tr></tbody></table><p>注意点：</p><p>&emsp;&emsp;这里SUBQUERY 和DEPEDENT SUBQUERY 都是指在SELECT或WHERE列表中包含了子查询，但是  SUBQUERY 指的是<strong>子查询只返回一个值</strong>，而DEPEDENT SUBQUERY指的是<strong>子查询返回一组值</strong>。</p><h3 id="4-3、type"><a href="#4-3、type" class="headerlink" title="4.3、type"></a>4.3、type</h3><p>&emsp;&emsp;type 是查询的访问类型。 是较为重要的一个指标， 结果值从最好到最坏依次是（常用）：  </p><p>&emsp;&emsp;&emsp;&emsp;<strong><font color='red'>system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt;  all</font></strong></p><p>一般来讲，至少要达到range级别，最好达到ref级别为佳。</p><h4 id="4-3-1、system"><a href="#4-3-1、system" class="headerlink" title="4.3.1、system"></a>4.3.1、system</h4><p>&emsp;&emsp;表只有一行记录（等于系统表）， 这是 const 类型的特列，平时不会出现，这个也可以忽略不计。</p><h4 id="4-3-2、const"><a href="#4-3-2、const" class="headerlink" title="4.3.2、const"></a>4.3.2、const</h4><p>&emsp;&emsp;表示<strong>通过索引一次就找到了</strong>,const 用于比较 primary key 或者 unique 索引。 因为只匹配一行数据， 所以很快。如将主键置于 where 列表中，MySQL 就能将该查询转换为一个常量。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210512171814263.png" alt="image-20210512171814263"></p><h4 id="4-3-3-eq-ref"><a href="#4-3-3-eq-ref" class="headerlink" title="4.3.3 eq_ref"></a>4.3.3 eq_ref</h4><p>&emsp;&emsp;唯一性索引扫描， 对于每个索引键， 表中<strong>只有一条记录与之匹配</strong>。 常见于主键或唯一索引扫描。</p><h4 id="4-3-4-ref"><a href="#4-3-4-ref" class="headerlink" title="4.3.4 ref"></a>4.3.4 ref</h4><p>&emsp;&emsp;非唯一性索引扫描，返回<strong>匹配某个单独值的所有行</strong>。本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行， 所以他应该属于查找和扫描的混合体。</p><h4 id="4-3-5、range"><a href="#4-3-5、range" class="headerlink" title="4.3.5、range"></a>4.3.5、range</h4><p>&emsp;&emsp;只检索给定范围的行，使用一个索引来选择行。key 列显示使用了哪个索引一般就是在你的 where 语句中出现了 between、 &lt;、 &gt;、 in 等的查询这种范围扫描索引扫描比全表扫描要好，因为它只需要**开始于索引的某一点，而结束语另一点，不用扫描全部索引 **。</p><h4 id="4-3-6、index"><a href="#4-3-6、index" class="headerlink" title="4.3.6、index"></a>4.3.6、index</h4><p>&emsp;&emsp;出现index是sql使用了索引但是没用通过索引进行过滤，一般是使用了<strong>覆盖索引</strong>或者是<strong>利用索引进行了排序分组</strong>。  </p><h4 id="4-3-7、all"><a href="#4-3-7、all" class="headerlink" title="4.3.7、all"></a>4.3.7、all</h4><p>&emsp;&emsp;Full Table Scan， 将遍历全表以找到匹配的行 。</p><h3 id="4-4、possible-keys-与-key-与key-len"><a href="#4-4、possible-keys-与-key-与key-len" class="headerlink" title="4.4、possible_keys  与 key 与key_len"></a>4.4、possible_keys  与 key 与key_len</h3><p>&emsp;&emsp;possible_key指的是显示可能应用在这张表中的索引， 一个或多个。 查询涉及到的字段上若存在索引， 则该索引将被列出， <font color='red'>但不一定被查询实际使用</font>。  </p><p>&emsp;&emsp;key指的是实际使用的索引。 如果为NULL， 则没有使用索引 。  </p><p>&emsp;&emsp;key_len表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。key_len 字段能够帮你检查是否充分的利用上了索引。ken_len 越长，说明索引使用的越充分 ，在查询结果相同的条件下，key_len越小越好。</p><h3 id="4-5、ref"><a href="#4-5、ref" class="headerlink" title="4.5、ref"></a>4.5、ref</h3><p>&emsp;&emsp;ref指的是索引的哪一列被使用了， 如果可能的话， 是一个常数（const）。 哪些列或常量被用于查找索引列上的值。  在有索引被使用的情况下，如果显示是const，说明索引指向的列对应的值是一个或一组固定值，否则则会反馈某个数据库的某张表的某个字段。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210512230257787.png" alt="image-20210512230257787"></p><h3 id="4-6、rows"><a href="#4-6、rows" class="headerlink" title="4.6、rows"></a>4.6、rows</h3><p>&emsp;&emsp;rows表示的是根据表统计信息及索引使用情况，大致会估算出找到所需记录所需要读取的行数，这个行数越小越好。</p><h3 id="4-7、Extra"><a href="#4-7、Extra" class="headerlink" title="4.7、Extra"></a>4.7、Extra</h3><p>&emsp;&emsp;其他额外的重要信息。</p><h4 id="4-7-1、Using-filesort"><a href="#4-7-1、Using-filesort" class="headerlink" title="4.7.1、Using filesort"></a><font color='red'>4.7.1、Using filesort</font></h4><p>&emsp;&emsp;SQL语句出现Using filesort，说明 MySQL 会对数据使用一个外部的索引排序， 而不是按照表内的索引顺序进行读取。 MySQL 中无法利用索引完成的排序操作称为“文件排序”  。</p><p>&emsp;&emsp;Using filesort是我们不希望出现的，可能是在排序时因为没有索引导致发生了外部排序，而外部排序是非常慢的。所以在查询中需要尽量避免发生这种情况。</p><h4 id="4-7-2、Using-temporary"><a href="#4-7-2、Using-temporary" class="headerlink" title="4.7.2、Using temporary "></a><font color='red'>4.7.2、Using temporary </font></h4><p>&emsp;&emsp;Using temporary指的是使了用临时表保存中间结果,MySQL 在对查询结果排序时使用临时表。 一般出现在多张表的数据需要排序的情况下，MySQL会先使用using temporary保存临时数据, 然后再在临时表上使用filesort进行排序。</p><p>&emsp;&emsp;Using temporary这种情况也是我们需要尽力避免的，他最经常出现在是在排序时因为没有索引或查询和排序的顺序不当导致没有使用到MySQL索引，导致在临时表中进行排序【引起Using filesort】，所以在查询中需要尽量避免发生这种情况。</p><h4 id="4-7-3、Using-index"><a href="#4-7-3、Using-index" class="headerlink" title="4.7.3、Using index"></a><font color='red'>4.7.3、Using index</font></h4><p>&emsp;&emsp;Using index 代表表示相应的 select 操作中使用了覆盖索引(Covering Index)， 避免访问了表的数据行， 效率是高的。如果同时出现 using where，表明索引被用来执行索引键值的查找；如果没有同时出现 using where， 则表明索引只是用来读取数据而非利用索引执行查找。  </p><h4 id="4-7-4、其他"><a href="#4-7-4、其他" class="headerlink" title="4.7.4、其他"></a>4.7.4、其他</h4><table><thead><tr><th>信息</th><th>含义</th></tr></thead><tbody><tr><td>Using where</td><td>使用了 where 过滤</td></tr><tr><td>Using index condition</td><td>使用了索引下推</td></tr><tr><td>Using join buffer</td><td>使用了连接缓存</td></tr><tr><td>impossible where</td><td>where 子句的值总是 false， 不能用来获取任何元组</td></tr><tr><td>select tables optimized away</td><td>在没有 GROUPBY 子句的情况下， 基于索引优化 MIN/MAX 操作或者对于MyISAM 存储引擎优化 COUNT(*)操作，不必等到执行阶段再进行计算， 查询执行计划生成的阶段即完成优化。</td></tr></tbody></table><h2 id="5、单表使用索引常见的索引失效"><a href="#5、单表使用索引常见的索引失效" class="headerlink" title="5、单表使用索引常见的索引失效"></a>5、单表使用索引常见的索引失效</h2><h3 id="5-1、优化查询顺序，减少-的使用"><a href="#5-1、优化查询顺序，减少-的使用" class="headerlink" title="5.1、优化查询顺序，减少 * 的使用"></a>5.1、优化查询顺序，减少 * 的使用</h3><p>&emsp;&emsp;SQL 中查询字段的顺序，跟使用索引中字段的顺序并没有直接关系。 优化器会在不影响 SQL 执行结果的前提下，会给你自动地优化。当然，我们在查询时尽量和索引保持一致。同时，我们尽量减少使用 *  的情况，需要什么字段，就返回什么字段，这样子可以产生索引覆盖，高效查询。  </p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210514171506197.png" alt="image-20210514171506197"></p><h3 id="5-2、最佳左前缀法则"><a href="#5-2、最佳左前缀法则" class="headerlink" title="5.2、最佳左前缀法则"></a><font color='red'>5.2、最佳左前缀法则</font></h3><p>&emsp;&emsp;过滤条件要使用索引必须按照索引建立时的顺序， 依次满足， 一旦跳过某个字段， 该索引后面的字段都无法被使用。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210514172712512.png" alt="image-20210514172712512"></p><h3 id="5-3、不要在索引列上做任何计算"><a href="#5-3、不要在索引列上做任何计算" class="headerlink" title="5.3、不要在索引列上做任何计算"></a>5.3、不要在索引列上做任何计算</h3><p>&emsp;&emsp;不要在索引列上做任何操作（计算、 函数、 (自动 or 手动)类型转换）， 会导致索引失效而转向全表扫描。  </p><h4 id="5-3-1、不要在sql中使用函数"><a href="#5-3-1、不要在sql中使用函数" class="headerlink" title="5.3.1、不要在sql中使用函数"></a>5.3.1、不要在sql中使用函数</h4><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210514172939992.png" alt="image-20210514172939992"></p><h4 id="5-3-2、在查询上进行转换"><a href="#5-3-2、在查询上进行转换" class="headerlink" title="5.3.2、在查询上进行转换"></a>5.3.2、在查询上进行转换</h4><p>&emsp;&emsp;这里演示的就是在一个varchar字段上使用了数字，不带引号，虽然能够查询，但是系统会进行隐式自动转换，导致索引失效。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210515162029879.png" alt="image-20210515162029879"></p><h3 id="5-4、索引上尽量减少范围查询"><a href="#5-4、索引上尽量减少范围查询" class="headerlink" title="5.4、索引上尽量减少范围查询"></a>5.4、索引上尽量减少范围查询</h3><p>&emsp;&emsp;尽量减少范围查询或者把范围查询放在最后，保证索引能够被充分使用。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210515164532352.png" alt="image-20210515164532352"></p><h3 id="5-5、索引上尽量减少使用-或-lt-gt"><a href="#5-5、索引上尽量减少使用-或-lt-gt" class="headerlink" title="5.5、索引上尽量减少使用 != 或 &lt;&gt;"></a>5.5、索引上尽量减少使用 != 或 &lt;&gt;</h3><p>&emsp;&emsp;&emsp;尽量减少!= 或 &lt;&gt; 查询或者把此类查询放在最后，保证索引能够被充分使用。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210515165122325.png" alt="image-20210515165122325"></p><h3 id="5-6、索引的-is-null-和-is-not-null"><a href="#5-6、索引的-is-null-和-is-not-null" class="headerlink" title="5.6、索引的 is null 和 is not null"></a>5.6、索引的 is null 和 is not null</h3><p>&emsp;&emsp;当字段允许为null的情况下，使用 is null 会使用索引，而使用 is not null  不会使用索引。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210515174831815.png" alt="image-20210515174831815"></p><h3 id="5-7、like模糊查询"><a href="#5-7、like模糊查询" class="headerlink" title="5.7、like模糊查询"></a>5.7、like模糊查询</h3><p>&emsp;&emsp;当时用like模糊查询时，前缀尽量不要使用模糊匹配，否则会导致索引失效。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210515175936971.png" alt="image-20210515175936971"></p><h3 id="5-8、减少-or-的使用"><a href="#5-8、减少-or-的使用" class="headerlink" title="5.8、减少 or 的使用"></a>5.8、减少 or 的使用</h3><p>&emsp;&emsp;使用 or 也会造成索引失效，所以可以考虑使用 union 或 union all 来代替。【这个在5.7版本测试中并未出现，了解即可】</p><h3 id="5-9、索引下推"><a href="#5-9、索引下推" class="headerlink" title="5.9、索引下推"></a><font color='red'>5.9、索引下推</font></h3><p>&emsp;&emsp;索引条件下推优化（Index Condition Pushdown (ICP) ）是MySQL5.6添加的，用于优化数据查询。那么索引下推能优化啥？</p><blockquote><p><strong>索引的查询过程</strong></p><p>没有使用索引下推：</p><p>1、获取下一行，首先读取索引信息，然后根据索引将整行数据读取出来。</p><p>2、然后通过where条件判断当前数据是否符合条件，符合返回数据。</p><p>使用索引下推：</p><p>1、获取下一行的索引信息。</p><p>2、检查<strong>索引中存储的列信息是否符合索引条件</strong>，如果符合再将整行数据读取出来，如果不符合跳过读取下一行。</p><p>3、用剩余的判断条件，判断此行数据是否符合要求，符合要求返回数据。</p></blockquote><p>&emsp;&emsp;再具体举一个例子：有一个索引name、age的复合索引，现在查询 select * from table where age = 10 and sex = 1；那么此时查询的时候，如果使用了索引下推，那么在查询索引的时候会同时判断age是不是等于10，是的话才会回表去查询这条结果，然后把返回的结果集再去查询其他sex = 1的条件。</p><p>&emsp;&emsp;当使用explan进行分析时，如果使用了索引条件下推，Extra会显示<strong>Using index condition</strong>。通过这样的操作，<strong>充分利用了索引中的数据，尽量在查询出整行数据之前过滤掉无效的数据</strong>。</p><h2 id="6、关联查询优化"><a href="#6、关联查询优化" class="headerlink" title="6、关联查询优化"></a>6、关联查询优化</h2><p>关于联表查询的优化，最重要的就是**<font color='red'>在满足业务需求的条件下</font>，永远小表驱动大表，即小的数据集驱动大的数据集**。</p><h3 id="6-1、left-join-与-right-join"><a href="#6-1、left-join-与-right-join" class="headerlink" title="6.1、left join 与 right join"></a>6.1、left join 与 right join</h3><p>&emsp;&emsp;在优化关联查询【left join 与 right join】时，只有将索引建立在被驱动表上才会生效。例如在左连接上，左表驱动右表，所以右表为被驱动表，所以索引应建立在右表上。同理，右连接时，索引应该建立在左表上。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210516184531479.png" alt="image-20210516184531479"></p><h3 id="6-2、inner-join"><a href="#6-2、inner-join" class="headerlink" title="6.2、inner join"></a>6.2、inner join</h3><p>&emsp;&emsp;使用inner join 时， MySQL 会自己帮你把小结果集的表选为驱动表 。如果使用straight_join，虽然效果和 inner join 一样， 但是会强制将左侧作为驱动表！  </p><h3 id="6-3、子查询（in-和-exists的使用）"><a href="#6-3、子查询（in-和-exists的使用）" class="headerlink" title="6.3、子查询（in 和 exists的使用）"></a>6.3、子查询（in 和 exists的使用）</h3><blockquote><p> 假设有两张表 A 和 B ，分别对 A 和 B 建立 id 索引，那么：</p><p><strong>当 B 的数据集永远比 A 小时，使用 in 更优于 exists</strong></p><p>SELECT * FROM A WHERE id IN (SELECT id FROM B);</p><p>等价于</p><p>FOR SELECT id FROM B<br>FOR SELECT * FROM A WHERE A.id = B.id;</p><p><strong>当 A 的数据集永远比 B 小时，使用 exists 更优于 in</strong></p><p>SELECT * FROM A WHERE id EXISTS (SELECT 1 FROM B WHERE B.id = A.id);</p><p>等价于</p><p>FOR SELECT * FROM A<br>FOR SELECT * FROM B WHERE A.id = B.id;</p></blockquote><p>&emsp;&emsp;对于exists的操作，我们可以这么理解：将主查询的数据，放到子查询中做条件验证，根据验证结果（TRUE or FALSE）来决定主查询中的结果是否保留。这里我们要注意 exists 的子查询语句中不管是 select 什么内容，其结果只会返回 TRUE or FALSE，不会返回其他内容。</p><h2 id="7、排序和分组优化"><a href="#7、排序和分组优化" class="headerlink" title="7、排序和分组优化"></a>7、排序和分组优化</h2><p>&emsp;&emsp;排序和分组也是可以通过索引来优化的。</p><p>&emsp;&emsp;之所以排序是可以通过索引优化，是由于Innodb底层是B+Tree，B+Tree的叶子节点是相互指向的、有序的，并且数据都附着在叶子结点的主键上，所以order by主键索引时，直接取出有序数据即可，效率很高。而分组是因为要先进行排序，再按组分配，所以也可以通过索引进行优化。</p><h3 id="7-1、order-by-的优化"><a href="#7-1、order-by-的优化" class="headerlink" title="7.1、order by 的优化"></a>7.1、order by 的优化</h3><p>&emsp;&emsp;对于order by 的优化，最优先的还是给<strong>order by子句的字段建立索引并满足索引最左前缀原则</strong>或者<strong>Where子句和order by子句的条件组合满足索引最左前缀原则</strong>。使排序操作在索引中进行。但是，在现实情况下，不一定能够在索引中进行排序，那么就会出现<strong>filesort</strong>，而filesort有两种算法：</p><h4 id="7-1-1、双路排序"><a href="#7-1-1、双路排序" class="headerlink" title="7.1.1、双路排序"></a>7.1.1、双路排序</h4><p>&emsp;&emsp;双路排序就是两次扫描磁盘才能获得数据，先读取需要排序的列和行指针，再进行排序，扫描排序好的列表再按照顺序从磁盘中获取其他字段。</p><h4 id="7-1-2、单路排序"><a href="#7-1-2、单路排序" class="headerlink" title="7.1.2、单路排序"></a>7.1.2、单路排序</h4><p>&emsp;&emsp;单路排序就是从磁盘中读取需要的所有列，按照排序的列进行排序，最后扫描排序好的列表进行输出。它相对于双路排序，避免了第二次查询的io操作，但是它会占用更多的空间，因为它获取了所有数据。但是由于sort_buffer的容量有限，如果读取的数据超过了buffer的默认大小262144B（256KB），会造成需要多次读取，创建templ文件再进行合并排序，io次数反而增加，性能下降；</p><p>&emsp;&emsp;所以单路排序的使用条件是：查询的字段总大小小于max_length_for_sort_data的限制值（1024B），且排序字段不是TEXT|BLOB时，才会使用单路排序。</p><blockquote><p>优化总结：</p><ol><li>可以通过调整sort_buffer_size、sort_buffer_size的大小来进行优化；</li><li>不管单路还是双路，提高sort_buffer_size都能提高效率，但需要根据系统能力去调整；</li><li>提高max_length_for_sort_data的大小会影响使用何种排序算法。</li></ol></blockquote><h3 id="7-2、group-by-的优化"><a href="#7-2、group-by-的优化" class="headerlink" title="7.2、group by 的优化"></a>7.2、group by 的优化</h3><p>&emsp;&emsp;我们上面也讲到，group by分组的实现是先进行排序再进行分组，所以上面 order by 的优化均适用于group by。此外，由于where优先级高于having，所以能写在where限定的条件就不要去having限定了。</p><h1 id="四、查询截取分析"><a href="#四、查询截取分析" class="headerlink" title="四、查询截取分析"></a>四、查询截取分析</h1><h2 id="1、慢查询日志"><a href="#1、慢查询日志" class="headerlink" title="1、慢查询日志"></a>1、慢查询日志</h2><h3 id="1-1、什么是慢查询日志？"><a href="#1-1、什么是慢查询日志？" class="headerlink" title="1.1、什么是慢查询日志？"></a>1.1、什么是慢查询日志？</h3><p>&emsp;&emsp;慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阈值的语句，具体指运行时间超过<strong>long_query_time</strong>值的SQL，则会被记录到慢查询日志中。</p><h3 id="1-2、如何使用？"><a href="#1-2、如何使用？" class="headerlink" title="1.2、如何使用？"></a>1.2、如何使用？</h3><p>&emsp;&emsp;在默认情况下， MySQL 数据库没有开启慢查询日志， 需要我们手动来设置这个参数。当然， 如果不是调优需要的话， 一般不建议启动该参数， 因为<strong>开启慢查询日志会或多或少带来一定的性能影响</strong>。</p><table><thead><tr><th>SQL 语句</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td>SHOW VARIABLES LIKE ‘%slow_query_log%’;</td><td>查看慢查询日志是否开启</td><td>默认情况下 slow_query_log 的值为 OFF， 表示慢查询日志是禁用的</td></tr><tr><td>set global slow_query_log=1;</td><td>开启慢查询日志</td><td></td></tr><tr><td>SHOW VARIABLES LIKE ‘long_query_time%’;</td><td>查看慢查询设定阈值</td><td>单位：秒</td></tr><tr><td>set long_query_time=1</td><td>设定慢查询阈值</td><td>单位：秒</td></tr></tbody></table><p>&emsp;&emsp;注意：设置新的阈值后进行查询可能没有发生变化，需要重新连接或者新开一个会话才能看到修改值。或者执行查询全局<code>show global variables like &#39;long_query_time&#39;;</code>进行查看。</p><p>&emsp;&emsp;当使用慢查询日志一段时间后，我们就可以通过<code>show global status like &#39;%Slow_queries%;&#39;</code>查询系统中存在多少条慢查询的sql。然后就可以拿出来进行分析改造…</p><h2 id="2、日志分析工具-MySQLdumpslow"><a href="#2、日志分析工具-MySQLdumpslow" class="headerlink" title="2、日志分析工具 MySQLdumpslow"></a>2、日志分析工具 MySQLdumpslow</h2><p>&emsp;&emsp;MySQLdumpslow是MySQL提供的能够查找、分析日志的工具，可以方便我们获取需要优化的sql。下面是该工具的一些参数说明：</p><table><thead><tr><th>参数</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td>-s</td><td>是表示按照何种方式排序</td><td></td></tr><tr><td>c</td><td>访问次数</td><td></td></tr><tr><td>l</td><td>锁定时间</td><td></td></tr><tr><td>r</td><td>返回记录</td><td></td></tr><tr><td>t</td><td>查询时间</td><td></td></tr><tr><td>al</td><td>平均锁定时间</td><td></td></tr><tr><td>ar</td><td>平均返回记录数</td><td></td></tr><tr><td>at</td><td>平均查询时间</td><td></td></tr><tr><td>-t</td><td>即为返回前面多少条的数据</td><td></td></tr><tr><td>-g</td><td>后边搭配一个正则匹配模式， 大小写不敏感的</td><td></td></tr></tbody></table><blockquote><p>一些常用的指令：</p><p>得到返回记录集最多的 10 个 SQL<br>MySQLdumpslow -s r -t 10 /var/lib/MySQL/xxx-slow.log</p><p>得到访问次数最多的 10 个 SQL<br>MySQLdumpslow -s c -t 10 /var/lib/MySQL/xxx-slow.log</p><p>得到按照时间排序的前 10 条里面含有左连接的查询语句<br>MySQLdumpslow -s t -t 10 -g “left join” /var/lib/MySQL/xxx-slow.log</p><p>另外建议在使用这些命令时结合 | 和 more 使用 ， 否则有可能出现爆屏情况<br>MySQLdumpslow -s r -t 10 /var/lib/MySQL/xxx-slow.log | more  </p></blockquote><h2 id="3、show-profiles"><a href="#3、show-profiles" class="headerlink" title="3、show profiles"></a>3、show profiles</h2><h3 id="3-1、show-profiles是什么？"><a href="#3-1、show-profiles是什么？" class="headerlink" title="3.1、show profiles是什么？"></a>3.1、show profiles是什么？</h3><p>&emsp;&emsp;show profiles是MySQL提供可以用来分析当前会话中语句执行的资源消耗情况。可以用于SQL的调优测量。</p><p>具体可以参考官网【<a href="http://dev.mysql.com/doc/refman/5.7/en/show-profile.html">链接</a>】。</p><h3 id="3-2、show-profiles的使用"><a href="#3-2、show-profiles的使用" class="headerlink" title="3.2、show profiles的使用"></a>3.2、show profiles的使用</h3><p>&emsp;&emsp;在默认情况下，show profiles默认不开启使用，我们可以通过命令<code>show variables like &#39;profiling&#39;</code>查询开启状态。如果需要打开，则执行<code>set profiling=on</code>。</p><p>&emsp;&emsp;在执行sql之后，执行<code>show profiles;</code>命令获取执行过的sql的id，然后再执行<code>show profile cpu,block io for query id;</code>获取对应信息。这里的参数类型有：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210518173211416.png" alt="image-20210518173211416"></p><p>&emsp;&emsp;查询效果展示：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210519214301006.png" alt="image-20210519214301006"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210519214934610.png" alt="image-20210519214934610"></p><h3 id="3-3、为日常开发需要注意的结论"><a href="#3-3、为日常开发需要注意的结论" class="headerlink" title="3.3、为日常开发需要注意的结论"></a>3.3、为日常开发需要注意的结论</h3><blockquote><p>a、converting HEAP to MyISAM；查询结果太大，内存不够了，开始往磁盘上搬了</p><p>b、Creating tmp table ；创建了临时表</p><p>c、Copying to tmp table on disk; 把内存中的临时表保存到磁盘上！！</p><p>d、locked</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 原理 </tag>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC（下）</title>
      <link href="/blog/2021/05/04/JUC%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/blog/2021/05/04/JUC%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h1><h1 id="六、线程池"><a href="#六、线程池" class="headerlink" title="六、线程池"></a>六、线程池</h1><h2 id="1、什么是线程池？为什么要使用线程池？"><a href="#1、什么是线程池？为什么要使用线程池？" class="headerlink" title="1、什么是线程池？为什么要使用线程池？"></a>1、什么是线程池？为什么要使用线程池？</h2><p>&emsp;&emsp;在前面的介绍中，我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题：如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务，有的，我们可以使用<strong>线程池</strong>来管理我们操作的线程。</p><h3 id="1-1、线程池的优势"><a href="#1-1、线程池的优势" class="headerlink" title="1.1、线程池的优势"></a>1.1、线程池的优势</h3><ul><li><font color='red'>降低系统资源消耗</font>，通过重用已存在的线程，降低线程创建和销毁造成的消耗；</li><li><font color='red'>提高系统响应速度</font>，当有任务到达时，通过复用已存在的线程，无需等待新线程的创建便能立即执行；</li><li><font color='red'>方便线程并发数的管控</font>。因为线程若是无限制的创建，可能会导致内存占用过多而产生OOM，并且会造成cpu过度切换（cpu切换线程是有时间成本的（需要保持当前执行线程的现场，并恢复要执行线程的现场））;</li><li><font color='red'>提供更强大的功能，延时定时线程池</font>。</li></ul><h2 id="2、创建线程池的方法"><a href="#2、创建线程池的方法" class="headerlink" title="2、创建线程池的方法"></a>2、创建线程池的方法</h2><p>&emsp;&emsp;默认线程池的创建方法有四种，主要是由Executors来进行创建：</p><blockquote><p>1、 newSingleThreadExecutor()：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行；</p><p>2、newFixedThreadPool(int n)：创建一个可重用固定个数的线程池，以共享的无界队列方式来运行这些线程；</p><p>3、newScheduledThreadPool(int n)：创建一个定长线程池，支持定时及周期性任务执行；</p><p>4、newCacheThreadPool()：可缓存线程池，先查看池中有没有以前建立的线程，如果有，就直接使用。如果没有，就建一个新的线程加入池中，缓存型池子通常用于执行一些生存期很短的异步型任务。</p></blockquote><p>&emsp;&emsp;这里需要注意：在使用完线程池之后，记得要<strong>关闭线程池！!</strong></p><h3 id="2-1、测试代码"><a href="#2-1、测试代码" class="headerlink" title="2.1、测试代码"></a>2.1、测试代码</h3><h4 id="2-1-1、单线程的线程池"><a href="#2-1-1、单线程的线程池" class="headerlink" title="2.1.1、单线程的线程池"></a>2.1.1、单线程的线程池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">simple</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ok&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210430160628319.png" alt="image-20210430160628319"></p><h4 id="2-1-2、可重用固定个数的线程池"><a href="#2-1-2、可重用固定个数的线程池" class="headerlink" title="2.1.2、可重用固定个数的线程池"></a>2.1.2、可重用固定个数的线程池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fixed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ok&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210430162614502.png" alt="image-20210430162614502"></p><h4 id="2-1-3、定长线程池"><a href="#2-1-3、定长线程池" class="headerlink" title="2.1.3、定长线程池"></a>2.1.3、定长线程池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">time</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ScheduledExecutorService executorService = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        executorService.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;延迟1秒后每3秒执行一次&quot;</span>);</span><br><span class="line">        &#125;,<span class="number">1</span>,<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210501115356517.png" alt="image-20210501115356517"></p><h4 id="2-1-4、可缓存线程池"><a href="#2-1-4、可缓存线程池" class="headerlink" title="2.1.4、可缓存线程池"></a>2.1.4、可缓存线程池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ok&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210430162943529.png" alt="image-20210430162943529"></p><h3 id="2-2、创建线程池的七大参数"><a href="#2-2、创建线程池的七大参数" class="headerlink" title="2.2、创建线程池的七大参数"></a>2.2、创建线程池的七大参数</h3><p>&emsp;&emsp;我们发现，阿里巴巴官方并不推荐使用Executors这种方式来创建线程池，原因是要<font color='red'>防止OOM【Java内存溢出】</font>，所以官方更推荐使用Executors的底层<font color='red'>ThreadPoolExecutor</font>这种方式来创建线程池。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210501115805200.png" alt="image-20210501115805200"></p><p>&emsp;&emsp;说到线程池，那么其最重要的就是有<strong>七个参数和四大拒绝策略</strong>，那么我们先以一个简单的例子来理解这七个参数。我们的线程池其实就像是银行办理业务，按照正常情况银行的窗口一般不会开满，如下：总共有5个窗口，但常开的窗口就只有2个，这就类比了线程池的<strong>核心线程数和最大线程数</strong>，当日常办理业务人数不多时，我们只需要开放核心的窗口办理业务即可，当有更多的人进来了，那么就先安排他们到等待区进行等待，这对应了线程池的<strong>BlockingQueue队列</strong>，用来设置等待区的大小。当等待区也填满了，那么此时就需要开放其他窗口，直至开放到最大窗口值，那么此时如果还有客户进来，那么我们就需要考虑使用怎样的方式来拒绝，这就类比线程池中的<strong>拒绝策略</strong>。此外，当办理业务的人数少了之后，等待一段时间后，除了核心线程以外的其他线程就需要被释放掉，要不然也是浪费资源，这就对应了线程池的<strong>超时时间和超时时间单位</strong>，当到达某个时间后，多余的线程就被释放掉。</p><p>&emsp;&emsp;总结一下，创建线程池总共需要七个参数，分别是：核心线程数、最大线程数、超时时间、超时时间单位、BlockingQueue队列、线程工厂和拒绝策略。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210501152059445.png" alt="image-20210501152059445"></p><h3 id="2-3、线程池的四大拒绝策略"><a href="#2-3、线程池的四大拒绝策略" class="headerlink" title="2.3、线程池的四大拒绝策略"></a>2.3、线程池的四大拒绝策略</h3><blockquote><p>不处理这个任务的，直接抛出异常 </p><p>new ThreadPoolExecutor.AbortPolicy() ；</p><p>不处理这个任务的，不会抛出异常</p><p>new ThreadPoolExecutor.DiscardPolicy() ；</p><p>将该任务返回给调用线程执行，例如是由main线程发起这个任务，那就由main线程执行</p><p>new ThreadPoolExecutor.CallerRunsPolicy() ；</p><p>尝试去和最早的任务竞争，即使尝试失败也不会抛出异常  </p><p>new ThreadPoolExecutor.DiscardOldestPolicy() ；</p></blockquote><h3 id="2-4、测试代码"><a href="#2-4、测试代码" class="headerlink" title="2.4、测试代码"></a>2.4、测试代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;(<span class="number">3</span>),</span><br><span class="line">            Executors.defaultThreadFactory(), <span class="keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ok&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        threadPoolExecutor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、拓展"><a href="#3、拓展" class="headerlink" title="3、拓展"></a>3、拓展</h2><p>问题：如何设置线程池最大线程数这个参数？？【调优】</p><p>&emsp;&emsp;有两个考虑方向：IO密集型和CPU密集型。</p><p>&emsp;&emsp;对于CPU密集型，就是判断系统的核数，是多少就设置多少，保证CPU的效率最高，在Java代码中，可以通过<code>Runtime.getRuntime().availableProcessors()  </code>获取CPU的核数。</p><p>&emsp;&emsp;对于IO密集型，就是判断程序中非常消耗IO的任务数量，根据该数量去设置最大线程数（一般为2倍大小即可），保证15个任务在操作的时候还有额外的线程去操作其他业务。</p><p>Lambda表达式和stream流参考：[<a href="http://cheng_qiwei.gitee.io/blog/2021/05/02/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8F%8AStream%E6%B5%81/">链接</a>]</p><h1 id="七、ForkJoin"><a href="#七、ForkJoin" class="headerlink" title="七、ForkJoin"></a>七、ForkJoin</h1><h2 id="1、什么是ForkJoin？"><a href="#1、什么是ForkJoin？" class="headerlink" title="1、什么是ForkJoin？"></a>1、什么是ForkJoin？</h2><ul><li><strong>Fork</strong>：把一个复杂任务进行分拆，大事化小</li><li><strong>Join</strong>：把分拆任务的结果进行合并</li></ul><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210504001056860.png" alt="image-20210504001056860"></p><h2 id="2、ForkJoin原理"><a href="#2、ForkJoin原理" class="headerlink" title="2、ForkJoin原理"></a>2、ForkJoin原理</h2><p>&emsp;&emsp;分而治之：规模为N的问题，N&lt;阈值，直接解决，N&gt;阈值，将N分解为K个小规模子问题，子问题互相对立，与原问题形式相同，将子问题的解合并得到原问题的解。</p><p>ForkJoin有一个特点就是<strong>工作窃取（工作密取）</strong><br>&emsp;&emsp;在每个小规模里面的问题解决完之后，会从别的地方后面拿取处理完成并归还。也是由于这个特点，所以ForkJoin维护的是一个个双端队列，当有一个子任务执行结束后，它会去其他子任务中反向拿取一个任务执行并归还。</p><h2 id="3、ForkJoin相关类"><a href="#3、ForkJoin相关类" class="headerlink" title="3、ForkJoin相关类"></a>3、ForkJoin相关类</h2><p>3.1、分支合并池    类比于   线程池</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210504153254861.png" alt="image-20210504153254861"></p><p>3.2、ForkJoinTask    类比于   FutureTask</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210504153345283.png" alt="image-20210504153345283"></p><p>3.3、递归任务：继承后可以实现递归(自己调自己)调用的任务</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210504153414665.png" alt="image-20210504153414665"></p><h2 id="4、测试代码"><a href="#4、测试代码" class="headerlink" title="4、测试代码"></a>4、测试代码</h2><p>测试目标：计算从1到10亿的和，并输出其消耗的时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通解</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Long sum = <span class="number">0L</span>;</span><br><span class="line">    Long startTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (Long i = start; i &lt;= end; i++) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    Long endTime = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;计算结果为：&quot;</span>+ sum +<span class="string">&quot; 消耗时间为：&quot;</span> + (endTime - startTime) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line">计算结果为：<span class="number">500000000500000000</span> 消耗时间为：5891ms</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建ForkJoin任务类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SumTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//设置开始值</span></span><br><span class="line">    <span class="keyword">private</span> Long start;</span><br><span class="line">    <span class="comment">//设置结束值</span></span><br><span class="line">    <span class="keyword">private</span> Long end;</span><br><span class="line">    <span class="comment">//设置临界值</span></span><br><span class="line">    <span class="keyword">private</span> Long temp = <span class="number">10000L</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SumTask</span><span class="params">(Long start, Long end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((end - start) &lt; temp)&#123;</span><br><span class="line">            Long sum = <span class="number">0L</span>;</span><br><span class="line">            <span class="keyword">for</span> (Long i = start; i &lt;= end; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            Long middle = (start + end)/<span class="number">2</span>;</span><br><span class="line">            SumTask sumTask1 = <span class="keyword">new</span> SumTask(start, middle);</span><br><span class="line">            sumTask1.fork();</span><br><span class="line">            SumTask sumTask2 = <span class="keyword">new</span> SumTask(middle + <span class="number">1</span>, end);</span><br><span class="line">            sumTask2.fork();</span><br><span class="line">            <span class="keyword">return</span> sumTask1.join() + sumTask2.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用forkJoin进行求和</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    Long sum = <span class="number">0L</span>;</span><br><span class="line">    Long startTime = System.currentTimeMillis();</span><br><span class="line">    ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">    SumTask sumTask = <span class="keyword">new</span> SumTask(start, end);</span><br><span class="line">    ForkJoinTask&lt;Long&gt; result = pool.submit(sumTask);</span><br><span class="line">    sum = result.get();</span><br><span class="line">    Long endTime = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;计算结果为：&quot;</span>+ sum +<span class="string">&quot; 消耗时间为：&quot;</span> + (endTime - startTime) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line">计算结果为：<span class="number">500000000500000000</span> 消耗时间为：5510ms</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Stream并行流</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Long sum = <span class="number">0L</span>;</span><br><span class="line">    Long startTime = System.currentTimeMillis();</span><br><span class="line">    sum = LongStream.rangeClosed(start, end).parallel().reduce(<span class="number">0</span>, Long::sum);</span><br><span class="line">    Long endTime = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;计算结果为：&quot;</span>+ sum +<span class="string">&quot; 消耗时间为：&quot;</span> + (endTime - startTime) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line">计算结果为：<span class="number">500000000500000000</span> 消耗时间为：107ms</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;由此可见，ForkJoin对于提高性能还是有一定的效果。</p><h1 id="八、异步回调"><a href="#八、异步回调" class="headerlink" title="八、异步回调"></a>八、异步回调</h1><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210504164356076.png" alt="image-20210504164356076"></p><p>Future类 设计的初衷： 对将来的某个事件的结果进行建模  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.g4b.juc.sync;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;成功返回结果！&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; <span class="number">6</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;等待了&quot;</span>+ i++ +<span class="string">&quot;s&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;等待了6秒，结束等待&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String result = future.whenComplete((t, u) -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;返回t：&quot;</span> + t);</span><br><span class="line">                    System.out.println(<span class="string">&quot;返回u：&quot;</span> + u);</span><br><span class="line">                &#125;).exceptionally((e) -&gt; &#123;</span><br><span class="line">                    <span class="keyword">return</span> e.getMessage();</span><br><span class="line">                &#125;).get();</span><br><span class="line">                System.out.println(<span class="string">&quot;获取返回结果：&quot;</span>+result);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line">等待了1s</span><br><span class="line">等待了2s</span><br><span class="line">等待了3s</span><br><span class="line">等待了4s</span><br><span class="line">等待了5s</span><br><span class="line">等待了<span class="number">6</span>秒，结束等待</span><br><span class="line">返回t：成功返回结果！</span><br><span class="line">返回u：<span class="keyword">null</span></span><br><span class="line">获取返回结果：成功返回结果！</span><br><span class="line">    </span><br><span class="line"><span class="comment">//异常情况的执行结果</span></span><br><span class="line">等待了1s</span><br><span class="line">等待了2s</span><br><span class="line">等待了3s</span><br><span class="line">等待了4s</span><br><span class="line">等待了5s</span><br><span class="line">等待了<span class="number">6</span>秒，结束等待</span><br><span class="line">返回t：<span class="keyword">null</span></span><br><span class="line">返回u：java.util.concurrent.CompletionException: java.lang.ArithmeticException: / by zero</span><br><span class="line">获取返回结果：java.lang.ArithmeticException: / by zero</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们可以看到，在执行等待的过程中，我们定义的异步任务也执行了。而异常情况下，则会返回我们的异常结果。</p><h1 id="九、volatile关键字与内存可见性"><a href="#九、volatile关键字与内存可见性" class="headerlink" title="九、volatile关键字与内存可见性"></a>九、volatile关键字与内存可见性</h1><h2 id="1、什么是volatile？"><a href="#1、什么是volatile？" class="headerlink" title="1、什么是volatile？"></a>1、什么是volatile？</h2><p>&emsp;&emsp;volatile是Java虚拟机提供的轻量级的同步机制。</p><h2 id="2、volatile的三个特性："><a href="#2、volatile的三个特性：" class="headerlink" title="2、volatile的三个特性："></a>2、volatile的三个特性：</h2><p>&emsp;&emsp;a、保证可见性；</p><p>&emsp;&emsp;b、<font color='red'>不</font>保证原子性；</p><p>&emsp;&emsp;c、禁止指令重排。</p><h2 id="3、什么是JMM？"><a href="#3、什么是JMM？" class="headerlink" title="3、什么是JMM？"></a>3、什么是JMM？</h2><p>&emsp;&emsp;要了解volatile，首先需要了解JMM，那JMM到底是什么呢？</p><p>&emsp;&emsp;在了解JMM之前，我们先了解一下现代计算机的内存模型，其实在早期计算机中cpu和内存的速度是差不多的，但在现代计算机中，cpu的指令速度远超内存的存取速度，由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache）作为内存与处理器之间的缓冲。将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也为计算机系统带来更高的复杂度，因为它引入了一个新的问题：<font color='red'>缓存一致性（CacheCoherence）</font>。</p><p>&emsp;&emsp;JMM指的是Java Memory Model（Java内存模型），它本身是一种抽象的概念，并不是真实存在的，它更多的是描述一组规则或规范，通过这组规范定义了程序中的各个变量（包括实例字段、静态字段和构成数组对象的元素）的访问方式。</p><p>JMM关于同步的规定：</p><p>&emsp;&emsp;a、线程解锁前，必须把共享变量的值刷回主内存；</p><p>&emsp;&emsp;b、线程加锁前，必须读取主内存的最新值到自己的工作内存；</p><p>&emsp;&emsp;c、加锁和解锁是同一把锁。</p><p>&emsp;&emsp;由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作空间（栈空间），工作内存是每个线程的私有数据区域，而Java内存模型中规定所有变量都存储在主内存中，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作（读取赋值等）必须在工作内存中进行，所以首先要将变量从主内存拷贝到自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成，其简要访问过程：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/20200309153225758.png" alt="20200309153225758"></p><p>这里需要注意的是：</p><p>a、数据的传输效率：硬盘 &lt; 内存 &lt;&lt; cache &lt; CPU</p><p>b、主内存与工作内存</p><p><strong>主内存</strong>：就是计算机的实体内存，我们经常提起的电脑是4G、8G还是16G内存，主内存是所有的线程所共享的；</p><p><strong>工作内存</strong>：可类比高速缓存，也是虚拟机内存的一部分，工作内存是线程私有的，不共享的。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210504174014498.png" alt="image-20210504174014498"></p><p>&emsp;&emsp;<strong>内存交互操作</strong>有8种，虚拟机实现必须保证每一个操作都是原子的，不可在分的（对于double和long类<br>型的变量来说，load、store、read和write操作在某些平台上允许例外）</p><ul><li><p><strong>lock （锁定）</strong>：作用于主内存的变量，把一个变量标识为线程独占状态</p></li><li><p><strong>unlock （解锁）</strong>：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量<br>才可以被其他线程锁定</p></li><li><p><strong>read （读取）</strong>：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便<br>随后的load动作使用</p></li><li><p><strong>load （载入）</strong>：作用于工作内存的变量，它把read操作从主存中变量放入工作内存中</p></li><li><p><strong>use （使用）</strong>：作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机<br>遇到一个需要使用到变量的值，就会使用到这个指令</p></li><li><p><strong>assign （赋值）</strong>：作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变<br>量副本中</p></li><li><p><strong>store （存储）</strong>：作用于主内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，<br>以便后续的write使用</p></li><li><p><strong>write （写入）</strong>：作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内<br>存的变量中</p></li><li><p>&emsp;&emsp;同时：JMM对这八种指令的使用，制定了如下规则：<br>不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须write</p></li><li><p>不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存</p></li><li><p>不允许一个线程将没有assign的数据从工作内存同步回主内存</p></li><li><p>一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是怼变量实施use、store操作之前，必须经过assign和load操作</p></li><li><p>一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁</p></li><li><p>如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值</p></li><li><p>如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量</p></li><li><p>对一个变量进行unlock操作之前，必须把此变量同步回主内存  </p></li></ul><h2 id="4、内存可见性"><a href="#4、内存可见性" class="headerlink" title="4、内存可见性"></a>4、内存可见性</h2><p><img src="http://cheng_qiwei.gitee.io/blog/img/21000001.png" alt="21013100001"></p><p>&emsp;&emsp;根据上图，我们可以发现，当我们需要修改一个主内存的数据，那么我们需要先将数据拷贝到自己的工作内存中，修改工作内存中的数据后，将数据刷回主内存中，那么此时，由于线程t1、t2、t3同时拷贝了age=25的数据，但t1线程先修改了，并把数据保存回主内存，那么此时，其他线程是不知道的，所以此时就需要通知其他线程，数据已经修改，你们要修改的话就需要重新获取数据的最新值再进行修改，这就是内存的可见性。</p><p><strong>JMM内存模型的可见性</strong>：指的是当主内存区域中的值被某个线程写入更改后，其它线程会马上知晓更改后的值，并重新得到更改后的值。</p><h2 id="5、验证volatile的可见性"><a href="#5、验证volatile的可见性" class="headerlink" title="5、验证volatile的可见性"></a>5、验证volatile的可见性</h2><p>5.1、假如 int number = 0，number变量没有volatile进行修饰，即没有可见性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cheng.juc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestVolatile</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyData</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.number+=<span class="number">60</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyData myData = <span class="keyword">new</span> MyData();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t come in&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            myData.addNum();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t update number : &quot;</span>+myData.number);</span><br><span class="line">        &#125;,<span class="string">&quot;ThreadA&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (myData.number == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//main线程一直在此等待，直到number不为0，则退出，从而验证可见性</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t misson is over&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;此时执行之后，结果如下图，由于没有可见性，所以main线程循环的那里根本就不知道number的数据已经改变，所以一直等待着。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210222221429485.png" alt="image-20210222221429485"></p><p>5.2、此时，给number加上volatile进行修饰，如下：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210222221701898.png" alt="image-20210222221701898"></p><p>&emsp;&emsp;执行结果如下，由于添加volatile进行修饰，该变量具备可见性，所以main线程能够获得通知，结束循环</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210222221844926.png" alt="image-20210222221844926"></p><h2 id="6、验证volatile的不保证原子性"><a href="#6、验证volatile的不保证原子性" class="headerlink" title="6、验证volatile的不保证原子性"></a>6、验证volatile的不保证原子性</h2><p>验证代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cheng.juc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestVolatileCurr</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyData</span></span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNumPlus</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.number++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyData myData = <span class="keyword">new</span> MyData();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                    myData.addNumPlus();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,<span class="string">&quot;Thread&quot;</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">2</span>)&#123;<span class="comment">//系统默认有两个线程，一个是main线程，一个是GC线程，超过则说明所有县城还未执行完</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t finally number value：&quot;</span>+ myData.number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里我们使用volatile修饰了number，但是根据计算，按照正常情况下，我们的最终结果应该是20000才对，而我们执行的结果如下，多次执行，这个值始终是小于20000，由此说明volatile不保证原子性。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210222224048795.png" alt="image-20210222224048795"></p><p>&emsp;&emsp;那么，为什么会出现缺失的情况呢？这是因为，在this.number++这个操作中，底层是被分成三个指令，首先执行getfield获取原始值number，然后执行iadd进行加1操作，最后再执行putfield把累加后的值写回主内存中，由于可能出现纳秒级别的时间差，此时当一个值写回到主内存后，可能还来不及通知其他线程，其他线程就又把值写到主内存中，造成写覆盖，从而导致最终的结果小于20000。</p><h2 id="7、volatile不保证原子性的解决方案"><a href="#7、volatile不保证原子性的解决方案" class="headerlink" title="7、volatile不保证原子性的解决方案"></a>7、volatile不保证原子性的解决方案</h2><p>&emsp;&emsp;首先，我们使用synchronized 修饰 addNumPlus，就可以保证原子性，如下图：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210222230438881.png" alt="image-20210222230438881"></p><p>&emsp;&emsp;其次，我们可以使用JUC中的AtomicInteger也可以解决这个问题，代码如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package com.cheng.juc;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line">public class TestVolatileCurr &#123;</span><br><span class="line"></span><br><span class="line">    public static class MyData&#123;</span><br><span class="line">        volatile int number = 0;</span><br><span class="line">        AtomicInteger atomicInteger = new AtomicInteger();</span><br><span class="line"></span><br><span class="line">        public void addNumPlus()&#123;</span><br><span class="line">            this.number++;</span><br><span class="line">            atomicInteger.getAndIncrement();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyData myData = new MyData();</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                for (int j = 0; j &lt; 1000; j++) &#123;</span><br><span class="line">                    myData.addNumPlus();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,&quot;Thread&quot;+i).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        while (Thread.activeCount() &gt; 2)&#123;//系统默认有两个线程，一个是main线程，一个是GC线程，超过则说明所有县城还未执行完</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;\t int Type finally number value：&quot;+ myData.number);</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+&quot;\t AtomicInteger Type finally number value：&quot;+ myData.atomicInteger);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;查看结果，我们发现，使用volatile依然没有达到20000，而使用AtomicInteger则达到了20000。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210223225630823.png" alt="image-20210223225630823"></p><h2 id="8、volatile的禁止指令重排"><a href="#8、volatile的禁止指令重排" class="headerlink" title="8、volatile的禁止指令重排"></a>8、volatile的禁止指令重排</h2><h3 id="8-1、什么是指令重排？"><a href="#8-1、什么是指令重排？" class="headerlink" title="8.1、什么是指令重排？"></a>8.1、什么是指令重排？</h3><p>&emsp;&emsp;在程序执行过程中, 为了性能考虑, 编译器和CPU可能会对指令重新排序。</p><h3 id="8-2、指令重排在单线程中的操作"><a href="#8-2、指令重排在单线程中的操作" class="headerlink" title="8.2、指令重排在单线程中的操作"></a>8.2、指令重排在单线程中的操作</h3><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210224235041724.png" alt="image-20210224235041724"></p><p>&emsp;&emsp;有如上图的一个方法，按照正常的情况，他的执行流程是：1234</p><p>&emsp;&emsp;但是，根据指令重排，有时候就会出现2134或1324的情况，但是绝对不会出现4先开始的操作，因为存在数据依赖。所以指令重排对单线程没有影响。</p><h3 id="8-3、指令重排在多线程中的操作"><a href="#8-3、指令重排在多线程中的操作" class="headerlink" title="8.3、指令重排在多线程中的操作"></a>8.3、指令重排在多线程中的操作</h3><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210225221645033.png" alt="image-20210225221645033"></p><p>&emsp;&emsp;我们观察这个案例，如果按照正常情况，我们定义四个变量，两个线程的执行顺序应该和表一的情况一致。首先线程1执行x = a = 0，线程2执行y = b = 0，然后执行 b = 1和a = 2，但是由于指令重排，就可能出现 第二个表的情况，先执行了 b = 1和a = 2，再执行x = a = 2，y = b =1，就和我们的目标不一致了。</p><p>所以，需要volatile实现禁止指令重排，来避免多线程环境下程序出现乱序执行的现象。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210225223038024.png" alt="image-20210225223038024"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210225223045121.png" alt="image-20210225223045121"></p><h3 id="8-4、测试volatile的指令重排"><a href="#8-4、测试volatile的指令重排" class="headerlink" title="8.4、测试volatile的指令重排"></a>8.4、测试volatile的指令重排</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cheng.juc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInstruction</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            a = a + <span class="number">5</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;****retValue:&quot;</span>+a);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span> ; i++) &#123;</span><br><span class="line">            TestInstruction  x = <span class="keyword">new</span> TestInstruction();</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                x.method1();</span><br><span class="line">            &#125;,<span class="string">&quot;Thread1&quot;</span>).start();</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                x.method2();</span><br><span class="line">            &#125;,<span class="string">&quot;Thread2&quot;</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;正常执行时，其结果为6，但是当出现先执行指令2，然后执行指令3，最后再执行指令1时，其结果会是5，如下图：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210225230108672.png" alt="image-20210225230108672"></p><p>&emsp;&emsp;所以只需要在定义a时使用volatile，则可以解决指令重排的问题。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210225230508672.png" alt="image-20210225230508672"></p><h2 id="9、总结：线程安全性如何获得保证？"><a href="#9、总结：线程安全性如何获得保证？" class="headerlink" title="9、总结：线程安全性如何获得保证？"></a>9、总结：线程安全性如何获得保证？</h2><h3 id="9-1、工作内存与主内存同步延迟现象导致的可见性问题"><a href="#9-1、工作内存与主内存同步延迟现象导致的可见性问题" class="headerlink" title="9.1、工作内存与主内存同步延迟现象导致的可见性问题"></a>9.1、工作内存与主内存同步延迟现象导致的可见性问题</h3><p>&emsp;&emsp;可以使用synchronized或volatile关键字解决，它们都可以使一个线程修改后的变量立即对对其他线程可见。</p><h3 id="9-2、对于指令重排导致的可见性问题和有序性问题"><a href="#9-2、对于指令重排导致的可见性问题和有序性问题" class="headerlink" title="9.2、对于指令重排导致的可见性问题和有序性问题"></a>9.2、对于指令重排导致的可见性问题和有序性问题</h3><p>&emsp;&emsp;可以利用volatile关键字解决，因为volatile的另一个作用就是禁止指令重排。</p><h2 id="10、volatile的应用"><a href="#10、volatile的应用" class="headerlink" title="10、volatile的应用"></a>10、volatile的应用</h2><p>在单例里模式下的应用：</p><p>&emsp;&emsp;对于频繁使用的对象，使用单例模式可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常客观的一笔系统开销。而且由于new操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻GC压力，缩短GC停顿时间。</p><h3 id="10-1、单例模式在多线程下可能出现的问题"><a href="#10-1、单例模式在多线程下可能出现的问题" class="headerlink" title="10.1、单例模式在多线程下可能出现的问题"></a>10.1、单例模式在多线程下可能出现的问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cheng.juc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonDemo instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t 我是构造方法SingletonDemo()！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonDemo();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1、单线程下的操作</span></span><br><span class="line">        System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());</span><br><span class="line">        System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());</span><br><span class="line">        System.out.println(SingletonDemo.getInstance() == SingletonDemo.getInstance());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------------------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//2、并发多线程下的操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt;&#123;</span><br><span class="line">                SingletonDemo.getInstance();</span><br><span class="line">            &#125;,<span class="string">&quot;线程&quot;</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们首先执行1单线程下的操作，结果如下：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210227162359503.png" alt="image-20210227162359503"></p><p>&emsp;&emsp;单例模式是有效的。接着，我们执行2多线程操作，结果如下，并没有每次都是创建一个对象，而且创建的个数也是不确定的，这就是多线程下延迟加载单例设计模式的线程安全问题。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210227165530080.png" alt="image-20210227165530080"></p><p>&emsp;&emsp;按照我们以前的习惯，那我们就在getInstance()方法上加上synchronized进行修饰，则可以解决此问题，但是，为了一个单例模式，我们就把整个代码锁住，而getInstance()整个方法体都是同步的，这就限定了访问速度。所以需要考虑使用DCL来解决这个问题。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210227165718093.png" alt="image-20210227165718093"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210227165919153.png" alt="image-20210227165919153"></p><h3 id="10-2、Double-Check-Lock（双端检锁机制）"><a href="#10-2、Double-Check-Lock（双端检锁机制）" class="headerlink" title="10.2、Double Check Lock（双端检锁机制）"></a>10.2、Double Check Lock（双端检锁机制）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改getInstance()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonDemo <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonDemo.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonDemo();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;如上，这样我们将上锁的粒度降低到了仅仅是初始化实例的那部分，从而使代码即正确又保证了执行效率。这就是所谓的“双检锁”机制（顾名思义）。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210227171948344.png" alt="image-20210227171948344"></p><p>&emsp;&emsp;我们进行测试，测试结果如上：单例模式是有效的。但是，DCL双端检锁机制不一定是线程安全的，原因是有指令重排的存在，加入volatile可以禁止指令重排。例如以下例子：</p><p>instance = new SingletonDemo(); 这个操作可以分为以下三步：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory = allocate(); <span class="comment">//1、分配对象内存空间</span></span><br><span class="line">instance(memory);    <span class="comment">//2、初始化对象</span></span><br><span class="line">instance = memory;   <span class="comment">//3、设置instance指向刚分配的内存地址，此时instance != null</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;但是由于步骤2和3不存在数据依赖关系，而且无论重排前还是重排后程序的执行结果在单线程中并没有改变，因此这种重排优化是允许的。所以就会出现以下情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory = allocate(); <span class="comment">//1、分配对象内存空间</span></span><br><span class="line">instance = memory;   <span class="comment">//3、设置instance指向刚分配的内存地址，此时instance != null,但是对象还没初始化完成！</span></span><br><span class="line">instance(memory);    <span class="comment">//2、初始化对象</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;所以，我们在需要创建单例的对象加上volatile，就能禁止其指令重排，减少指令重排所带来的问题。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210228163758047.png" alt="image-20210228163758047"></p><h1 id="十、CAS"><a href="#十、CAS" class="headerlink" title="十、CAS"></a>十、CAS</h1><p>面试题：CAS  -&gt;  Unsafe  -&gt;  CAS底层思想  -&gt; ABA  -&gt;  原子引用更新  -&gt;  ABA问题的规避</p><h2 id="1、什么是CAS？"><a href="#1、什么是CAS？" class="headerlink" title="1、什么是CAS？"></a>1、什么是CAS？</h2><p>&emsp;&emsp;CAS （compareAndSwap），中文叫比较与交换，是一种无锁原子算法。过程是这样：它包含 3 个参数 CAS（V，E，N），V表示要更新变量的值，E表示预期值，N表示新值。仅当 V值等于E值时，才会将V的值设为N，如果V值和E值不同，则说明已经有其他线程做两个更新，则当前线程则什么都不做。最后，CAS 返回当前V的真实值。CAS 操作时抱着乐观的态度进行的，它总是认为自己可以成功完成操作。</p><h3 id="测试案例"><a href="#测试案例" class="headerlink" title="测试案例"></a>测试案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cheng.juc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhoCAS</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">5</span>);</span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>,<span class="number">2021</span>) + <span class="string">&quot;\t current data：&quot;</span> + atomicInteger.get());</span><br><span class="line">        System.out.println(atomicInteger.compareAndSet(<span class="number">5</span>,<span class="number">1024</span>) + <span class="string">&quot;\t current data：&quot;</span> + atomicInteger.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210228223541474.png" alt="image-20210228223541474"></p><h2 id="2、CAS底层原理"><a href="#2、CAS底层原理" class="headerlink" title="2、CAS底层原理"></a>2、CAS底层原理</h2><p>&emsp;&emsp;CAS体现在Java语言中就是sun.misc.Unsafe类的各个方法。调用UnSafe类中的CAS方法，JVM会帮我们实现出CAS汇编指令，是完全依赖于硬件的功能，由于CAS是一种系统原语，原语属于操作系统使用范畴，是由若干条指令组成，用于完成某个功能的一个过程，<font color='red'>并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说CAS是一条CPU的原子指令，不会造成所谓的数据不一致的问题</font>，即CAS是线程安全的。</p><h2 id="3、CAS的缺点"><a href="#3、CAS的缺点" class="headerlink" title="3、CAS的缺点"></a>3、CAS的缺点</h2><h3 id="3-1、循环时间长，CPU开销大；"><a href="#3-1、循环时间长，CPU开销大；" class="headerlink" title="3.1、循环时间长，CPU开销大；"></a>3.1、循环时间长，CPU开销大；</h3><p>&emsp;&emsp;我们从源码上看，假设我们一直没有执行成功，那么我们就一直在循环着，所以长时间的循环可能会给CPU带来很大的开销。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210301230104091.png" alt="image-20210301230104091"></p><h3 id="3-2、只能保证一个共享变量的原子操作"><a href="#3-2、只能保证一个共享变量的原子操作" class="headerlink" title="3.2、只能保证一个共享变量的原子操作"></a>3.2、只能保证一个共享变量的原子操作</h3><p>&emsp;&emsp;当我们只对一个共享变量进行操作时，我们可以使用循环CAS来保证原子操作，但是对于多个共享变量而言，循环CAS就无法保证操作的原子性，这时候就可以用锁来保证原子性。</p><h3 id="3-3、可能会出现ABA问题"><a href="#3-3、可能会出现ABA问题" class="headerlink" title="3.3、可能会出现ABA问题"></a>3.3、可能会出现ABA问题</h3><h2 id="4、ABA问题"><a href="#4、ABA问题" class="headerlink" title="4、ABA问题"></a>4、ABA问题</h2><h3 id="4-1、什么是ABA问题？"><a href="#4-1、什么是ABA问题？" class="headerlink" title="4.1、什么是ABA问题？"></a>4.1、什么是ABA问题？</h3><p>&emsp;&emsp;我们上一篇说到，CAS可能会导致ABA问题，那什么是ABA问题？</p><p>&emsp;&emsp;<font color='red'>CAS算法实现的一个重要前提就是需要去除内存中某时刻的数据并在当下时刻比较并交换，那么在这个时间差类会导致数据的变化。</font>譬如说：存在两个线程1和2，都从内存中取出值A，线程1执行比较慢，需要10s，线程2执行比较快，只需要4s，此时线程2率先执行结束，将数值A改为B，并写回内存中，接着，线程2再执行，有执行了一次，将数值修改回A，此时才消耗了8s，然后线程1执行CAS进行修改，发现内存的值是A，然后线程1操作成功将数据改为C并写回内存。虽然线程1修改成功了，但这并不代表这个过程就是没问题的。</p><h3 id="4-2、AtomicReference的使用（原子引用）"><a href="#4-2、AtomicReference的使用（原子引用）" class="headerlink" title="4.2、AtomicReference的使用（原子引用）"></a>4.2、AtomicReference的使用（原子引用）</h3><p>&emsp;&emsp;我们前面使用Atomic的时候都是有指定的类型，例如AtomicInteger、AtomicBoolean等，那么，如果是一个对象，那应该是怎么办，此时，可以考虑使用AtomicReference。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cheng.juc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReferenceDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User user1 = <span class="keyword">new</span> User(<span class="string">&quot;小米&quot;</span>,<span class="number">10</span>);</span><br><span class="line">        User user2 = <span class="keyword">new</span> User(<span class="string">&quot;小百&quot;</span>,<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">        AtomicReference&lt;User&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;(user1);</span><br><span class="line">        System.out.println(atomicReference.compareAndSet(user1,user2) + <span class="string">&quot;\t &quot;</span> + atomicReference.get().toString());</span><br><span class="line">        System.out.println(atomicReference.compareAndSet(user1,user2) + <span class="string">&quot;\t &quot;</span> + atomicReference.get().toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">   String name;</span><br><span class="line">   Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上面的案例：效果和之前的AtomicInteger一样，如下：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210303230733811.png" alt="image-20210303230733811"></p><h3 id="4-3、如何解决ABA问题"><a href="#4-3、如何解决ABA问题" class="headerlink" title="4.3、如何解决ABA问题"></a>4.3、如何解决ABA问题</h3><p>&emsp;&emsp;<font color='red'>解决方案：原子引用+新增修改版本号的机制。</font></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210303234418046.png" alt="image-20210303234418046"></p><h4 id="4-3-1、演示ABA问题"><a href="#4-3-1、演示ABA问题" class="headerlink" title="4.3.1、演示ABA问题"></a>4.3.1、演示ABA问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">FoundABA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------ABA问题的产生-----------------------------&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">&quot;t1&quot;</span>)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;t1当前值为：&quot;</span> + atomicReference.get());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                atomicReference.compareAndSet(<span class="number">100</span>,<span class="number">101</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;t1当前值为：&quot;</span> + atomicReference.get());</span><br><span class="line">                atomicReference.compareAndSet(<span class="number">101</span>,<span class="number">100</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;t1当前值为：&quot;</span> + atomicReference.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">&quot;t2&quot;</span>)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;t2当前值为：&quot;</span> + atomicReference.get());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;t2执行结果：&quot;</span>+atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">2021</span>)</span><br><span class="line">                + <span class="string">&quot;\t 当前值为：&quot;</span> + atomicReference.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------ABA问题的结束-----------------------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前，线程1和线程2同时获取数值100，然后线程1进行一次ABA操作之后，线程2发现数值还是100就认为其没有改变，所以就将其改为2021。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210306150315866.png" alt="image-20210306150315866"></p><h4 id="4-3-2、演示ABA问题的解决"><a href="#4-3-2、演示ABA问题的解决" class="headerlink" title="4.3.2、演示ABA问题的解决"></a>4.3.2、演示ABA问题的解决</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">solveABA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------ABA问题的解决开发-----------------------------&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">&quot;t3&quot;</span>)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;t3当前值为：&quot;</span> + atomicStampedReference.getReference()+<span class="string">&quot;当前版本号为：&quot;</span>+atomicStampedReference.getStamp());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//t3线程休眠1秒中,确保t4也拿到初始的版本号</span></span><br><span class="line">                    sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                atomicStampedReference.compareAndSet(<span class="number">100</span>,<span class="number">101</span>,atomicStampedReference.getStamp(),atomicStampedReference.getStamp()+<span class="number">1</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;t3当前值为：&quot;</span> + atomicStampedReference.getReference()+<span class="string">&quot;当前版本号为：&quot;</span>+atomicStampedReference.getStamp());</span><br><span class="line">                atomicStampedReference.compareAndSet(<span class="number">101</span>,<span class="number">100</span>,atomicStampedReference.getStamp(),atomicStampedReference.getStamp()+<span class="number">1</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;t3当前值为：&quot;</span> + atomicStampedReference.getReference()+<span class="string">&quot;当前版本号为：&quot;</span>+atomicStampedReference.getStamp());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">&quot;t4&quot;</span>)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">int</span> stamp = atomicStampedReference.getStamp();</span><br><span class="line">                System.out.println(<span class="string">&quot;t4当前值为：&quot;</span> + atomicStampedReference.getReference()+<span class="string">&quot;当前版本号为：&quot;</span>+stamp);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;t4执行结果：&quot;</span>+(atomicStampedReference.compareAndSet(<span class="number">100</span>, <span class="number">2021</span>,stamp,stamp+<span class="number">1</span>)?<span class="string">&quot;成功&quot;</span>:<span class="string">&quot;失败&quot;</span>)</span><br><span class="line">                        + <span class="string">&quot;\t 当前值为：&quot;</span> + atomicStampedReference.getReference()</span><br><span class="line">                        + <span class="string">&quot;\t 当前版本号为：&quot;</span> + atomicStampedReference.getStamp());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3200</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------ABA问题的解决结束-----------------------------&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当前，线程3和线程4同时获取数值100，然后线程3进行一次ABA操作之后，由于加入了版本号，所以线程2发现数值已经发生改变，所以修改数值就失败了。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210305000638912.png" alt="image-20210305000638912"></p>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 线程池 </tag>
            
            <tag> cas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC（上）</title>
      <link href="/blog/2021/05/03/JUC%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/blog/2021/05/03/JUC%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h1><h1 id="一、JUC简介"><a href="#一、JUC简介" class="headerlink" title="一、JUC简介"></a>一、JUC简介</h1><h2 id="1、什么是JUC？"><a href="#1、什么是JUC？" class="headerlink" title="1、什么是JUC？"></a>1、什么是JUC？</h2><p>&emsp;&emsp;JUC就是java.util .concurrent工具包的简称。在此包中增加了在并发编程中很常用的工具类,用于定义类似于线程的自定义子系统,包括线程池,异步 IO 和轻量级任务框架；还提供了设计用于多线程上下文中的 Collection 实现等。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1619235052964.png" alt="1619235052964"></p><h2 id="2、一些基本概念"><a href="#2、一些基本概念" class="headerlink" title="2、一些基本概念"></a>2、一些基本概念</h2><p>&emsp;&emsp;在了解JUC之前，要先了解一些基本概念：</p><h3 id="2-1、进程和线程"><a href="#2-1、进程和线程" class="headerlink" title="2.1、进程和线程"></a>2.1、进程和线程</h3><p><strong>进程</strong>：是一个程序的实例；例如：QQ.exe、WeiXin.exe</p><p>&emsp;&emsp;一个进程至少包含一个线程，往往是包含多个线程。</p><p><strong>线程</strong>：是一个进程的实体，是CPU调度和分配的基本单位；</p><p>&emsp;&emsp;Java默认有两个线程：main方法和GC。</p><p>&emsp;&emsp;开启线程的方式：Thread、Runnable、Callable。</p><p>&emsp;&emsp;Java本质是无法开启线程的，是调用本地方法(c++)来开启线程的，Java无法操作硬件。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1619235719045.png" alt="1619235719045"></p><h3 id="2-2、并发、并行"><a href="#2-2、并发、并行" class="headerlink" title="2.2、并发、并行"></a>2.2、并发、并行</h3><p>并发编程：并发、并行</p><p><strong>并发</strong>：指两个或多个事件在同一时间段发生；</p><p><strong>并行</strong>：指两个或多个事件在同一时刻发生【多个线程同时进行】。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1612063497885.png" alt="1612063497885"></p><p>&emsp;&emsp;**并发编程的本质：充分利用CPU的资源 **</p><h3 id="2-3、线程的状态"><a href="#2-3、线程的状态" class="headerlink" title="2.3、线程的状态"></a>2.3、线程的状态</h3><p>&emsp;&emsp;线程的状态有六种：新生（NEW）、运行（RUNNABLE）、阻塞（BLOCKED）、等待（WAITING）、超时等（TIMED_WAITING）、终止（TERMINATED）</p><h3 id="2-4、wait和sleep的区别"><a href="#2-4、wait和sleep的区别" class="headerlink" title="2.4、wait和sleep的区别"></a>2.4、wait和sleep的区别</h3><p>&emsp;&emsp;首先，它们来自不同的类：wait来自Object类，而sleep来自Thread类；</p><p>&emsp;&emsp;其次，关于锁的释放：wait在等待的时候会释放锁，而sleep在休眠的时候不会释放锁；</p><p>&emsp;&emsp;再次，关于使用范围：wait只能在同步代码块中使用，而sleep可以在任何位置使用；</p><p>&emsp;&emsp;最后，wait在使用过程中不需要捕获异常，而sleep必须捕获异常。</p><h1 id="二、Lock锁"><a href="#二、Lock锁" class="headerlink" title="二、Lock锁"></a>二、Lock锁</h1><h2 id="1、Synchronized"><a href="#1、Synchronized" class="headerlink" title="1、Synchronized"></a>1、Synchronized</h2><p>&emsp;&emsp;Synchronized的本质其实就是队列和锁，把所有过来的线程排成一条队列，按顺序给锁执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.g4b.juc.sync;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="comment">/**基本买票案例*/</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                ticket.safeTicket();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                ticket.safeTicket();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                ticket.safeTicket();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket_num = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义卖票的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">safeTicket</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ticket_num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;线程&#123;&#125;卖出了&#123;&#125;张票，剩余：&#123;&#125;张票&quot;</span>, Thread.currentThread().getName(),ticket_num--,ticket_num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/1619250392858.png" alt="1619250392858"></p><h2 id="2、Lock"><a href="#2、Lock" class="headerlink" title="2、Lock"></a>2、Lock</h2><p>&emsp;&emsp;Lock锁实现提供了比使用同步方法和语句可以获得的更广泛的锁操作。它们允许更灵活的结构，可能具有非常不同的属性，并且可能支持多个关联的条件对象。</p><p>&emsp;&emsp;Lock锁的实现，根据官方文档，修改上面synchronized的例子：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1619251703015.png" alt="1619251703015"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.g4b.juc.sync;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Ticket2 ticket = <span class="keyword">new</span> Ticket2();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                ticket.safeTicket();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                ticket.safeTicket();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                ticket.safeTicket();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket2</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket_num = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">//定义卖票的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">safeTicket</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(ticket_num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                log.info(<span class="string">&quot;线程&#123;&#125;卖出了&#123;&#125;张票，剩余：&#123;&#125;张票&quot;</span>,Thread.currentThread().getName(),ticket_num--,ticket_num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Lock使用三部曲：创建一个锁，加锁，解锁</strong></p><p>测试中，我们发现使用Lock也能达到 synchronized 相同的效果。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1619252114625.png" alt="1619252114625"></p><h2 id="3、-synchronized-和Lock的区别"><a href="#3、-synchronized-和Lock的区别" class="headerlink" title="3、 synchronized 和Lock的区别"></a>3、 synchronized 和Lock的区别</h2><p>3.1、synchronized 是内置的java关键字，而Lock是一个java类；</p><p>3.2、synchronized 无法判断获取锁的状态，而Lock可以判断是否获取到了锁；</p><p>3.3、synchronized 会自动释放锁，Lock必须要手动释放锁，否则会造成<strong>死锁</strong>；</p><p>3.4、synchronized 线程1（获得锁，阻塞）线程2（等待），而Lock锁就不一定会等待下去（tryLock尝试获取锁）；</p><p>3.5、synchronized 是可重入锁，不可以中断且是非公平锁，而Lock锁也是可重入锁，可以判断锁且可以设置是否为公平锁；</p><p>3.6、synchronized 适合锁少量的代码同步问题，而Lock锁适合锁大量的同步代码。</p><h2 id="4、生产者和消费者问题"><a href="#4、生产者和消费者问题" class="headerlink" title="4、生产者和消费者问题"></a>4、生产者和消费者问题</h2><h3 id="4-1、生产者和消费者问题（synchronized解决方式）"><a href="#4-1、生产者和消费者问题（synchronized解决方式）" class="headerlink" title="4.1、生产者和消费者问题（synchronized解决方式）"></a>4.1、生产者和消费者问题（synchronized解决方式）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.g4b.juc.PCQuestion;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Data data = <span class="keyword">new</span> Data();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(number != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number++;</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125; =&gt; &#123;&#125;&quot;</span>,Thread.currentThread().getName(),number);</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(number == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number--;</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125; =&gt; &#123;&#125;&quot;</span>,Thread.currentThread().getName(),number);</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/1619278351119.png" alt="1619278351119"></p><h4 id="●-虚假唤醒"><a href="#●-虚假唤醒" class="headerlink" title="●  虚假唤醒"></a>●  虚假唤醒</h4><p>&emsp;&emsp;但是，当我们把当前的线程提升到四个时，就会发生如下现象：部分数据不是按照1,0,1,0分布，而会出现2甚至3的情况，我们通过官方文档，发现这就是所谓的虚假唤醒，而官方也提供了解决办法，就是把if改成while来进行判断即可。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1619359820306.png" alt="1619359820306"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1619360130681.png" alt="1619360130681"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1619360232400.png" alt="1619360232400"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1619360254278.png" alt="1619360254278"></p><h3 id="4-2、生产者和消费者问题（JUC解决方式）"><a href="#4-2、生产者和消费者问题（JUC解决方式）" class="headerlink" title="4.2、生产者和消费者问题（JUC解决方式）"></a>4.2、生产者和消费者问题（JUC解决方式）</h3><p><img src="http://cheng_qiwei.gitee.io/blog/img/1619360523036.png" alt="1619360523036"></p><p>&emsp;&emsp;对于synchronized，我们使用wait和notify来解决生产者和消费者的问题，而对于Lock，我们这是使用Condition类中的await和signal来解决生产者消费者问题。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1619360692490.png" alt="1619360692490"></p><p>我们修改synchronized的方法，修改如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data2</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">0</span>)&#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number++;</span><br><span class="line">            log.info(<span class="string">&quot;&#123;&#125; =&gt; &#123;&#125;&quot;</span>,Thread.currentThread().getName(),number);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(number == <span class="number">0</span>)&#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number--;</span><br><span class="line">            log.info(<span class="string">&quot;&#123;&#125; =&gt; &#123;&#125;&quot;</span>,Thread.currentThread().getName(),number);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/1619361467012.png" alt="1619361467012"></p><h3 id="4-3、使用Lock和Condition的优势？"><a href="#4-3、使用Lock和Condition的优势？" class="headerlink" title="4.3、使用Lock和Condition的优势？"></a>4.3、使用Lock和Condition的优势？</h3><p>&emsp;&emsp;使用Lock和Condition的优势在于，我们可以进行精准唤醒。例如上一篇，我们是随机的（A–B–A–D–C–B），假如我们希望是A–B–C–D这样轮询操作，那么就可以使用我们的Lock来进行精准唤醒。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.g4b.juc.PCQuestion;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Data3 data = <span class="keyword">new</span> Data3();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.a();</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.b();</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.c();</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data3</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    Condition condition = lock.newCondition();</span><br><span class="line">    Condition condition2 = lock.newCondition();</span><br><span class="line">    Condition condition3 = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">0</span>)&#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number = <span class="number">1</span>;</span><br><span class="line">            log.info(<span class="string">&quot;&#123;&#125; =&gt; &#123;&#125;&quot;</span>,Thread.currentThread().getName(),number);</span><br><span class="line">            condition2.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(number != <span class="number">1</span>)&#123;</span><br><span class="line">                condition2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number = <span class="number">2</span>;</span><br><span class="line">            log.info(<span class="string">&quot;&#123;&#125; =&gt; &#123;&#125;&quot;</span>,Thread.currentThread().getName(),number);</span><br><span class="line">            condition3.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">c</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(number != <span class="number">2</span>)&#123;</span><br><span class="line">                condition3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number = <span class="number">0</span>;</span><br><span class="line">            log.info(<span class="string">&quot;&#123;&#125; =&gt; &#123;&#125;&quot;</span>,Thread.currentThread().getName(),number);</span><br><span class="line">            condition.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/1619362132097.png" alt="1619362132097"></p><h2 id="5、八锁现象"><a href="#5、八锁现象" class="headerlink" title="5、八锁现象"></a>5、八锁现象</h2><p>&emsp;&emsp;八锁现象，其实就是八个锁的问题。</p><h3 id="5-1、问题一和二"><a href="#5-1、问题一和二" class="headerlink" title="5.1、问题一和二"></a>5.1、问题一和二</h3><p>&emsp;&emsp;当存在一个Phone类，类中有发短信和打电话两个方法，两个方法均被synchronized修饰，那么此时，由两个线程来操作这两个方法，具体如下代码，请问，两个方法谁会先被执行？此时发短信的方法需要延时4s，那么两个方法中谁会先被执行？</p><p>&emsp;&emsp;这两题的答案均为先发短信，后打电话，原因是synchronized锁的对象是方法的调用者，也就是phone对象，而两个线程使用的都是同一个phone对象，所以当发短信获得锁之后，就必须由它执行结束后释放锁，接下来才能给到打电话执行，所以都是先执行发短信，再执行打电话。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.g4b.juc.LockEight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            phone.sendSms();</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            phone.call();</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSms</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;发短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2、问题三"><a href="#5-2、问题三" class="headerlink" title="5.2、问题三"></a>5.2、问题三</h3><p>&emsp;&emsp;当我们在Phone中加入一个普通方法听音乐，那么当我们开两个线程去执行发短信和听音乐时，谁会先被执行？</p><p>&emsp;&emsp;答案是先执行听音乐，后执行发短信。原因是听音乐的方法没有加锁，所以该方法不会受到锁的影响。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.g4b.juc.LockEight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone2 phone = <span class="keyword">new</span> Phone2();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            phone.sendSms();</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            phone.listen();</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSms</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;发短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;听音乐&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3、问题四"><a href="#5-3、问题四" class="headerlink" title="5.3、问题四"></a>5.3、问题四</h3><p>&emsp;&emsp;在问题1和2的基础上，如果此时使用两个对象访问两个同步方法，那么此时是先发短信还是先打电话？</p><p>&emsp;&emsp;答案是先打电话，因为此时两个方法的锁的对象不同了，所以两个方法之间的执行没有关系，所以此时会先执行打电话。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.g4b.juc.LockEight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone3 phone = <span class="keyword">new</span> Phone3();</span><br><span class="line">        Phone3 phone2 = <span class="keyword">new</span> Phone3();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            phone.sendSms();</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            phone2.call();</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSms</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;发短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-4、问题五和六"><a href="#5-4、问题五和六" class="headerlink" title="5.4、问题五和六"></a>5.4、问题五和六</h3><p>&emsp;&emsp;现在，在问题1和2的基础上，将发短信和打电话的方法设置为静态方法，此时又会是谁先执行？然后，在此基础上，使用两个对象访问两个静态同步方法，那么此时是先发短信还是先打电话？</p><p>&emsp;&emsp;这两道题目，答案都是先发短信，再打电话。那么，第一个题目比较好理解，就是一个锁，发短信先占有锁，所以先发短信再打电话。但是这个题目最重要的点是锁的对象发生了改变，从操作的对象phone变更为这个类的Class模板，因为使用了静态方法，所以锁的对象也就发生了改变，所以这也就可以解释9第二道题目了，为什么还是先发短信，再打电话，就是因为锁是Class模板，所以Class模板在类中只有一个，所以就必须先执行发短信。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.g4b.juc.LockEight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone4 phone = <span class="keyword">new</span> Phone4();</span><br><span class="line">        Phone4 phone2 = <span class="keyword">new</span> Phone4();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            phone.sendSms();</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            phone2.call();</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSms</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;发短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-5、问题七和八"><a href="#5-5、问题七和八" class="headerlink" title="5.5、问题七和八"></a>5.5、问题七和八</h3><p>&emsp;&emsp;在问题五的基础上，将其中一个方法设置为非静态方法，此时是先打电话还是先发短信？在此条件下，如果有两个对象来操作两个方法，那么又是如何呢？</p><p>&emsp;&emsp;答案是都是先执行打电话，再执行发短信，因为两个方法对应的锁都不一样了，所以就不存在联系了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.g4b.juc.LockEight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone5 phone = <span class="keyword">new</span> Phone5();</span><br><span class="line">        Phone5 phone2 = <span class="keyword">new</span> Phone5();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            phone.sendSms();</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            phone2.call();</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendSms</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;发短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-6、总结"><a href="#5-6、总结" class="headerlink" title="5.6、总结"></a>5.6、总结</h3><p>&emsp;&emsp;在判断线程的执行时，需要判断其使用的对应的锁，<font color='red'>普通的synchronized方法锁的是操作的对象，而静态的synchronized方法操作的则是类对象本身（Class）</font>一旦其他线程获取了和我们所需的相同的锁时，则必须等待其释放锁资源后才能获取锁操作。</p><h1 id="三、集合类不安全问题"><a href="#三、集合类不安全问题" class="headerlink" title="三、集合类不安全问题"></a>三、集合类不安全问题</h1><h2 id="1、集合类不安全问题的产生"><a href="#1、集合类不安全问题的产生" class="headerlink" title="1、集合类不安全问题的产生"></a>1、集合类不安全问题的产生</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">         <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">8</span>));</span><br><span class="line">             System.out.println(list);</span><br><span class="line">         &#125;,String.valueOf(i)).start();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210306162750572.png" alt="image-20210306162750572"></p><p>出现  <font color='red'>java.util.ConcurrentModificationException</font> 并发修改异常 。</p><h2 id="2、产生原因"><a href="#2、产生原因" class="headerlink" title="2、产生原因"></a>2、产生原因</h2><p>&emsp;&emsp;并发争抢修改导致异常。一个线程正在写入，其他线程过来争抢导致的数据不一致。</p><h2 id="3、解决方案："><a href="#3、解决方案：" class="headerlink" title="3、解决方案："></a>3、解决方案：</h2><h3 id="3-1、不使用ArrayList-使用Vector-；"><a href="#3-1、不使用ArrayList-使用Vector-；" class="headerlink" title="3.1、不使用ArrayList(),使用Vector()；"></a>3.1、不使用ArrayList(),使用Vector()；</h3><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210307113507428.png" alt="image-20210307113507428"></p><p>&emsp;&emsp;原因：Vector() 的add 方法加锁了，如下图：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210307112721016.png" alt="image-20210307112721016"></p><p>&emsp;&emsp;缺点：加了锁之后，一致性得到保证，并发性急剧下降。</p><h3 id="3-2、使用Collections-synchronizedList-new-ArrayList-lt-gt-；"><a href="#3-2、使用Collections-synchronizedList-new-ArrayList-lt-gt-；" class="headerlink" title="3.2、使用Collections.synchronizedList(new ArrayList&lt;&gt;())；"></a>3.2、使用Collections.synchronizedList(new ArrayList&lt;&gt;())；</h3><p>&emsp;&emsp;原因： 该方法返回的是一个 SynchronizedList 的对象，SynchronizedList 的实现里，get, set, add 等操作都加了 mutex 对象锁，再将操作委托给最初传入的 list。这个对象以组合的方式将对 List 的接口方法操作，委托给传入的 list 对象，并且对所有的接口方法对象加锁，得到并发安全性。<br><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210307115254256.png" alt="image-20210307115254256"></p><h3 id="3-3、new-CopyOnWriteArrayList-lt-gt-；写时复制"><a href="#3-3、new-CopyOnWriteArrayList-lt-gt-；写时复制" class="headerlink" title="3.3、new CopyOnWriteArrayList&lt;&gt;()；写时复制"></a><font color='red'>3.3、new CopyOnWriteArrayList&lt;&gt;()；写时复制</font></h3><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210307121707858.png" alt="image-20210307121707858"></p><p>&emsp;&emsp;原因： CopyOnWrite容器即写时复制容器。在往一个容器添加元素的时候，并不直接往当前容器object[]添加元素，而是先将当前容器object[]进行复制，复制出一个新的容器object[] newElements里添加元素，添加完成后，再将原容器的引用指向新容器 setArray(newElements)。这样做的好处是<font color='red'>可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素</font>。所以CopyOnWrite容器也是一种读写分离的思想，读和写分布于不同的容器中。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210307124250796.png" alt="image-20210307124250796"></p><h2 id="4、集合类不安全问题拓展"><a href="#4、集合类不安全问题拓展" class="headerlink" title="4、集合类不安全问题拓展"></a>4、集合类不安全问题拓展</h2><p>&emsp;&emsp;除了ArrayList，HashSet、HashMap等都具备以上问题相关解决的操作方案，HashMap的话对应的是ConcurrentHashMap。而且HashSet的方法CopyOnWriteArraySet的底层其实是CopyOnWriteArrayList，如下图：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210307151222444.png" alt="image-20210307151222444"></p><p>面试题：HashSet的底层是什么？HashMap在添加的时候需要放入键值，那HashSet是怎么处理的？</p><p>&emsp;&emsp;答：HashSet的底层是HashMap，在添价值时，把添加的值作为键，值的话使用一个叫PERSENT的常量（new Object()）代替。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210307152317401.png" alt="image-20210307152317401"></p><h1 id="四、Callable与常用辅助类"><a href="#四、Callable与常用辅助类" class="headerlink" title="四、Callable与常用辅助类"></a>四、Callable与常用辅助类</h1><h2 id="1、Callable"><a href="#1、Callable" class="headerlink" title="1、Callable"></a>1、Callable</h2><p>&emsp;&emsp;Callable接口类的功能类似于Runnable，但是相对于Runnable，Callable有以下几点优势：</p><ul><li>可以有返回值；</li><li>可以抛出异常。</li></ul><p>&emsp;&emsp;而我们在构建线程的时候，我们是将runnable对象设置到Thread中，但是它并不接受Callable，所以此时我们需要通过Runnable，将Callable转换成Runnable才能够执行。所以我们从开发文档中发现Runnable中有一个FutureTask的方法，能够运行Callable。</p><p>&emsp;&emsp;FutureTask的作用是把主线程中需要执行某些比较耗时的操作，但又不想阻塞主线程时，就可以把这些操作交给Future对象在后台完成，当主线程未来需要了解这些操作的完成情况时，就可以通过Future对象获取后台该操作的执行结果。在使用时，当调用其get方法时，如果该操作未完成，则会使其阻塞在那里，直至其完成所有操作为止。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210427225141160.png" alt="image-20210427225141160"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210427225208951.png" alt="image-20210427225208951"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.g4b.juc.callableTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyCallable callable = <span class="keyword">new</span> MyCallable();</span><br><span class="line">        FutureTask futureTask = <span class="keyword">new</span> FutureTask(callable);</span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(futureTask.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1024</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里使用FutureTask多次执行相同的线程时，其结果会被<strong>缓存</strong>，执行效率会大大提升。同时，因为线程执行需要时间，所以使用get方法时可能会<strong>产生阻塞</strong>。</p><h2 id="2、常用的辅助类1：CountDownLatch"><a href="#2、常用的辅助类1：CountDownLatch" class="headerlink" title="2、常用的辅助类1：CountDownLatch"></a>2、常用的辅助类1：CountDownLatch</h2><p>&emsp;&emsp;CountDownLatch是一个同步辅助类，通过它可以完成类似于阻塞当前线程的功能（类似倒数计时器），即：一个线程或多个线程一直等待，直到其他线程执行的操作完成。CountDownLatch用一个给定的计数器来初始化，该计数器的操作是原子操作，即同时只能有一个线程去操作该计数器。调用该类await方法的线程会一直处于阻塞状态，直到其他线程调用countDown方法使当前计数器的值变为零，每次调用countDown计数器的值减1。当计数器值减至零时，所有因调用await()方法而处于等待状态的线程就会继续往下执行。这种现象只会出现一次，因为计数器不能被重置，如果业务上需要一个可以重置计数次数的版本，可以考虑使用CycliBarrier。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210427231403736.png" alt="image-20210427231403736"></p><h3 id="2-1、API"><a href="#2-1、API" class="headerlink" title="2.1、API"></a>2.1、API</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用该方法的线程进入等待状态，直到计数器的值减至0或者该线程被其他线程Interrupted</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用该方法的线程进入等待状态，直到计数器的值减至0或者该线程被其他线程Interrupted或者等待时间超过指定的时间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireSharedNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//减少计数器 当前的值，每次调用值减少1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取计数器 当前的值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.getCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2、牛刀小试"><a href="#2-2、牛刀小试" class="headerlink" title="2.2、牛刀小试"></a>2.2、牛刀小试</h3><p>&emsp;&emsp;现在有一个教室，里面有六名学生和一名老师，老师需要在所有学生离开后才可以关闭教室，代码模拟如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.g4b.juc.callableTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; Go Out&quot;</span>);</span><br><span class="line">                countDownLatch.countDown();<span class="comment">//计数器 -1</span></span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        countDownLatch.await();<span class="comment">// 等待计数器归零，然后再向下执行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;计数器归零。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210427232338724.png" alt="image-20210427232338724"></p><h3 id="2-3、实际场景模拟"><a href="#2-3、实际场景模拟" class="headerlink" title="2.3、实际场景模拟"></a>2.3、实际场景模拟</h3><p>&emsp;&emsp;在某些业务场景中，程序执行需要等待某个条件完成后才能继续执行后续的操作；典型的应用如并行计算，当某个处理的运算量很大时，可以将该运算任务拆分成多个子任务，等待所有的子任务都完成之后，父任务再拿到所有子任务的运算结果进行汇总。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.g4b.juc.callableTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Integer taskNumber = <span class="number">10</span>;</span><br><span class="line">        AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">        CountDownLatch readyLatch = <span class="keyword">new</span> CountDownLatch(taskNumber);</span><br><span class="line">        CountDownLatch startLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        CountDownLatch endLatch = <span class="keyword">new</span> CountDownLatch(taskNumber);</span><br><span class="line"></span><br><span class="line">        Executor executor = Executors.newCachedThreadPool();</span><br><span class="line">        System.out.println(<span class="string">&quot;&gt;&gt;&gt;   main线程启动，开始分发任务&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= taskNumber; i++) &#123;</span><br><span class="line">            Task task = <span class="keyword">new</span> Task(String.valueOf(i),count,readyLatch,startLatch,endLatch);</span><br><span class="line">            executor.execute(task);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;&gt;&gt;&gt;   main线程启动，正在等待所有子任务就绪&quot;</span>);</span><br><span class="line">        readyLatch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;&gt;&gt;&gt;   main线程启动，所有子任务准备就绪，通知子任务开始执行&quot;</span>);</span><br><span class="line">        startLatch.countDown();</span><br><span class="line">        endLatch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;&gt;&gt;&gt;   main线程启动，所有子任务执行结束，获取结果：&quot;</span>+ count.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String taskCode;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger count;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch readyLatch;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch startLatch;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch endLatch;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(String taskCode, AtomicInteger count, CountDownLatch readyLatch, CountDownLatch startLatch, CountDownLatch endLatch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.taskCode = taskCode;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">        <span class="keyword">this</span>.readyLatch = readyLatch;</span><br><span class="line">        <span class="keyword">this</span>.startLatch = startLatch;</span><br><span class="line">        <span class="keyword">this</span>.endLatch = endLatch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;子任务  线程&quot;</span>+taskCode+<span class="string">&quot; 已经准备就绪&quot;</span>);</span><br><span class="line">            readyLatch.countDown();</span><br><span class="line">            startLatch.await();</span><br><span class="line">            System.out.println(<span class="string">&quot;子任务  线程&quot;</span>+taskCode+<span class="string">&quot; 执行开始&quot;</span>);</span><br><span class="line">            Integer number = count.addAndGet(Integer.valueOf(taskCode));</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;子任务  线程&quot;</span>+taskCode+<span class="string">&quot; 执行结束，当前的值为：&quot;</span>+number);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            endLatch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><blockquote><p> —   main线程启动，开始分发任务<br> —   main线程启动，正在等待所有子任务就绪<br>子任务  线程4 已经准备就绪<br>子任务  线程9 已经准备就绪<br>子任务  线程6 已经准备就绪<br>子任务  线程5 已经准备就绪<br>子任务  线程8 已经准备就绪<br>子任务  线程3 已经准备就绪<br>子任务  线程2 已经准备就绪<br>子任务  线程7 已经准备就绪<br>子任务  线程10 已经准备就绪<br>子任务  线程1 已经准备就绪<br> —   main线程启动，所有子任务准备就绪，通知子任务开始执行<br>子任务  线程4 执行开始<br>子任务  线程6 执行开始<br>子任务  线程2 执行开始<br>子任务  线程1 执行开始<br>子任务  线程9 执行开始<br>子任务  线程10 执行开始<br>子任务  线程7 执行开始<br>子任务  线程3 执行开始<br>子任务  线程5 执行开始<br>子任务  线程8 执行开始<br>子任务  线程1 执行结束，当前的值为：13<br>子任务  线程10 执行结束，当前的值为：32<br>子任务  线程4 执行结束，当前的值为：4<br>子任务  线程9 执行结束，当前的值为：22<br>子任务  线程3 执行结束，当前的值为：42<br>子任务  线程8 执行结束，当前的值为：55<br>子任务  线程7 执行结束，当前的值为：39<br>子任务  线程6 执行结束，当前的值为：10<br>子任务  线程2 执行结束，当前的值为：12<br>子任务  线程5 执行结束，当前的值为：47<br> —   main线程启动，所有子任务执行结束，获取结果：55</p></blockquote><h2 id="3、常用的辅助类2：CyclicBarrier"><a href="#3、常用的辅助类2：CyclicBarrier" class="headerlink" title="3、常用的辅助类2：CyclicBarrier"></a>3、常用的辅助类2：CyclicBarrier</h2><p>&emsp;&emsp;CyclicBarrier也是一个同步辅助类，它允许一组线程相互等待，直到到达某个公共屏障点（common barrier point）。通过它可以完成多个线程之间相互等待，只有当每个线程都准备就绪后，才能各自继续往下执行后面的操作。类似于CountDownLatch，它也是通过计数器来实现的。当某个线程调用await方法时，该线程进入等待状态，且计数器加1，当计数器的值达到设置的初始值时，所有因调用await进入等待状态的线程被唤醒，继续执行后续操作。因为CycliBarrier在释放等待线程后可以重用，所以称为循环barrier。CycliBarrier支持一个可选的Runnable，在计数器的值到达设定值后（但在释放所有线程之前），该Runnable运行一次，注，Runnable在每个屏障点只运行一个。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210427232747783.png" alt="image-20210427232747783"></p><h3 id="3-1、API"><a href="#3-1、API" class="headerlink" title="3.1、API"></a>3.1、API</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用该方法的线程进入等待状态，并且计数器加1，直到调用该方法的线程数达到设置值后或该线程被其他Interrputed</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// cannot happen;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用该方法的线程进入等待状态，并且计数器加1，直到调用该方法的线程数达到设置值后或该线程被其他Interrputed或者等待时间超过指定时间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException,</span></span><br><span class="line"><span class="function">           BrokenBarrierException,</span></span><br><span class="line"><span class="function">           TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dowait(<span class="keyword">true</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断该Barrier是否处于broker状态</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBroken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> generation.broken;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重置barrier进入初始状态</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        breakBarrier();   <span class="comment">// break the current generation</span></span><br><span class="line">        nextGeneration(); <span class="comment">// start a new generation</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2、牛刀小试"><a href="#3-2、牛刀小试" class="headerlink" title="3.2、牛刀小试"></a>3.2、牛刀小试</h3><p>&emsp;&emsp;问题：集齐七颗龙珠，可以召唤神龙。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.g4b.juc.callableTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">7</span>,() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;龙珠已集齐，召唤神龙！&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> Integer temp = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;收集第&quot;</span>+temp+<span class="string">&quot;个龙珠&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210428115953764.png" alt="image-20210428115953764"></p><h3 id="3-3、实际场景模拟"><a href="#3-3、实际场景模拟" class="headerlink" title="3.3、实际场景模拟"></a>3.3、实际场景模拟</h3><p>&emsp;&emsp;CyclicBarrier的使用场景和CountDownLatch，但他们俩还是有一定差别：</p><ul><li>CountDownLatch主要是实现了1个或N个线程需要等待其他线程完成某项操作之后才能继续往下执行操作，描述的是<strong>1个线程或N个线程等待其他线程的关系</strong>。CyclicBarrier主要是实现了<strong>多个线程之间相互等待</strong>，直到所有的线程都满足了条件之后各自才能继续执行后续的操作，描述的是<strong>多个线程内部相互等待的关系</strong>；</li><li>CountDownLatch是一次性的，而CyclicBarrier则可以被重置而重复使用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.g4b.juc.callableTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer taskNumber = <span class="number">10</span>;</span><br><span class="line">        AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">        CyclicBarrier startCyclicBarrier = <span class="keyword">new</span> CyclicBarrier(taskNumber,() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;&gt;&gt;&gt;   main线程启动，所有子任务准备就绪，通知子任务开始执行&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        CyclicBarrier endCyclicBarrier = <span class="keyword">new</span> CyclicBarrier(taskNumber,() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;&gt;&gt;&gt;   main线程启动，所有子任务执行结束，获取结果：&quot;</span>+ count.get());</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;&gt;&gt;&gt;   main线程启动，开始分发任务&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;&gt;&gt;&gt;   main线程启动，正在等待所有子任务就绪&quot;</span>);</span><br><span class="line">        Executor executor = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Task2 task = <span class="keyword">new</span> Task2(String.valueOf(i),count,startCyclicBarrier,endCyclicBarrier);</span><br><span class="line">            executor.execute(task);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String taskCode;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger count;</span><br><span class="line">    <span class="keyword">private</span> CyclicBarrier startCyclicBarrier;</span><br><span class="line">    <span class="keyword">private</span> CyclicBarrier endCyclicBarrier;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Task2</span><span class="params">(String taskCode, AtomicInteger count, CyclicBarrier startCyclicBarrier, CyclicBarrier endCyclicBarrier)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.taskCode = taskCode;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">        <span class="keyword">this</span>.startCyclicBarrier = startCyclicBarrier;</span><br><span class="line">        <span class="keyword">this</span>.endCyclicBarrier = endCyclicBarrier;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子任务  线程&quot;</span>+taskCode+<span class="string">&quot; 已经准备就绪&quot;</span>);</span><br><span class="line">            startCyclicBarrier.await();</span><br><span class="line">            System.out.println(<span class="string">&quot;子任务  线程&quot;</span>+ taskCode +<span class="string">&quot; 执行开始&quot;</span>);</span><br><span class="line">            Integer number = count.addAndGet(Integer.valueOf(taskCode));</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;子任务  线程&quot;</span>+taskCode+<span class="string">&quot; 执行结束，当前的值为：&quot;</span>+number);</span><br><span class="line">            endCyclicBarrier.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><blockquote><p>—  main线程启动，开始分发任务<br>—  main线程启动，正在等待所有子任务就绪<br>子任务  线程2 已经准备就绪<br>子任务  线程1 已经准备就绪<br>子任务  线程3 已经准备就绪<br>子任务  线程6 已经准备就绪<br>子任务  线程7 已经准备就绪<br>子任务  线程8 已经准备就绪<br>子任务  线程4 已经准备就绪<br>子任务  线程5 已经准备就绪<br>子任务  线程9 已经准备就绪<br>子任务  线程10 已经准备就绪<br>—  main线程启动，所有子任务准备就绪，通知子任务开始执行<br>子任务  线程10 执行开始<br>子任务  线程2 执行开始<br>子任务  线程1 执行开始<br>子任务  线程3 执行开始<br>子任务  线程4 执行开始<br>子任务  线程8 执行开始<br>子任务  线程7 执行开始<br>子任务  线程6 执行开始<br>子任务  线程9 执行开始<br>子任务  线程5 执行开始<br>子任务  线程1 执行结束，当前的值为：13<br>子任务  线程10 执行结束，当前的值为：10<br>子任务  线程4 执行结束，当前的值为：20<br>子任务  线程2 执行结束，当前的值为：12<br>子任务  线程3 执行结束，当前的值为：16<br>子任务  线程9 执行结束，当前的值为：50<br>子任务  线程5 执行结束，当前的值为：55<br>子任务  线程7 执行结束，当前的值为：35<br>子任务  线程8 执行结束，当前的值为：28<br>子任务  线程6 执行结束，当前的值为：41<br>—  main线程启动，所有子任务执行结束，获取结果：55</p></blockquote><h2 id="4、常用的辅助类3：Semaphore"><a href="#4、常用的辅助类3：Semaphore" class="headerlink" title="4、常用的辅助类3：Semaphore"></a>4、常用的辅助类3：Semaphore</h2><p>&emsp;&emsp;信号量（semaphore）是在多线程环境下负责协调各个线程，正确合理的使用公用资源。Semaphore是基于计数的信号量。它可以设定一个阈值，多个线程竞争获取许可信号，做完自己的申请后归还，超过阈值后，线程申请许可信号将会被阻塞。Semaphore可以用来构建一些对象池，资源池之类的，比如数据库连接池，我们也可以创建计数为1的Semaphore，将其作为一种类似互斥锁的机制。</p><p>&emsp;&emsp;我们可以理解Semaphore是一个停车场，而停车场的车位是固定的，当停车场停满车时，则新的车就不能停进来，而必须等到停车场的车开走时才能够给新的车停放。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210428141708667.png" alt="image-20210428141708667"></p><h3 id="4-1、API"><a href="#4-1、API" class="headerlink" title="4.1、API"></a>4.1、API</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得信号量，并阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放信号量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2、牛刀小试"><a href="#4-2、牛刀小试" class="headerlink" title="4.2、牛刀小试"></a>4.2、牛刀小试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.g4b.juc.callableTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//代表有三个停车位</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;抢到车位&quot;</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;离开车位&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210428145116609.png" alt="image-20210428145116609"></p><h3 id="3、实际场景模拟"><a href="#3、实际场景模拟" class="headerlink" title="3、实际场景模拟"></a>3、实际场景模拟</h3><p>&emsp;&emsp;Semaphore常用于仅能提供有限访问的资源，如数据库链接数最大只有20， 而上层应用并发数远大于20，如果同时对数据库进行操作，则就会出现因无法获取数据库连接数而导致的异常。此时就可以通过该信号量来做并发访问限制。【也就是所谓的限流】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.g4b.juc.callableTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//执行线程池</span></span><br><span class="line">        Executor executor = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//初始化信号量</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">4</span>);</span><br><span class="line">        <span class="comment">//任务执行完成信号</span></span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line">        log.info(<span class="string">&quot;---  main线程启动，所有子任务准备就绪，通知子任务开始执行&quot;</span>);</span><br><span class="line">        <span class="comment">//执行任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            executor.execute(<span class="keyword">new</span> Task3(semaphore, countDownLatch));</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">       log.info(<span class="string">&quot;---  main线程启动，所有子任务执行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task3</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Semaphore semaphore;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Task3</span><span class="params">(Semaphore semaphore, CountDownLatch countDownLatch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.semaphore = semaphore;</span><br><span class="line">        <span class="keyword">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            semaphore.acquire();</span><br><span class="line">            log.info(<span class="string">&quot;子任务&#123;&#125;: 执行中...&quot;</span>,Thread.currentThread().getName());</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            log.info(<span class="string">&quot;子任务&#123;&#125;: 执行结束&quot;</span>,Thread.currentThread().getName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            semaphore.release();</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>15:27:00.689 [main] INFO cn.g4b.juc.callableTask.SemaphoreDemo2 - —  main线程启动，所有子任务准备就绪，通知子任务开始执行<br>15:27:00.697 [pool-1-thread-10] INFO cn.g4b.juc.callableTask.Task3 - 子任务pool-1-thread-10: 执行中…<br>15:27:00.697 [pool-1-thread-6] INFO cn.g4b.juc.callableTask.Task3 - 子任务pool-1-thread-6: 执行中…<br>15:27:00.696 [pool-1-thread-5] INFO cn.g4b.juc.callableTask.Task3 - 子任务pool-1-thread-5: 执行中…<br>15:27:00.696 [pool-1-thread-4] INFO cn.g4b.juc.callableTask.Task3 - 子任务pool-1-thread-4: 执行中…<br>15:27:02.699 [pool-1-thread-6] INFO cn.g4b.juc.callableTask.Task3 - 子任务pool-1-thread-6: 执行结束<br>15:27:02.699 [pool-1-thread-10] INFO cn.g4b.juc.callableTask.Task3 - 子任务pool-1-thread-10: 执行结束<br>15:27:02.699 [pool-1-thread-5] INFO cn.g4b.juc.callableTask.Task3 - 子任务pool-1-thread-5: 执行结束<br>15:27:02.699 [pool-1-thread-2] INFO cn.g4b.juc.callableTask.Task3 - 子任务pool-1-thread-2: 执行中…<br>15:27:02.699 [pool-1-thread-1] INFO cn.g4b.juc.callableTask.Task3 - 子任务pool-1-thread-1: 执行中…<br>15:27:02.699 [pool-1-thread-3] INFO cn.g4b.juc.callableTask.Task3 - 子任务pool-1-thread-3: 执行中…<br>15:27:02.700 [pool-1-thread-4] INFO cn.g4b.juc.callableTask.Task3 - 子任务pool-1-thread-4: 执行结束<br>15:27:02.700 [pool-1-thread-7] INFO cn.g4b.juc.callableTask.Task3 - 子任务pool-1-thread-7: 执行中…<br>15:27:04.699 [pool-1-thread-3] INFO cn.g4b.juc.callableTask.Task3 - 子任务pool-1-thread-3: 执行结束<br>15:27:04.699 [pool-1-thread-2] INFO cn.g4b.juc.callableTask.Task3 - 子任务pool-1-thread-2: 执行结束<br>15:27:04.699 [pool-1-thread-1] INFO cn.g4b.juc.callableTask.Task3 - 子任务pool-1-thread-1: 执行结束<br>15:27:04.699 [pool-1-thread-8] INFO cn.g4b.juc.callableTask.Task3 - 子任务pool-1-thread-8: 执行中…<br>15:27:04.699 [pool-1-thread-9] INFO cn.g4b.juc.callableTask.Task3 - 子任务pool-1-thread-9: 执行中…<br>15:27:04.700 [pool-1-thread-7] INFO cn.g4b.juc.callableTask.Task3 - 子任务pool-1-thread-7: 执行结束<br>15:27:06.700 [pool-1-thread-9] INFO cn.g4b.juc.callableTask.Task3 - 子任务pool-1-thread-9: 执行结束<br>15:27:06.700 [pool-1-thread-8] INFO cn.g4b.juc.callableTask.Task3 - 子任务pool-1-thread-8: 执行结束<br>15:27:06.700 [main] INFO cn.g4b.juc.callableTask.SemaphoreDemo2 - —  main线程启动，所有子任务执行结束</p></blockquote><h1 id="五、读写锁与阻塞队列"><a href="#五、读写锁与阻塞队列" class="headerlink" title="五、读写锁与阻塞队列"></a>五、读写锁与阻塞队列</h1><h2 id="1、读写锁（ReadWriteLock）"><a href="#1、读写锁（ReadWriteLock）" class="headerlink" title="1、读写锁（ReadWriteLock）"></a>1、读写锁（ReadWriteLock）</h2><p>&emsp;&emsp;ReadWriteLock管理一组锁，一个是只读的锁，一个是写锁。读锁可以在没有写锁的时候被多个线程同时持有，写锁是独占的。<br>&emsp;&emsp;所有读写锁的实现必须确保写操作对读操作的内存影响。换句话说，一个获得了读锁的线程必须能看到前一个释放的写锁所更新的内容。<br>&emsp;&emsp;读写锁比互斥锁允许对于共享数据更大程度的并发。每次只能有一个写线程，但是同时可以有多个线程并发地读数据。ReadWriteLock适用于读多写少的并发情况。<br>&emsp;&emsp;Java并发包中ReadWriteLock是一个接口，主要有两个方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadWriteLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 返回读锁</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">Lock <span class="title">readLock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回写锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Lock <span class="title">writeLock</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210428171436886.png" alt="image-20210428171436886"></p><h3 id="1-1、ReentrantReadWriteLock的特性"><a href="#1-1、ReentrantReadWriteLock的特性" class="headerlink" title="1.1、ReentrantReadWriteLock的特性"></a>1.1、ReentrantReadWriteLock的特性</h3><p>①、<strong>获取锁的顺序</strong></p><ul><li>非公平模式（默认）：当以非公平初始化时，读锁和写锁的获取的顺序是不确定的。非公平锁主张竞争获取，可能会延缓一个或多个读或写线程，但是会比公平锁有更高的吞吐量。</li><li>公平模式：当以公平模式初始化时，线程将会以队列的顺序获取锁。当当前线程释放锁后，等待时间最长的写锁线程就会被分配写锁；或者有一组读线程组等待时间比写线程长，那么这组读线程组将会被分配读锁。</li></ul><p>&emsp;&emsp;当有写线程持有写锁或者有等待的写线程时，一个尝试获取公平的读锁（非重入）的线程就会阻塞。这个线程直到等待时间最长的写锁获得锁后并释放掉锁后才能获取到读锁。</p><p>②、<strong>是否可重入</strong><br>&emsp;&emsp;允许读锁可写锁可重入。写锁可以获得读锁，读锁不能获得写锁。<br>③、<strong>锁降级</strong><br>&emsp;&emsp;允许写锁降低为读锁。<br>④、<strong>中断锁的获取</strong><br>&emsp;&emsp;在读锁和写锁的获取过程中支持中断。<br>⑤、<strong>支持Condition</strong><br>&emsp;&emsp;写锁提供Condition实现<br>⑥、<strong>监控</strong><br>&emsp;&emsp;提供确定锁是否被持有等辅助方法</p><h3 id="1-2、测试代码"><a href="#1-2、测试代码" class="headerlink" title="1.2、测试代码"></a>1.2、测试代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.g4b.juc.RW;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CacheLock cacheLock = <span class="keyword">new</span> CacheLock();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> String str = i+<span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                cacheLock.put(str,str);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> String str = i+<span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                cacheLock.get(str);</span><br><span class="line">            &#125;,String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CacheLock</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> ReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存，写入的时候，只希望同时只有一个线程写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key,Object value)</span></span>&#123;</span><br><span class="line">        readWriteLock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;写入&quot;</span>+key);</span><br><span class="line">            map.put(key,value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;写入OK&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readWriteLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取，读，所有人都可以读！</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        readWriteLock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;读取&quot;</span>+key);</span><br><span class="line">            Object o = map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;读取OK&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readWriteLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210428173250080.png" alt="image-20210428173250080"></p><h2 id="2、阻塞队列"><a href="#2、阻塞队列" class="headerlink" title="2、阻塞队列"></a>2、阻塞队列</h2><p>&emsp;&emsp;多线程环境中，通过队列可以很容易实现数据共享， 比如经典的“生产者”和“消费者”模型中，通过队列可以很便利地实现两者之间的数据共享。 假设我们有若干生产者线程，另外又有若干个消费者线程。 如果生产者线程需要把准备好的数据共享给消费者线程，利用队列的方式来传递数据，就可以很方便地解决他们之间的数据共享问题。 但如果生产者和消费者在某个时间段内，万一发生数据处理速度不匹配的情况呢？ 理想情况下，如果生产者产出数据的速度大于消费者消费的速度， 并且当生产出来的数据累积到一定程度的时候，那么生产者必须暂停等待一下（阻塞生产者线程）， 以便等待消费者线程把累积的数据处理完毕，反之亦然。</p><p>&emsp;&emsp;然而，在concurrent包发布以前，在多线程环境下，我们每个程序员都必须去自己控制这些细节， 尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。 好在此时，强大的concurrent包横空出世了，而他也给我们带来了强大的BlockingQueue。 （在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动被唤醒）。</p><p>&emsp;&emsp;所以，阻塞队列就出现了。阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作支持阻塞的插入和移除方法。</p><ul><li>支持阻塞的插入方法：当队列满时，队列会阻塞插入元素的线程，直到队列中至少有一个元素被移出。</li><li>支持阻塞的移除方法：当队列为空时，获取元素的线程会等待队列直至至少有一个元素插入队列。</li></ul><p>&emsp;&emsp;我们从源码发现，BlockingQueue并不是一类新的事物，他的上一级Queue和我们经常使用的List和Set属于同一级。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210429145407117.png" alt="image-20210429145407117"></p><p>&emsp;&emsp;而阻塞队列在我们日常的使用中是非常常见的，最常见的位置莫过于XX池，例如：JDBC连接池、线程池等。</p><h3 id="2-1、BlockingQueue的实现"><a href="#2-1、BlockingQueue的实现" class="headerlink" title="2.1、BlockingQueue的实现"></a>2.1、BlockingQueue的实现</h3><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210429151421684.png" alt="image-20210429151421684"></p><p>实现类的简单介绍：</p><ul><li><font color='red'>ArrayBlockingQueue：由数组结构组成的有界阻塞队列。</font></li><li><font color='red'>LinkedBlockingQueue：由链表结构组成的有界（但大小默认值为integer.MAX_VALUE）阻塞队列。</font></li><li>PriorityBlockingQueue：支持优先级排序的无界阻塞队列。</li><li>DelayQueue：使用优先级队列实现的延迟无界阻塞队列。</li><li><font color='red'>SynchronousQueue：不存储元素的阻塞队列，也即单个元素的队列。</font></li><li>LinkedTransferQueue：由链表组成的无界阻塞队列。</li><li>LinkedBlockingDeque：由链表组成的双向阻塞队列。</li></ul><h3 id="2-2、BlockingQueue-的操作方法"><a href="#2-2、BlockingQueue-的操作方法" class="headerlink" title="2.2、BlockingQueue 的操作方法"></a>2.2、BlockingQueue 的操作方法</h3><p>&emsp;&emsp;BlockingQueue 具有 4 组不同的方法用于插入、移除以及对队列中的元素进行检查。如果请求的操作不能得到立即执行的话，每个方法的表现也不同。这些方法如下：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210429150243899.png" alt="image-20210429150243899"></p><ul><li>抛异常：如果试图的操作无法立即执行，抛一个异常。</li><li>特定值：如果试图的操作无法立即执行，返回一个特定的值(常常是 true / false)。</li><li>阻塞：如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行。</li><li>超时：如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行，但等待时间不会超过给定值。返回一个特定值以告知该操作是否成功(典型的是true / false)。</li></ul><h3 id="2-3、测试代码"><a href="#2-3、测试代码" class="headerlink" title="2.3、测试代码"></a>2.3、测试代码</h3><p>&emsp;&emsp;该测试以ArrayBlockingQueue进行测试。</p><h4 id="2-3-1、抛异常"><a href="#2-3-1、抛异常" class="headerlink" title="2.3.1、抛异常"></a>2.3.1、抛异常</h4><p>&emsp;&emsp;操作add和remove方法，添加超量或移除时为空会直接抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BlockingQueue blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">3</span>);</span><br><span class="line">    System.out.println(blockingQueue.add(<span class="number">1</span>));</span><br><span class="line">    System.out.println(blockingQueue.add(<span class="number">2</span>));</span><br><span class="line">    System.out.println(blockingQueue.add(<span class="number">3</span>));</span><br><span class="line">    <span class="comment">//System.out.println(blockingQueue.add(4));</span></span><br><span class="line">    System.out.println(blockingQueue.remove());</span><br><span class="line">    System.out.println(blockingQueue.remove());</span><br><span class="line">    System.out.println(blockingQueue.remove());</span><br><span class="line">    System.out.println(blockingQueue.remove());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210429153534061.png" alt="image-20210429153534061"></p><h4 id="2-3-2、特定值"><a href="#2-3-2、特定值" class="headerlink" title="2.3.2、特定值"></a>2.3.2、特定值</h4><p>&emsp;&emsp;操作offer和poll方法，添加超量时会返回false，移除时为空会返回null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BlockingQueue blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">3</span>);</span><br><span class="line">    System.out.println(blockingQueue.offer(<span class="number">1</span>));</span><br><span class="line">    System.out.println(blockingQueue.offer(<span class="number">2</span>));</span><br><span class="line">    System.out.println(blockingQueue.offer(<span class="number">3</span>));</span><br><span class="line">    <span class="comment">//System.out.println(blockingQueue.offer(4));</span></span><br><span class="line">    System.out.println(blockingQueue.poll());</span><br><span class="line">    System.out.println(blockingQueue.poll());</span><br><span class="line">    System.out.println(blockingQueue.poll());</span><br><span class="line">    System.out.println(blockingQueue.poll());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210429154419754.png" alt="image-20210429154419754"></p><h4 id="2-3-3、阻塞"><a href="#2-3-3、阻塞" class="headerlink" title="2.3.3、阻塞"></a>2.3.3、阻塞</h4><p>&emsp;&emsp;操作put和take方法，添加超量或移除时为空时会阻塞等待。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    BlockingQueue blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">3</span>);</span><br><span class="line">    blockingQueue.put(<span class="number">1</span>);</span><br><span class="line">    blockingQueue.put(<span class="number">2</span>);</span><br><span class="line">    blockingQueue.put(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">//blockingQueue.put(4);</span></span><br><span class="line">    System.out.println(blockingQueue.take());</span><br><span class="line">    System.out.println(blockingQueue.take());</span><br><span class="line">    System.out.println(blockingQueue.take());</span><br><span class="line">    System.out.println(blockingQueue.take());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210429155143167.png" alt="image-20210429155143167"></p><h4 id="2-3-4、超时"><a href="#2-3-4、超时" class="headerlink" title="2.3.4、超时"></a>2.3.4、超时</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    BlockingQueue blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">3</span>);</span><br><span class="line">    System.out.println(blockingQueue.offer(<span class="number">1</span>, <span class="number">2</span>, TimeUnit.SECONDS));</span><br><span class="line">    System.out.println(blockingQueue.offer(<span class="number">2</span>, <span class="number">2</span>, TimeUnit.SECONDS));</span><br><span class="line">    System.out.println(blockingQueue.offer(<span class="number">3</span>, <span class="number">2</span>, TimeUnit.SECONDS));</span><br><span class="line">    <span class="comment">//System.out.println(blockingQueue.offer(4, 2, TimeUnit.SECONDS));</span></span><br><span class="line">    System.out.println(blockingQueue.poll(<span class="number">2</span>,TimeUnit.SECONDS));</span><br><span class="line">    System.out.println(blockingQueue.poll(<span class="number">2</span>,TimeUnit.SECONDS));</span><br><span class="line">    System.out.println(blockingQueue.poll(<span class="number">2</span>,TimeUnit.SECONDS));</span><br><span class="line">    System.out.println(blockingQueue.poll(<span class="number">2</span>,TimeUnit.SECONDS));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210430143028970.png" alt="image-20210430143028970"></p><h3 id="2-4、SynchronousQueue-同步队列"><a href="#2-4、SynchronousQueue-同步队列" class="headerlink" title="2.4、SynchronousQueue   同步队列"></a>2.4、SynchronousQueue   同步队列</h3><p>&emsp;&emsp;SynchronousQueue是没有容量的队列，即保存一个元素之后，就必须取出一个元素才可以保存第二个元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.g4b.juc.RW;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.SynchronousQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronousQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SynchronousQueue queue = <span class="keyword">new</span> SynchronousQueue();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;放进去：A&quot;</span>);</span><br><span class="line">                queue.put(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;放进去：B&quot;</span>);</span><br><span class="line">                queue.put(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;放进去：C&quot;</span>);</span><br><span class="line">                queue.put(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;取出 &quot;</span> +queue.take());</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;取出 &quot;</span> +queue.take());</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;取出 &quot;</span> +queue.take());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210430145425691.png" alt="image-20210430145425691"></p>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 锁 </tag>
            
            <tag> JUC </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8新特性——Lambda表达式及Stream API</title>
      <link href="/blog/2021/05/02/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8F%8AStream%E6%B5%81/"/>
      <url>/blog/2021/05/02/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8F%8AStream%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="Java8新特性——Lambda表达式及Stream-API"><a href="#Java8新特性——Lambda表达式及Stream-API" class="headerlink" title="Java8新特性——Lambda表达式及Stream API"></a>Java8新特性——Lambda表达式及Stream API</h1><h2 id="一、Lambda表达式"><a href="#一、Lambda表达式" class="headerlink" title="一、Lambda表达式"></a>一、Lambda表达式</h2><h3 id="1、为什么会使用Lambda表达式"><a href="#1、为什么会使用Lambda表达式" class="headerlink" title="1、为什么会使用Lambda表达式"></a>1、为什么会使用Lambda表达式</h3><p>&emsp;&emsp;Lambda是一个匿名函数，可以理解为一段可以传递的代码（将代码像数据一样传递）；可以写出<font color="red"><strong>更简洁、更灵活的代码</strong></font>；作为一种更紧凑的代码风格，是Java语言表达能力得到提升。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//匿名内部类的写法</span></span><br><span class="line">    Comparable&lt;Integer&gt; comparable = <span class="keyword">new</span> Comparable&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Integer o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o+<span class="number">1111</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(comparable.compareTo(<span class="number">100</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;--------------------------------------------------&quot;</span>);</span><br><span class="line">    <span class="comment">//Lambda表达式的写法</span></span><br><span class="line">    comparable = (num) -&gt; num+<span class="number">1314</span>;</span><br><span class="line">    System.out.println(comparable.compareTo(<span class="number">100</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7&emsp;&emsp;从上述代码可以看出，原本六行代码压缩成了一行解决，而且能够解决相同的问题。</p><h3 id="2、Lambda表达式的使用格式"><a href="#2、Lambda表达式的使用格式" class="headerlink" title="2、Lambda表达式的使用格式"></a>2、Lambda表达式的使用格式</h3><p><font color="red">*Lambda 表达式 参数的数据类型可以省略不写是因为 Jvm可以自动进行 “类型推断”</font></p><h4 id="2-1、格式1：无参数，无返回值"><a href="#2-1、格式1：无参数，无返回值" class="headerlink" title="2.1、格式1：无参数，无返回值"></a>2.1、格式1：无参数，无返回值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**测试Lambda表达式语法格式1：无参数，无返回值：() -&gt; sout*/</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;测试Lambda表达式语法格式1：无参数，无返回值：() -&gt; sout——原方式&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.run();</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------------------------------&quot;</span>);</span><br><span class="line">        Runnable runnable = () -&gt; System.out.println(<span class="string">&quot;测试Lambda表达式语法格式1：无参数，无返回值：() -&gt; sout——Lambda方式&quot;</span>);</span><br><span class="line">        runnable.run();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="2-2、格式2：有参数，无返回值"><a href="#2-2、格式2：有参数，无返回值" class="headerlink" title="2.2、格式2：有参数，无返回值"></a>2.2、格式2：有参数，无返回值</h4><p><font color="red">*参数的括号可以不写</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Consumer&lt;String&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">                System.out.println(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.accept(<span class="string">&quot;测试Lambda表达式语法格式2：有参数，无返回值&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------------------------------&quot;</span>);</span><br><span class="line">        Consumer&lt;String&gt; consumer = x -&gt; System.out.println(x);</span><br><span class="line">        consumer.accept(<span class="string">&quot;测试Lambda表达式语法格式2：有参数，无返回值&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="2-3、格式3：有两个及以上的参数，有返回值"><a href="#2-3、格式3：有两个及以上的参数，有返回值" class="headerlink" title="2.3、格式3：有两个及以上的参数，有返回值"></a>2.3、格式3：有两个及以上的参数，有返回值</h4><p><font color="red">*Lambda体只有一条语句，则不需要写return和大括号，否则都要写</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> compare = <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o1 + o2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.compare(<span class="number">12</span>, <span class="number">23</span>);</span><br><span class="line">    System.out.println(compare);</span><br><span class="line">    System.out.println(<span class="string">&quot;--------------------------------------------------&quot;</span>);</span><br><span class="line">    Comparator&lt;Integer&gt; comparator = (o1, o2) -&gt; o1 - o2;</span><br><span class="line">    System.out.println(comparator.compare(<span class="number">100</span>, <span class="number">98</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、函数式接口"><a href="#3、函数式接口" class="headerlink" title="3、函数式接口"></a>3、函数式接口</h3><h4 id="3-1、函数式接口"><a href="#3-1、函数式接口" class="headerlink" title="3.1、函数式接口"></a>3.1、函数式接口</h4><ul><li>接口中只有一个抽象方法的接口 ，可使用@FunctionalIterface进行校验,符合函数式接口的类才可以使用Lambda表达式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyFunTion</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">checkStr</span><span class="params">(T str1,T str2,T str3)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MyFunTion&lt;Integer&gt; myFunTion = (str1,str2,str3) -&gt; str1 + str2 + str3;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行结果：&quot;</span>+myFunTion.checkStr(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------------------------------&quot;</span>);</span><br><span class="line">        MyFunTion&lt;String&gt; myFunTion2 = (str1,str2,str3) -&gt; str1 + str2 + str3;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行结果：&quot;</span>+myFunTion2.checkStr(<span class="string">&quot;今天&quot;</span>, <span class="string">&quot;天气&quot;</span>, <span class="string">&quot;真好！！&quot;</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">执行结果：6</span><br><span class="line">--------------------------------------------------</span><br><span class="line">执行结果：今天天气真好！！</span><br></pre></td></tr></table></figure><h4 id="3-2、Java内置四大核心函数式接口"><a href="#3-2、Java内置四大核心函数式接口" class="headerlink" title="3.2、Java内置四大核心函数式接口"></a>3.2、Java内置四大核心函数式接口</h4><table><thead><tr><th>函数式接口</th><th>参数类型</th><th>返回类型</th><th>用途</th></tr></thead><tbody><tr><td>Consumer<br/>消费型接口</td><td>T</td><td>void</td><td>对类型为T的对象应用操作：void accept(T t)</td></tr><tr><td>Supplier<br/>提供型接口</td><td>无</td><td>T</td><td>返回类型为T的对象：T get()</td></tr><tr><td>Function&lt;T, R&gt;<br/>函数型接口</td><td>T</td><td>R</td><td>对类型为T的对象应用操作，并返回结果为R类型的对象：R apply(T t)</td></tr><tr><td>Predicate<br/>断言型接口</td><td>T</td><td>boolean</td><td>确定类型为T的对象是否满足某约束，并返回boolean值：boolean test(T t)</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------测试消费型接口--------------------------&quot;</span>);</span><br><span class="line">        Consumer&lt;String&gt; consumer = x -&gt; System.out.println(x);</span><br><span class="line">        consumer.accept(<span class="string">&quot;测试&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------测试提供型接口--------------------------&quot;</span>);</span><br><span class="line">        Supplier&lt;String&gt; stringSupplier = () -&gt; <span class="string">&quot;提供回复超科技福克斯&quot;</span>;</span><br><span class="line">        System.out.println(stringSupplier.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------测试函数型接口--------------------------&quot;</span>);</span><br><span class="line">        Function&lt;String,Integer&gt; getStringlenth = x -&gt; x.length();</span><br><span class="line">        System.out.println(<span class="string">&quot;ugsfgcuhi的长度是：&quot;</span>+getStringlenth.apply(<span class="string">&quot;ugsfgcuhi&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------测试断言型接口--------------------------&quot;</span>);</span><br><span class="line">        Predicate&lt;String&gt; predicate = x -&gt; x.equals(<span class="string">&quot;华为&quot;</span>);</span><br><span class="line">        System.out.println(predicate.test(<span class="string">&quot;华为&quot;</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="3-3、Java其他函数式接口"><a href="#3-3、Java其他函数式接口" class="headerlink" title="3.3、Java其他函数式接口"></a>3.3、Java其他函数式接口</h4><table><thead><tr><th>函数式接口</th><th>参数类型</th><th>返回类型</th><th>用途</th></tr></thead><tbody><tr><td>BiFunction&lt;T,U,R&gt;</td><td>T,U</td><td>R</td><td>T,U作为参数，R作为结果，方法是<br/>R apply(T t,U u);</td></tr><tr><td>UnaryOperator<T></td><td>T</td><td>T</td><td>对类型为T的对象进行一元运算，返回T类型的结果<br/>T apply(T t)；</td></tr><tr><td>BinaryOperator<T></td><td>T ,T</td><td>T</td><td>对类型为T的对象进行二元运算，返回T类型的结果<br/>T apply(T t1，T t2)；</td></tr><tr><td>BiConsumer&lt;T,U&gt;</td><td>T,U</td><td>void</td><td>T,U作为参数，没有返回结果，方法是<br/>void accept(T t,U u);</td></tr><tr><td>ToIntFunction<T><br/>ToLongFunction<T><br/>ToDoubleFunction<T></td><td>T</td><td>int<br/>long<br/>double</td><td>分别计算int 、long、double的函数</td></tr><tr><td>IntFunction<T><br/>LongFunction<T><br/>DoubleFunction<T></td><td>int<br/>long<br/>double</td><td>T</td><td>参数分别为int 、long、double的函数</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------测试BiFunction接口----------------------&quot;</span>);</span><br><span class="line">        BiFunction&lt;String,Integer,Boolean&gt; booleanBiFunction = (x,y) -&gt; x.length() == y;</span><br><span class="line">        System.out.println(<span class="string">&quot;测试结果：&quot;</span>+booleanBiFunction.apply(<span class="string">&quot;换位思考&quot;</span>, <span class="number">4</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------测试UnaryOperator接口----------------------&quot;</span>);</span><br><span class="line">        UnaryOperator&lt;String&gt; unaryOperator = x -&gt; x.replaceAll(<span class="string">&quot;sa&quot;</span>,<span class="string">&quot;ka&quot;</span>);</span><br><span class="line">        System.out.println(unaryOperator.apply(<span class="string">&quot;sakasaka&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------测试BinaryOperator接口---------------------&quot;</span>);</span><br><span class="line">        BinaryOperator&lt;Integer&gt; binaryOperator = (x,y) -&gt; x + x + y;</span><br><span class="line">        System.out.println(<span class="string">&quot;计算结果：&quot;</span>+binaryOperator.apply(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------测试BiConsumer接口-------------------------&quot;</span>);</span><br><span class="line">        BiConsumer&lt;String,Integer&gt; biConsumer = (x,y) -&gt; System.out.println(x+<span class="string">&quot;---&quot;</span>+y);</span><br><span class="line">        biConsumer.accept(<span class="string">&quot;你好&quot;</span>,<span class="number">666</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------测试ToLongFunction接口---------------------&quot;</span>);</span><br><span class="line">        ToLongFunction&lt;String&gt; toLongFunction = x -&gt; x.length();</span><br><span class="line">        System.out.println(toLongFunction.applyAsLong(<span class="string">&quot;feyugbqiFBUKEHIOHNFOUEW&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------测试DoubleFunction接口--------------------&quot;</span>);</span><br><span class="line">        DoubleFunction&lt;Double&gt; doubleFunction = x -&gt; x*<span class="number">0.1</span>;</span><br><span class="line">        System.out.println(doubleFunction.apply(<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="4、引用"><a href="#4、引用" class="headerlink" title="4、引用"></a>4、引用</h3><h4 id="4-1、方法引用"><a href="#4-1、方法引用" class="headerlink" title="4.1、方法引用"></a>4.1、方法引用</h4><h5 id="4-1-1、方法引用的定义："><a href="#4-1-1、方法引用的定义：" class="headerlink" title="4.1.1、方法引用的定义："></a>4.1.1、方法引用的定义：</h5><p>&emsp;&emsp;若 Lambda 表达式体中的内容已有方法实现，则我们可以使用“方法引用”</p><h5 id="4-1-2、方法引用的格式："><a href="#4-1-2、方法引用的格式：" class="headerlink" title="4.1.2、方法引用的格式："></a>4.1.2、方法引用的格式：</h5><ul><li><p>对象 :: 实例方法</p></li><li><p>类 :: 静态方法</p></li><li><p>类 :: 实例方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Consumer&lt;String&gt; consumer = x -&gt; System.out.println(x);</span><br><span class="line">        consumer.accept(<span class="string">&quot;测试1&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------测试对象 :: 实例方法----------&quot;</span>);</span><br><span class="line">        consumer = System.out::println;</span><br><span class="line">        consumer.accept(<span class="string">&quot;测试方法引用&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注意：Lambda 表达实体中调用方法的参数列表、返回类型必须和函数式接口中抽象方法保持一致</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Comparator&lt;Integer&gt; comparator = (x,y) -&gt; Integer.compare(x,y);</span><br><span class="line">        System.out.println(comparator.compare(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------测试 类 :: 静态方法--------------------&quot;</span>);</span><br><span class="line">        Comparator&lt;Integer&gt; com =  Integer::compare;</span><br><span class="line">        System.out.println(com.compare(<span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test9</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BiPredicate&lt;String,String&gt; biPredicate = (x,y) -&gt; x.equals(y);</span><br><span class="line">        System.out.println(biPredicate.test(<span class="string">&quot;山&quot;</span>, <span class="string">&quot;水&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------测试 类::实例方法--------------------&quot;</span>);</span><br><span class="line">        BiPredicate&lt;String,String&gt; biPredicate2 = String::equals;</span><br><span class="line">        System.out.println(biPredicate2.test(<span class="string">&quot;山&quot;</span>, <span class="string">&quot;山&quot;</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注意：Lambda 参数列表中的第一个参数是方法的调用者，第二个参数是方法的参数时，才能使用 ClassName :: Method</p><h4 id="4-2、构造器引用"><a href="#4-2、构造器引用" class="headerlink" title="4.2、构造器引用"></a>4.2、构造器引用</h4><p>&emsp;&emsp;格式：ClassName :: new</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test10</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Supplier&lt;List&gt; supplier = () -&gt; <span class="keyword">new</span> ArrayList();</span><br><span class="line">        List list = supplier.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------测试 ClassName :: new-----------------&quot;</span>);</span><br><span class="line">        Supplier&lt;Set&gt; setSupplier = HashSet::<span class="keyword">new</span>;</span><br><span class="line">        Set set = setSupplier.get();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注意：需要调用的构造器的参数列表要与函数时接口中抽象方法的参数列表保持一致</p><h4 id="4-3、数组引用"><a href="#4-3、数组引用" class="headerlink" title="4.3、数组引用"></a>4.3、数组引用</h4><p>&emsp;&emsp;格式：Type:: new</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test11</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------匿名内部类写法--------------------&quot;</span>);</span><br><span class="line">        Function&lt;Integer, String[]&gt; function = <span class="keyword">new</span> Function&lt;Integer, String[]&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String[] apply(Integer t) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> String[t];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        String[] array = function.apply(<span class="number">5</span>);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------Lambda表达式写法--------------------&quot;</span>);</span><br><span class="line">        Function&lt;Integer, String[]&gt; function1 = t -&gt; <span class="keyword">new</span> String[t];</span><br><span class="line">        System.out.println(Arrays.toString(function1.apply(<span class="number">5</span>)));</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------类型引用写法--------------------&quot;</span>);</span><br><span class="line">        Function&lt;Integer, String[]&gt; function2 = String[]::<span class="keyword">new</span>;</span><br><span class="line">        System.out.println(Arrays.toString(function2.apply(<span class="number">5</span>)));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="5、Lambda表达式应用"><a href="#5、Lambda表达式应用" class="headerlink" title="5、Lambda表达式应用"></a>5、Lambda表达式应用</h3><p>&emsp;&emsp;Lambda表达式一般我们会用于重写某个匿名内部类的方法或者是遍历集合，但除此之外，其实还有某些地方会使用，如：</p><h4 id="5-1、lambda表达式快速创建线程"><a href="#5-1、lambda表达式快速创建线程" class="headerlink" title="5.1、lambda表达式快速创建线程"></a>5.1、lambda表达式快速创建线程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>,<span class="number">8</span>));</span><br><span class="line">            System.out.println(list);</span><br><span class="line">        &#125;,String.valueOf(i)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2、集合中删除某些指定元素，或对元素进行排序"><a href="#5-2、集合中删除某些指定元素，或对元素进行排序" class="headerlink" title="5.2、集合中删除某些指定元素，或对元素进行排序"></a>5.2、集合中删除某些指定元素，或对元素进行排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">    list.removeIf(str -&gt; str.equals(<span class="string">&quot;C&quot;</span>));</span><br><span class="line">    System.out.println(list);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list2.add(<span class="number">33</span>);</span><br><span class="line">    list2.add(<span class="number">12</span>);</span><br><span class="line">    list2.add(<span class="number">78</span>);</span><br><span class="line">    list2.sort((o1,o2) -&gt; o1 - o2);</span><br><span class="line">    System.out.println(list2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210502165539248.png" alt="image-20210502165539248"></p><h2 id="二、Stream-API"><a href="#二、Stream-API" class="headerlink" title="二、Stream API"></a>二、Stream API</h2><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210502170210419.png" alt="image-20210502170210419"></p><h3 id="1、什么是stream？"><a href="#1、什么是stream？" class="headerlink" title="1、什么是stream？"></a>1、什么是stream？</h3><p>&emsp;&emsp;stream将要处理的元素集合看作一种流，在流的过程中，借助<code>Stream API</code>对流中的元素进行操作，比如：筛选、排序、聚合等。</p><h4 id="1-1、stream可以由数组或集合创建，对流的操作分为两种："><a href="#1-1、stream可以由数组或集合创建，对流的操作分为两种：" class="headerlink" title="1.1、stream可以由数组或集合创建，对流的操作分为两种："></a>1.1、stream可以由数组或集合创建，对流的操作分为两种：</h4><ul><li>中间操作，每次返回一个新的流，可以有多个。</li><li>终端操作，每个流只能进行一次终端操作，终端操作结束后流无法再次使用。终端操作会产生一个新的集合或值。</li></ul><h4 id="1-2、stream的特性："><a href="#1-2、stream的特性：" class="headerlink" title="1.2、stream的特性："></a>1.2、stream的特性：</h4><ul><li>stream不存储数据，而是按照特定的规则对数据进行计算，一般会输出结果。</li><li>stream不会改变数据源，通常情况下会产生一个新的集合或一个值。</li><li>stream具有延迟执行特性，只有调用终端操作时，中间操作才会执行。</li></ul><h3 id="2、Stream的创建"><a href="#2、Stream的创建" class="headerlink" title="2、Stream的创建"></a>2、Stream的创建</h3><p>&emsp;&emsp;stream可以通过集合或数组来创建，创建方式一般分为以下几种：</p><h4 id="2-1、通过-java-util-Collection-stream-方法用集合创建流"><a href="#2-1、通过-java-util-Collection-stream-方法用集合创建流" class="headerlink" title="2.1、通过 java.util.Collection.stream() 方法用集合创建流"></a>2.1、通过 <code>java.util.Collection.stream()</code> 方法用集合创建流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line"><span class="comment">// 创建一个顺序流</span></span><br><span class="line">Stream&lt;String&gt; stream = list.stream();</span><br><span class="line"><span class="comment">// 创建一个并行流</span></span><br><span class="line">Stream&lt;String&gt; parallelStream = list.parallelStream();</span><br></pre></td></tr></table></figure><h4 id="2-2、使用java-util-Arrays-stream-T-array-方法用数组创建流"><a href="#2-2、使用java-util-Arrays-stream-T-array-方法用数组创建流" class="headerlink" title="2.2、使用java.util.Arrays.stream(T[] array)方法用数组创建流"></a>2.2、使用<code>java.util.Arrays.stream(T[] array)</code>方法用数组创建流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line">IntStream stream = Arrays.stream(array);</span><br></pre></td></tr></table></figure><h4 id="2-3、使用Stream的静态方法：of-、iterate-、generate"><a href="#2-3、使用Stream的静态方法：of-、iterate-、generate" class="headerlink" title="2.3、使用Stream的静态方法：of()、iterate()、generate()"></a>2.3、使用<code>Stream</code>的静态方法：<code>of()、iterate()、generate()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">Stream&lt;Integer&gt; stream2 = Stream.iterate(<span class="number">0</span>, (x) -&gt; x + <span class="number">3</span>).limit(<span class="number">4</span>);</span><br><span class="line">stream2.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">Stream&lt;Double&gt; stream3 = Stream.generate(Math::random).limit(<span class="number">3</span>);</span><br><span class="line">stream3.forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里需要注意：<code>stream</code>是顺序流，由主线程按顺序对流执行操作，而<code>parallelStream</code>是并行流，内部以多线程并行执行的方式对流进行操作，但前提是流中的数据处理没有顺序要求。例如筛选集合中的奇数，两者的处理不同之处：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210502180436589.png" alt="image-20210502180436589"></p><p>&emsp;&emsp;顺序流可以通过parallel()转换为并行流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line"><span class="comment">// 创建一个顺序流</span></span><br><span class="line">Stream&lt;String&gt; stream = list.stream();</span><br><span class="line"><span class="comment">//将一个顺序流转换为一个并行流</span></span><br><span class="line">Stream&lt;String&gt; parallel = stream.parallel();</span><br></pre></td></tr></table></figure><h3 id="3、stream的使用"><a href="#3、stream的使用" class="headerlink" title="3、stream的使用"></a>3、stream的使用</h3><p>案例准备代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.g4b.juc.java8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;  <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> salary; <span class="comment">// 薪资</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age; <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">private</span> String sex; <span class="comment">//性别</span></span><br><span class="line">    <span class="keyword">private</span> String area;  <span class="comment">// 地区</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Person&gt; personList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>, <span class="number">8900</span>,<span class="number">18</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line">        personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jack&quot;</span>, <span class="number">7000</span>, <span class="number">23</span>,<span class="string">&quot;male&quot;</span>, <span class="string">&quot;Washington&quot;</span>));</span><br><span class="line">        personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Lily&quot;</span>, <span class="number">7800</span>,<span class="number">27</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;Washington&quot;</span>));</span><br><span class="line">        personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Anni&quot;</span>, <span class="number">8200</span>,<span class="number">39</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line">        personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Owen&quot;</span>, <span class="number">9500</span>,<span class="number">32</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line">        personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Alisa&quot;</span>, <span class="number">7900</span>,<span class="number">45</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(personList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-1、遍历-匹配（foreach-find-match）"><a href="#3-1、遍历-匹配（foreach-find-match）" class="headerlink" title="3.1、遍历/匹配（foreach/find/match）"></a>3.1、遍历/匹配（foreach/find/match）</h4><p><img src="http://cheng_qiwei.gitee.io/blog/img/2020110914450139.png" alt="2020110914450139"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">7</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//匹配第一个符合条件的值</span></span><br><span class="line">    Optional&lt;Integer&gt; first = list.stream().filter(x -&gt; x &gt; <span class="number">6</span>).findFirst();</span><br><span class="line">    System.out.println(<span class="string">&quot;第一个符合条件的值：&quot;</span>+first.get());</span><br><span class="line">    <span class="comment">//匹配任意一个符合条件的值，适合使用并行流</span></span><br><span class="line">    Optional&lt;Integer&gt; any = list.parallelStream().filter(x -&gt; x &gt; <span class="number">6</span>).findAny();</span><br><span class="line">    System.out.println(<span class="string">&quot;任意一个符合条件的值：&quot;</span>+any.get());</span><br><span class="line">    <span class="comment">//是否存在大于6的值</span></span><br><span class="line">    <span class="keyword">boolean</span> flag = list.stream().anyMatch(x -&gt; x &gt; <span class="number">6</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;是否存在大于6的值：&quot;</span>+flag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line">第一个符合条件的值：<span class="number">7</span></span><br><span class="line">任意一个符合条件的值：<span class="number">8</span></span><br><span class="line">是否存在大于<span class="number">6</span>的值：<span class="keyword">true</span></span><br></pre></td></tr></table></figure><h4 id="3-2、筛选（filter）"><a href="#3-2、筛选（filter）" class="headerlink" title="3.2、筛选（filter）"></a>3.2、筛选（filter）</h4><p><img src="http://cheng_qiwei.gitee.io/blog/img/20201109144706541.jpg" alt="20201109144706541"></p><p>测试目标：输出员工中工资高于8000的人的姓名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; nameResultList = personList.stream().filter(x -&gt; x.getSalary() &gt; <span class="number">8000</span>).map(Person::getName).collect(Collectors.toList());</span><br><span class="line">    System.out.println(nameResultList.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line">[Tom, Anni, Owen]</span><br></pre></td></tr></table></figure><h4 id="3-3、聚合（max-min-count"><a href="#3-3、聚合（max-min-count" class="headerlink" title="3.3、聚合（max/min/count)"></a>3.3、聚合（max/min/count)</h4><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210502230035630.png" alt="image-20210502230035630"></p><p>测试目标1：输出员工中工资最高的人的姓名</p><p>测试目标2：输出员工中工资高于8000的人数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String maxSalaryer = personList.stream().max(Comparator.comparing(Person::getSalary)).map(Person::getName).get();</span><br><span class="line">    System.out.println(<span class="string">&quot;员工中工资最高的人是：&quot;</span>+maxSalaryer);</span><br><span class="line">    <span class="keyword">long</span> count = personList.stream().filter(x -&gt; x.getSalary() &gt; <span class="number">8000</span>).count();</span><br><span class="line">    System.out.println(<span class="string">&quot;员工中工资高于8000的总人数是：&quot;</span>+count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line">员工中工资最高的人是：Owen</span><br><span class="line">员工中工资高于<span class="number">8000</span>的总人数是：<span class="number">3</span></span><br></pre></td></tr></table></figure><h4 id="3-4、映射-map-flatMap"><a href="#3-4、映射-map-flatMap" class="headerlink" title="3.4、映射(map/flatMap)"></a>3.4、映射(map/flatMap)</h4><p><img src="http://cheng_qiwei.gitee.io/blog/img/20201109145252340.jpg" alt="20201109145252340"></p><p>测试目标：给每位员工的薪资提高1000元，测试操作原来的集合和不操作原来的集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Person&gt; newPersonList = personList.stream().map(person -&gt; &#123;</span><br><span class="line">        Person newPerson = <span class="keyword">new</span> Person(person.getName(),person.getSalary()+ <span class="number">1000</span>, person.getAge(), person.getSex(), person.getArea());</span><br><span class="line">        <span class="keyword">return</span> newPerson;</span><br><span class="line">    &#125;).collect(Collectors.toList());</span><br><span class="line">    System.out.println(<span class="string">&quot;不操作原集合提薪前的集合：&quot;</span>+personList);</span><br><span class="line">    System.out.println(<span class="string">&quot;不操作原集合提薪后的集合：&quot;</span>+newPersonList);</span><br><span class="line">    List&lt;Person&gt; newPersonList2 = personList.stream().map(person -&gt; &#123;</span><br><span class="line">        person.setSalary(person.getSalary() + <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125;).collect(Collectors.toList());</span><br><span class="line">    System.out.println(<span class="string">&quot;操作原集合提薪前的集合：&quot;</span>+personList);</span><br><span class="line">    System.out.println(<span class="string">&quot;操作原集合提薪后的集合：&quot;</span>+newPersonList2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line">不操作原集合提薪前的集合：[Person(name=Tom, salary=<span class="number">8900</span>, age=<span class="number">18</span>, sex=male, area=New York), Person(name=Jack, salary=<span class="number">7000</span>, age=<span class="number">23</span>, sex=male, area=Washington), Person(name=Lily, salary=<span class="number">7800</span>, age=<span class="number">27</span>, sex=female, area=Washington), Person(name=Anni, salary=<span class="number">8200</span>, age=<span class="number">39</span>, sex=female, area=New York), Person(name=Owen, salary=<span class="number">9500</span>, age=<span class="number">32</span>, sex=male, area=New York), Person(name=Alisa, salary=<span class="number">7900</span>, age=<span class="number">45</span>, sex=female, area=New York)]</span><br><span class="line">不操作原集合提薪后的集合：[Person(name=Tom, salary=<span class="number">9900</span>, age=<span class="number">18</span>, sex=male, area=New York), Person(name=Jack, salary=<span class="number">8000</span>, age=<span class="number">23</span>, sex=male, area=Washington), Person(name=Lily, salary=<span class="number">8800</span>, age=<span class="number">27</span>, sex=female, area=Washington), Person(name=Anni, salary=<span class="number">9200</span>, age=<span class="number">39</span>, sex=female, area=New York), Person(name=Owen, salary=<span class="number">10500</span>, age=<span class="number">32</span>, sex=male, area=New York), Person(name=Alisa, salary=<span class="number">8900</span>, age=<span class="number">45</span>, sex=female, area=New York)]</span><br><span class="line">操作原集合提薪前的集合：[Person(name=Tom, salary=<span class="number">9900</span>, age=<span class="number">18</span>, sex=male, area=New York), Person(name=Jack, salary=<span class="number">8000</span>, age=<span class="number">23</span>, sex=male, area=Washington), Person(name=Lily, salary=<span class="number">8800</span>, age=<span class="number">27</span>, sex=female, area=Washington), Person(name=Anni, salary=<span class="number">9200</span>, age=<span class="number">39</span>, sex=female, area=New York), Person(name=Owen, salary=<span class="number">10500</span>, age=<span class="number">32</span>, sex=male, area=New York), Person(name=Alisa, salary=<span class="number">8900</span>, age=<span class="number">45</span>, sex=female, area=New York)]</span><br><span class="line">操作原集合提薪后的集合：[Person(name=Tom, salary=<span class="number">9900</span>, age=<span class="number">18</span>, sex=male, area=New York), Person(name=Jack, salary=<span class="number">8000</span>, age=<span class="number">23</span>, sex=male, area=Washington), Person(name=Lily, salary=<span class="number">8800</span>, age=<span class="number">27</span>, sex=female, area=Washington), Person(name=Anni, salary=<span class="number">9200</span>, age=<span class="number">39</span>, sex=female, area=New York), Person(name=Owen, salary=<span class="number">10500</span>, age=<span class="number">32</span>, sex=male, area=New York), Person(name=Alisa, salary=<span class="number">8900</span>, age=<span class="number">45</span>, sex=female, area=New York)]</span><br></pre></td></tr></table></figure><p>flatMap的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.g4b.juc.java8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">//测试案例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlatMapDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Student&gt; studentList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        List&lt;Class&gt; tomList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Class&gt; jackList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Class music = <span class="keyword">new</span> Class(<span class="number">1</span>,<span class="string">&quot;音乐&quot;</span>);</span><br><span class="line">        Class chinese = <span class="keyword">new</span> Class(<span class="number">2</span>,<span class="string">&quot;语文&quot;</span>);</span><br><span class="line">        Class math = <span class="keyword">new</span> Class(<span class="number">3</span>,<span class="string">&quot;数学&quot;</span>);</span><br><span class="line">        Collections.addAll(tomList,math,music);</span><br><span class="line">        Collections.addAll(jackList,chinese,music);</span><br><span class="line">        studentList.add(<span class="keyword">new</span> Student(<span class="number">1002</span>,<span class="string">&quot;Tom&quot;</span>,tomList));</span><br><span class="line">        studentList.add(<span class="keyword">new</span> Student(<span class="number">1001</span>,<span class="string">&quot;Jack&quot;</span>,jackList));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(studentList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer studentId;</span><br><span class="line">    <span class="keyword">private</span> String studentName;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Class&gt; classList;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer classId;</span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;需求：假设现在有一个学生类，学生类下面有一个课程类的list列表，此时我们有一个需求，获取所有学生的所有课程的名称，那么我们此时的操作可能是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; classNameList = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Student student : studentList) &#123;</span><br><span class="line">        List&lt;Class&gt; classList = student.getClassList();</span><br><span class="line">        <span class="keyword">for</span> (Class aClass : classList) &#123;</span><br><span class="line">            classNameList.add(aClass.getClassName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(classNameList.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line">[数学, 语文, 音乐]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;那么，出现这种嵌套循环就会让人感觉不是很方便，所以此时我们就可以考虑使用flatMap来解决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; claasNameList = studentList.stream().map(Student::getClassList).flatMap(Collection::stream).distinct().map(Class::getClassName).collect(Collectors.toList());</span><br><span class="line">    System.out.println(claasNameList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line">[数学, 语文, 音乐]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;除上以外，map和flatMap更多用来获取两个集合的并集、交集和差集，我们以上面tomList和jackList来进行测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取两个人课程的交集</span></span><br><span class="line">    List&lt;String&gt; collect = tomList.stream().filter(jackList::contains).map(Class::getClassName).collect(Collectors.toList());</span><br><span class="line">    System.out.println(<span class="string">&quot;两个人课程的交集&quot;</span> + collect);</span><br><span class="line">    <span class="comment">//获取两个人课程的并集</span></span><br><span class="line">    List&lt;String&gt; classList = Stream.of(tomList, jackList).flatMap(Collection::stream).distinct().map(Class::getClassName).collect(Collectors.toList());</span><br><span class="line">    System.out.println(<span class="string">&quot;两个人课程的并集&quot;</span> + classList);</span><br><span class="line">    <span class="comment">//获取tom课程和jack课程的差集</span></span><br><span class="line">    List&lt;String&gt; classes1 = tomList.stream().filter(c -&gt; !jackList.contains(c)).map(Class::getClassName).collect(Collectors.toList());</span><br><span class="line">    System.out.println(<span class="string">&quot;tom课程和jack课程的差集&quot;</span> + classes1);</span><br><span class="line">    <span class="comment">//获取jack课程和tom课程的差集</span></span><br><span class="line">    List&lt;String&gt; classes2 = jackList.stream().filter(c -&gt; !tomList.contains(c)).map(Class::getClassName).collect(Collectors.toList());</span><br><span class="line">    System.out.println(<span class="string">&quot;jack课程和tom课程的差集&quot;</span> + classes2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line">两个人课程的交集[音乐]</span><br><span class="line">两个人课程的并集[数学, 音乐, 语文]</span><br><span class="line">tom课程和jack课程的差集[数学]</span><br><span class="line">jack课程和tom课程的差集[语文]</span><br></pre></td></tr></table></figure><h4 id="3-5、归约-reduce"><a href="#3-5、归约-reduce" class="headerlink" title="3.5、归约(reduce)"></a>3.5、归约(reduce)</h4><p>&emsp;&emsp;归约，其实就是把多个值转变为1个值，例如求和、乘积、求最大值最小值等等。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210503162603025.png" alt="image-20210503162603025"></p><p>测试目标：求所有员工的工资之和，并查询最高工资</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//查询工资之和，方式1</span></span><br><span class="line">    Optional&lt;Integer&gt; sumSalary = personList.stream().map(Person::getSalary).reduce(Integer::sum);</span><br><span class="line">    System.out.println(<span class="string">&quot;工资之和（方式1）为：&quot;</span>+sumSalary.get());</span><br><span class="line">    <span class="comment">//查询工资之和，方式2</span></span><br><span class="line">    Integer sumSalary2 = personList.stream().reduce(<span class="number">0</span>, (sum, p) -&gt; sum += p.getSalary(), (sum1, sum2) -&gt; sum1 + sum2);</span><br><span class="line">    System.out.println(<span class="string">&quot;工资之和（方式2）为：&quot;</span>+sumSalary2);</span><br><span class="line">    <span class="comment">//查询工资之和，方式3</span></span><br><span class="line">    Integer sumSalary3 = personList.stream().reduce(<span class="number">0</span>, (sum, p) -&gt; sum += p.getSalary(), Integer::sum);</span><br><span class="line">    System.out.println(<span class="string">&quot;工资之和（方式3）为：&quot;</span>+sumSalary3);</span><br><span class="line">    <span class="comment">//查询最高工资，方式1</span></span><br><span class="line">    Integer maxSalary = personList.stream().reduce(<span class="number">0</span>, (max, p) -&gt; max &gt; p.getSalary() ? max : p.getSalary(), Integer::max);</span><br><span class="line">    System.out.println(<span class="string">&quot;最高工资（方式1）为：&quot;</span>+maxSalary);</span><br><span class="line">    <span class="comment">//查询最高工资，方式2</span></span><br><span class="line">    Integer maxSalary2 = personList.stream().reduce(<span class="number">0</span>, (max, p) -&gt; max &gt; p.getSalary() ? max : p.getSalary(), (max1, max2) -&gt; max1 &gt; max2 ? max1 : max2);</span><br><span class="line">    System.out.println(<span class="string">&quot;最高工资（方式2）为：&quot;</span>+maxSalary2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line">工资之和（方式<span class="number">1</span>）为：<span class="number">49300</span></span><br><span class="line">工资之和（方式<span class="number">2</span>）为：<span class="number">49300</span></span><br><span class="line">工资之和（方式<span class="number">3</span>）为：<span class="number">49300</span></span><br><span class="line">最高工资（方式<span class="number">1</span>）为：<span class="number">9500</span></span><br><span class="line">最高工资（方式<span class="number">2</span>）为：<span class="number">9500</span></span><br></pre></td></tr></table></figure><h4 id="3-6、收集-collect"><a href="#3-6、收集-collect" class="headerlink" title="3.6、收集(collect)"></a>3.6、收集(collect)</h4><h5 id="3-6-1、归集-toList-toSet-toMap"><a href="#3-6-1、归集-toList-toSet-toMap" class="headerlink" title="3.6.1、归集(toList/toSet/toMap)"></a>3.6.1、归集(toList/toSet/toMap)</h5><p>测试目标：获取数据转为list、set、map</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">20</span>);</span><br><span class="line">    List&lt;Integer&gt; resultList = list.stream().filter(x -&gt; x % <span class="number">2</span> == <span class="number">0</span>).collect(Collectors.toList());</span><br><span class="line">    System.out.println(<span class="string">&quot;能模2的数据有：&quot;</span> + resultList);</span><br><span class="line">    Set&lt;Integer&gt; resultSet = list.stream().filter(x -&gt; x % <span class="number">2</span> == <span class="number">0</span>).collect(Collectors.toSet());</span><br><span class="line">    System.out.println(<span class="string">&quot;能模2的数据(不重复)有：&quot;</span> + resultSet);</span><br><span class="line">    Map&lt;String, Person&gt; resultMap = personList.stream().collect(Collectors.toMap(Person::getName, p -&gt; p));</span><br><span class="line">    System.out.println(<span class="string">&quot;返回的Map是：&quot;</span>+resultMap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line">能模<span class="number">2</span>的数据有：[<span class="number">6</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">20</span>]</span><br><span class="line">能模<span class="number">2</span>的数据(不重复)有：[<span class="number">4</span>, <span class="number">20</span>, <span class="number">6</span>]</span><br><span class="line">返回的Map是：&#123;Tom=Person(name=Tom, salary=<span class="number">8900</span>, age=<span class="number">18</span>, sex=male, area=New York), Owen=Person(name=Owen, salary=<span class="number">9500</span>, age=<span class="number">32</span>, sex=male, area=New York), Anni=Person(name=Anni, salary=<span class="number">8200</span>, age=<span class="number">39</span>, sex=female, area=New York), Alisa=Person(name=Alisa, salary=<span class="number">7900</span>, age=<span class="number">45</span>, sex=female, area=New York), Jack=Person(name=Jack, salary=<span class="number">7000</span>, age=<span class="number">23</span>, sex=male, area=Washington), Lily=Person(name=Lily, salary=<span class="number">7800</span>, age=<span class="number">27</span>, sex=female, area=Washington)&#125;</span><br></pre></td></tr></table></figure><h5 id="3-6-2-统计-count-averaging"><a href="#3-6-2-统计-count-averaging" class="headerlink" title="3.6.2 统计(count/averaging)"></a>3.6.2 统计(count/averaging)</h5><ul><li>计数：count</li><li>平均值：averagingInt、averagingLong、averagingDouble</li><li>最值：maxBy、minBy</li><li>求和：summingInt、summingLong、summingDouble</li><li>统计以上所有：summarizingInt、summarizingLong、summarizingDouble</li></ul><p>测试目标：统计员工人数、平均工资、工资总额、最高工资</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> count = personList.stream().count();</span><br><span class="line">    System.out.println(<span class="string">&quot;员工人数：&quot;</span>+count);</span><br><span class="line">    Double averMoney = personList.stream().collect(Collectors.averagingInt(Person::getSalary));</span><br><span class="line">    System.out.println(<span class="string">&quot;平均工资：&quot;</span>+averMoney);</span><br><span class="line">    <span class="keyword">long</span> sumMoney = personList.stream().collect(Collectors.summingInt(Person::getSalary));</span><br><span class="line">    System.out.println(<span class="string">&quot;工资总和：&quot;</span>+sumMoney);</span><br><span class="line">    Integer maxMoney = personList.stream().map(Person::getSalary).collect(Collectors.maxBy(Integer::compare)).get();</span><br><span class="line">    System.out.println(<span class="string">&quot;最高工资：&quot;</span>+maxMoney);</span><br><span class="line">    IntSummaryStatistics collect = personList.stream().collect(Collectors.summarizingInt(Person::getSalary));</span><br><span class="line">    System.out.println(<span class="string">&quot;所有信息：&quot;</span>+collect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line">员工人数：<span class="number">6</span></span><br><span class="line">平均工资：<span class="number">8216.666666666666</span></span><br><span class="line">工资总和：<span class="number">49300</span></span><br><span class="line">最高工资：<span class="number">9500</span></span><br><span class="line">所有信息：IntSummaryStatistics&#123;count=<span class="number">6</span>, sum=<span class="number">49300</span>, min=<span class="number">7000</span>, average=<span class="number">8216.666667</span>, max=<span class="number">9500</span>&#125;</span><br></pre></td></tr></table></figure><h5 id="3-6-3、分组-partitioningBy-groupingBy"><a href="#3-6-3、分组-partitioningBy-groupingBy" class="headerlink" title="3.6.3、分组(partitioningBy/groupingBy)"></a>3.6.3、分组(partitioningBy/groupingBy)</h5><ul><li>分区：将<code>stream</code>按条件分为两个<code>Map</code>，比如员工按薪资是否高于8000分为两部分。</li><li>分组：将集合分为多个Map，比如员工按性别分组。有单级分组和多级分组。</li></ul><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210503191632568.png" alt="image-20210503191632568"></p><p>测试目标：第一个是将员工按薪资是否高于8000分为两部分、第二个是将员工按性别和地区分组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> count = personList.stream().count();</span><br><span class="line">    System.out.println(<span class="string">&quot;员工人数：&quot;</span>+count);</span><br><span class="line">    Double averMoney = personList.stream().collect(Collectors.averagingInt(Person::getSalary));</span><br><span class="line">    System.out.println(<span class="string">&quot;平均工资：&quot;</span>+averMoney);</span><br><span class="line">    <span class="keyword">long</span> sumMoney = personList.stream().collect(Collectors.summingInt(Person::getSalary));</span><br><span class="line">    System.out.println(<span class="string">&quot;工资总和：&quot;</span>+sumMoney);</span><br><span class="line">    Integer maxMoney = personList.stream().map(Person::getSalary).collect(Collectors.maxBy(Integer::compare)).get();</span><br><span class="line">    System.out.println(<span class="string">&quot;最高工资：&quot;</span>+maxMoney);</span><br><span class="line">    IntSummaryStatistics collect = personList.stream().collect(Collectors.summarizingInt(Person::getSalary));</span><br><span class="line">    System.out.println(<span class="string">&quot;所有信息：&quot;</span>+collect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line">薪资高于<span class="number">8000</span>的员工分组[Person(name=Tom, salary=<span class="number">8900</span>, age=<span class="number">18</span>, sex=male, area=New York), Person(name=Anni, salary=<span class="number">8200</span>, age=<span class="number">39</span>, sex=female, area=New York), Person(name=Owen, salary=<span class="number">9500</span>, age=<span class="number">32</span>, sex=male, area=New York)]</span><br><span class="line">薪资低于<span class="number">8000</span>的员工分组[Person(name=Jack, salary=<span class="number">7000</span>, age=<span class="number">23</span>, sex=male, area=Washington), Person(name=Lily, salary=<span class="number">7800</span>, age=<span class="number">27</span>, sex=female, area=Washington), Person(name=Alisa, salary=<span class="number">7900</span>, age=<span class="number">45</span>, sex=female, area=New York)]</span><br><span class="line">员工按照性别分组：&#123;female=[Person(name=Lily, salary=<span class="number">7800</span>, age=<span class="number">27</span>, sex=female, area=Washington), Person(name=Anni, salary=<span class="number">8200</span>, age=<span class="number">39</span>, sex=female, area=New York), Person(name=Alisa, salary=<span class="number">7900</span>, age=<span class="number">45</span>, sex=female, area=New York)], male=[Person(name=Tom, salary=<span class="number">8900</span>, age=<span class="number">18</span>, sex=male, area=New York), Person(name=Jack, salary=<span class="number">7000</span>, age=<span class="number">23</span>, sex=male, area=Washington), Person(name=Owen, salary=<span class="number">9500</span>, age=<span class="number">32</span>, sex=male, area=New York)]&#125;</span><br><span class="line">员工先按照性别分组，再按照地区分组：&#123;female=&#123;New York=[Person(name=Anni, salary=<span class="number">8200</span>, age=<span class="number">39</span>, sex=female, area=New York), Person(name=Alisa, salary=<span class="number">7900</span>, age=<span class="number">45</span>, sex=female, area=New York)], Washington=[Person(name=Lily, salary=<span class="number">7800</span>, age=<span class="number">27</span>, sex=female, area=Washington)]&#125;, male=&#123;New York=[Person(name=Tom, salary=<span class="number">8900</span>, age=<span class="number">18</span>, sex=male, area=New York), Person(name=Owen, salary=<span class="number">9500</span>, age=<span class="number">32</span>, sex=male, area=New York)], Washington=[Person(name=Jack, salary=<span class="number">7000</span>, age=<span class="number">23</span>, sex=male, area=Washington)]&#125;&#125;</span><br></pre></td></tr></table></figure><h5 id="3-6-4、接合-joining"><a href="#3-6-4、接合-joining" class="headerlink" title="3.6.4、接合(joining)"></a>3.6.4、接合(joining)</h5><p>&emsp;&emsp;<code>joining</code>可以将stream中的元素用特定的连接符（没有的话，则直接连接）连接成一个字符串。</p><p>测试目标：拼接所有的员工姓名作为一个字符串，用，隔开</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test9</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String result = personList.stream().map(Person::getName).collect(Collectors.joining(<span class="string">&quot;，&quot;</span>));</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line">Tom，Jack，Lily，Anni，Owen，Alisa</span><br></pre></td></tr></table></figure><h5 id="3-6-5-归约-reducing"><a href="#3-6-5-归约-reducing" class="headerlink" title="3.6.5 归约(reducing)"></a>3.6.5 归约(reducing)</h5><p>&emsp;&emsp;<code>Collectors</code>类提供的<code>reducing</code>方法，相比于<code>stream</code>本身的<code>reduce</code>方法，增加了对自定义归约的支持。</p><p>测试目标：返回所有员工的总工资</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test10</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Integer result = personList.stream().collect(Collectors.reducing(<span class="number">0</span>, Person::getSalary, (x, sum) -&gt; sum += x));</span><br><span class="line">    System.out.println(<span class="string">&quot;所有员工的总工资为：&quot;</span> + result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line">所有员工的总工资为：<span class="number">49300</span></span><br></pre></td></tr></table></figure><h4 id="3-7、排序-sorted"><a href="#3-7、排序-sorted" class="headerlink" title="3.7、排序(sorted)"></a>3.7、排序(sorted)</h4><ul><li>sorted()：自然排序，流中元素需实现Comparable接口</li><li>sorted(Comparator com)：Comparator排序器自定义排序</li></ul><p>测试目标：将员工按照工资高低进行排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test11</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Object&gt; sortAsc1 = personList.stream().sorted(Comparator.comparing(Person::getSalary))</span><br><span class="line">            .map(person -&gt; &#123;</span><br><span class="line">                HashMap map = <span class="keyword">new</span> HashMap();</span><br><span class="line">                map.put(person.getName(), person.getSalary());</span><br><span class="line">                <span class="keyword">return</span> map;</span><br><span class="line">            &#125;).collect(Collectors.toList());</span><br><span class="line">    System.out.println(<span class="string">&quot;按照工资升序：&quot;</span> + sortAsc1);</span><br><span class="line">    List&lt;Object&gt; sortDesc1 = personList.stream().sorted(Comparator.comparing(Person::getSalary).reversed())</span><br><span class="line">            .map(person -&gt; &#123;</span><br><span class="line">                HashMap map = <span class="keyword">new</span> HashMap();</span><br><span class="line">                map.put(person.getName(), person.getSalary());</span><br><span class="line">                <span class="keyword">return</span> map;</span><br><span class="line">            &#125;).collect(Collectors.toList());</span><br><span class="line">    System.out.println(<span class="string">&quot;按照工资降序：&quot;</span> + sortDesc1);</span><br><span class="line">    List&lt;Object&gt; result = personList.stream().sorted((p1, p2) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1.getSalary() == p2.getSalary()) &#123;</span><br><span class="line">            <span class="keyword">return</span> p2.getAge() - p1.getAge();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> p1.getSalary() - p2.getSalary();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).map(person -&gt; &#123;</span><br><span class="line">        HashMap map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(person.getName(), person.getSalary());</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;).collect(Collectors.toList());</span><br><span class="line">    System.out.println(<span class="string">&quot;先按工资升序再按年龄降序(自定义排序)：&quot;</span> + result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line">按照工资升序：[&#123;Jack=<span class="number">7000</span>&#125;, &#123;Lily=<span class="number">7800</span>&#125;, &#123;Alisa=<span class="number">7900</span>&#125;, &#123;Anni=<span class="number">8200</span>&#125;, &#123;Tom=<span class="number">8900</span>&#125;, &#123;Owen=<span class="number">9500</span>&#125;]</span><br><span class="line">按照工资降序：[&#123;Owen=<span class="number">9500</span>&#125;, &#123;Tom=<span class="number">8900</span>&#125;, &#123;Anni=<span class="number">8200</span>&#125;, &#123;Alisa=<span class="number">7900</span>&#125;, &#123;Lily=<span class="number">7800</span>&#125;, &#123;Jack=<span class="number">7000</span>&#125;]</span><br><span class="line">先按工资升序再按年龄降序(自定义排序)：[&#123;Jack=<span class="number">7000</span>&#125;, &#123;Lily=<span class="number">7800</span>&#125;, &#123;Alisa=<span class="number">7900</span>&#125;, &#123;Anni=<span class="number">8200</span>&#125;, &#123;Tom=<span class="number">8900</span>&#125;, &#123;Owen=<span class="number">9500</span>&#125;]</span><br></pre></td></tr></table></figure><h4 id="3-8、提取-组合"><a href="#3-8、提取-组合" class="headerlink" title="3.8、提取/组合"></a>3.8、提取/组合</h4><p>&emsp;&emsp;提供了合并、去重、限制、跳过等操作。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/20201109145946301.jpg"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/20201109150001270.jpg" alt="20201109150001270"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/20201109150012790.jpg" alt="20201109150012790"></p><p>测试目标：测试合并、去重、限制、跳过等操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test12</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String[] arr1 = &#123; <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span> &#125;;</span><br><span class="line">    String[] arr2 = &#123; <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>, <span class="string">&quot;g&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并两个数组并去重</span></span><br><span class="line">    Stream&lt;String&gt; stream1 = Stream.of(arr1);</span><br><span class="line">    Stream&lt;String&gt; stream2 = Stream.of(arr2);</span><br><span class="line">    List&lt;String&gt; result1 = Stream.concat(stream1,stream2).distinct().collect(Collectors.toList());</span><br><span class="line">    System.out.println(<span class="string">&quot;组合去重结果：&quot;</span>+result1);</span><br><span class="line">    <span class="comment">//获取流中的前几个数据</span></span><br><span class="line">    List&lt;Integer&gt; result2 = Stream.iterate(<span class="number">1</span>, x -&gt; x + <span class="number">2</span>).limit(<span class="number">5</span>).collect(Collectors.toList());</span><br><span class="line">    System.out.println(<span class="string">&quot;从1开始，每次获取 +2 后的值，获取前5个：&quot;</span>+result2);</span><br><span class="line">    <span class="comment">//跳过前面几个数据</span></span><br><span class="line">    List&lt;Integer&gt; result3 = Stream.iterate(<span class="number">1</span>, x -&gt; x + <span class="number">2</span>).skip(<span class="number">2</span>).limit(<span class="number">5</span>).collect(Collectors.toList());</span><br><span class="line">    System.out.println(<span class="string">&quot;从1开始，每次获取 +2 后的值，跳过前2个后获取前5个：&quot;</span>+result3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line">组合去重结果：[a, b, c, d, e, f, g]</span><br><span class="line">从<span class="number">1</span>开始，每次获取 +<span class="number">2</span> 后的值，获取前<span class="number">5</span>个：[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line">从<span class="number">1</span>开始，每次获取 +<span class="number">2</span> 后的值，跳过前<span class="number">2</span>个后获取前<span class="number">5</span>个：[<span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JDK8新特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDK8 </tag>
            
            <tag> Lambda </tag>
            
            <tag> stream </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch面试题</title>
      <link href="/blog/2021/04/23/ELasticSearch%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/blog/2021/04/23/ELasticSearch%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="ElasticSearch面试题"><a href="#ElasticSearch面试题" class="headerlink" title="ElasticSearch面试题"></a>ElasticSearch面试题</h1><h2 id="1、为什么要使用ElasticSearch？"><a href="#1、为什么要使用ElasticSearch？" class="headerlink" title="1、为什么要使用ElasticSearch？"></a>1、为什么要使用ElasticSearch？</h2><p>&emsp;&emsp;系统中的数据，随着业务的发展和时间的推移， 将会<strong>非常多</strong>， 而业务中往往采用<strong>模糊查询</strong>进行数据的搜索，而模糊查询会导致<strong>查询引擎放弃索引</strong>，从而导致系统查询数据时都是<strong>全表扫描</strong>，在百万级别的数据库中查询<strong>效率是非常低下</strong>的，而我们使用ElasticSearch做一个全文索引，将经常查询的系统功能中的某些字段放入 ElasticSearch索引库里，可以<strong>提高查询速度</strong>。</p><h2 id="2、ElasticSearch-的-master-选举流程是怎样的"><a href="#2、ElasticSearch-的-master-选举流程是怎样的" class="headerlink" title="2、ElasticSearch 的 master 选举流程是怎样的"></a>2、ElasticSearch 的 master 选举流程是怎样的</h2><p>&emsp;&emsp;ElasticSearch 的选举是 ZenDiscovery 模块负责的，主要包含 Ping （节点之间通过这个 RPC 来发现彼此）和 Unicast （单播模块包含一个主机列表以控制哪些节点需要 ping 通）这两部分</p><p>1、对所有可以成为 master 的节点（<strong>node.master: true</strong>）根据 nodeId 字典排序，每次选举每个节点都把自<br>己所知道节点排一次序，然后选出第一个（第 0 位）节点，暂且认为它是 master 节点。</p><p>2、如果对某个节点的投票数达到一定的值（可以成为 master需要的节点数为： <strong>n/2+1</strong> ）并且该节点<strong>自己也选举自己</strong>，如果都符合，那这个节点就是 master ，否则重新选举一直到满足上述条件。</p><p>&emsp;&emsp;master节点的职责主要包括<strong>集群、节点和索引的管理</strong>，<strong>不负责文档级别的管理</strong>，此时master节点可以关闭node.data功能。</p><h2 id="3、ElasticSearch集群的脑裂问题"><a href="#3、ElasticSearch集群的脑裂问题" class="headerlink" title="3、ElasticSearch集群的脑裂问题"></a>3、ElasticSearch集群的脑裂问题</h2><h3 id="3-1、出现原因"><a href="#3-1、出现原因" class="headerlink" title="3.1、出现原因"></a>3.1、出现原因</h3><p>a、<strong>网络问题</strong>：集群间的<strong>网络延迟</strong>导致一些节点访问不到master，认为master挂掉了从而选举出新的master；</p><p>b、<strong>节点负载</strong>：主节点的角色<strong>既是master又是data</strong>，当<strong>访问量大</strong>时可能会导致ElasticSearch<strong>停止响应造成大面积延迟</strong>，其他节点<strong>得不到master的响应</strong>从而认为master挂掉了从而选举出新的master；</p><p>c、<strong>内存回收</strong>：data节点上的ElasticSearch<strong>进程占用的内存较大</strong>，从而引发JVM的规模的<strong>内存回收</strong>，造成ElasticSearch失去响应。</p><h3 id="3-2、解决方案"><a href="#3-2、解决方案" class="headerlink" title="3.2、解决方案"></a>3.2、解决方案</h3><p>a、<strong>减少误判</strong>：可以设置 discovery.zen.ping_timeout 节点状态的响应时间，默认为 3s，可以适当<strong>增大响应时间</strong>来减少其他节点对<strong>master状态的误判</strong>；</p><p>b、<strong>选举触发</strong> : 可以设置discovery.zen.minimum_master_nodes，该参数是用于<strong>控制选举行为发生的最小集群主节点数量</strong>。当备选主节点的个数大于等于该参数的值，且备选主节点中有该参数个节点认为主节点挂了，进行选举。默认值是1，官方建议为（ n/2）+1 个，其中n为主节点个数（即有资格成为主节点的节点个数）；</p><p>c、<strong>角色分离</strong>：即将<strong>master节点和data节点分离</strong>，限制角色。</p><p>&emsp;主节点配置为：node.master: true                   node.data: false</p><p>&emsp;从节点配置为：node.master: false                  node.data: true</p><h2 id="4、Elasticsearch索引文档的流程？"><a href="#4、Elasticsearch索引文档的流程？" class="headerlink" title="4、Elasticsearch索引文档的流程？"></a>4、Elasticsearch索引文档的流程？</h2><p>1、一个文档请求发送到任意集群节点上；</p><p>2、获得请求的节点成为协调节点默认使用文档ID参与计算，以便为路由提供合适的分片；</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>shard = hash(document_id) % (num_of_primary_shards)</strong></p><p>3、当分片所在节点接收来自协调节点的请求后，会将请求的文档写入到Memory Buffer中，然后定时（默认是1s）写入FileSystem Cache，这个过程称为refresh；</p><p>4、在某些情况中，Memory Buffer 和 FileSystem Cache 中的数据可能会丢失，ElasticSearch通过translog的机制来保证数据的可靠性。它的机制是：接收到请求后，同时写入到translog中，只有当FileSystem cache的数据写如此盘中时，才会将translog清除掉，这个过程称为flush；</p><p>注：在flush的过程中，内存中的缓存将会被清除掉内容被写入一个新段，段的 fsync 将创建一个新的提交点， 并将内容刷新到磁盘，旧的 translog 将被删除并开始一个新的 translog。flush触发的时机是定时触发（默认30min）或者translog文件太大（默认512M）。</p><h2 id="5、ElasticSearch更新和删除文档的流程"><a href="#5、ElasticSearch更新和删除文档的流程" class="headerlink" title="5、ElasticSearch更新和删除文档的流程"></a>5、ElasticSearch更新和删除文档的流程</h2><p>&emsp;&emsp;虽然删除和更新文档也是写操作，但是由于ElasticSearch的文档不可变性，所以不能通过删除或修改文档来执行变更操作。</p><p>&emsp;&emsp;当执行删除请求时，我们的文档本质并没有被删除，而是由于磁盘上的每一个段都有对应的一个.del文件，删除的文档会在.del文件中被标记为删除。此时，虽然文档还是能够在查询过程中被匹配出来，但是他会在结果中被过滤掉。</p><p>&emsp;&emsp;当执行更新请求时，由于我们ElasticSearch中存在一个版本号，所以此时旧版本的文档会在.del文件上被标记为删除，而新版本的文档则会被索引到一个新段。此时，我们能够同时查询到两个版本的文档，但是在结果中，旧版本的文档会被过滤掉，只会返回最新版本的文档。</p><p>&emsp;&emsp;当执行段合并时，此时会真的将.del文件中被标记删除的文档执行物理删除。</p><h2 id="6、ElasticSearch的搜索流程"><a href="#6、ElasticSearch的搜索流程" class="headerlink" title="6、ElasticSearch的搜索流程"></a>6、ElasticSearch的搜索流程</h2><p>搜索被执行成一个两阶段过程，称为  Query Then Fetch；</p><p>1、在初始查询阶段，查询会<strong>广播到索引中每一个分片拷贝（主分片或者副本分片）</strong>。 每个分片在本地执行搜索并构建一个匹配文档的大小为 <strong>from + size 的优先队列</strong>。PS：在搜索的时候是会查询 Filesystem Cache 的，但是有部分数据还在 Memory Buffer，所以搜索是近实时的。</p><p>2、每个分片返回各自优先队列中<strong>所有文档的 ID 和排序值 给协调节点</strong>，协调节点合并这些值到自己的优先队列中来产生一个<strong>全局排序后的结果列表</strong>。</p><p>3、接下来就是取回阶段，协调节点辨别出哪些文档需要被取回并向<strong>相关的分片提交多个 GET 请求</strong>。每个分片<strong>加载并丰富文档</strong>，接着返回文档给协调节点。一旦所有的文档都被取回了， 协调节点返回结果给客户端。</p><p>&emsp;&emsp;Query Then Fetch 的搜索类型在文档相关性打分的时候参考的是本分片的数据，这样在文档数量较少 的时候可能不够准确，DFS Query Then Fetch 增加了一个预查询的处理，询问 Term 和 Document frequency，这个评分更准确，但是性能会变差。</p><h2 id="7、ElasticSearch在部署时，对Linux的设置有哪些优化方法？"><a href="#7、ElasticSearch在部署时，对Linux的设置有哪些优化方法？" class="headerlink" title="7、ElasticSearch在部署时，对Linux的设置有哪些优化方法？"></a>7、ElasticSearch在部署时，对Linux的设置有哪些优化方法？</h2><p>1、使用内存更高的机器部署ElasticSearch（64G最优，不要少于8G）；</p><p>2、选择更多核心数的机器；</p><p>3、负担得起的话，使用SSD会远远超过任何旋转介质，查询和索引性能都会有所提升；</p><p>4、确保运行你应用程序的 JVM 和服务器的 JVM 是完全一样的。 在 Elasticsearch 的几个地方，使用Java的本地序列化；</p><p>5、通过设置gateway.recover_after_nodes、gateway.expected_nodes、gateway.recover_after_time 可以在集群重启的时候避免过多的分片交换，这可能会让数据恢复从数个小时缩短为几秒钟；</p><p>6、不要随意修改垃圾回收器（CMS）和各个线程池的大小；</p><p>7、把内存的（少于）一半给 Lucene（但不要超过 32 GB！），可以通过 ES_HEAP_SIZE 环境变量设置。</p><h3 id="补充：在索引阶段性能提升的方法："><a href="#补充：在索引阶段性能提升的方法：" class="headerlink" title="补充：在索引阶段性能提升的方法："></a>补充：在索引阶段性能提升的方法：</h3><p>1、使用批量请求并调整其大小：每次批量数据 5–15 MB 大是个不错的起始点；</p><p>2、使用SSD；</p><p>3、段和合并：ElasticSearch 默认值是 20 MB/s，对机械磁盘应该是个不错的设置。如果你用的是 SSD， 可以考虑提高到 100–200 MB/s。如果你在做批量导入，完全不在意搜索，你可以彻底关掉合并限流。 另外还可以增加 index.translog.flush_threshold_size 设置，从默认的 512 MB 到更大一些的值，比如 1 GB，这可以在一次清空触发的时候在事务日志里积累出更大的段；</p><p>4、如果你的搜索结果不需要近实时的准确度，考虑把每个索引的 index.refresh_interval （刷新到文件系统缓存）由1s改到 30s；</p><p>5、如果你在做大批量导入，考虑通过设置 index.number_of_replicas: 0 关闭副本。</p><h2 id="8、在GC方面，在使用-ElasticSearch-时要注意什么？"><a href="#8、在GC方面，在使用-ElasticSearch-时要注意什么？" class="headerlink" title="8、在GC方面，在使用 ElasticSearch 时要注意什么？"></a>8、在GC方面，在使用 ElasticSearch 时要注意什么？</h2><p>1、倒排词典的索引需要常驻内存，无法 GC，需要监控 data node 上 segment memory 增长趋势；</p><p>2、field cache, filter cache, indexing cache, bulk queue 等等各类缓存，要设置合理的大小，并且要应该根据最坏的情况来看 heap 是否够用，避免采用 clear cache 等“自欺欺人”的方式来释放内存；</p><p>3、避免返回大量结果集的搜索与聚合。确实需要大量拉取数据的场景，可以采用 scan &amp; scroll api 来实现。</p><h2 id="9、-对于大数据量（上亿量级）的聚合如何实现？"><a href="#9、-对于大数据量（上亿量级）的聚合如何实现？" class="headerlink" title="9、 对于大数据量（上亿量级）的聚合如何实现？"></a>9、 对于大数据量（上亿量级）的聚合如何实现？</h2><p>&emsp;&emsp;ElasticSearch 提供的首个近似聚合是 cardinality 度量。它提供一个字段的基数，即该字段的 distinct 或者 unique 值的数目。它是基于 HLL 算法的。HLL 会先对我们的输入作哈希运算，然后根据哈希运算的结果中的bits 做概率估算从而得到基数。其特点是：可配置的精度，用来控制内存的使用（更精确 ＝ 更多内存）；小的数据集精度是非常高的；我们可以通过配置参数，来设置去重需要的固定内存使用量。无论数千还是数十亿的唯一值，内存使用量只与你配置的精确度相关。</p><h2 id="10、在并发情况下，ElasticSearch-如果保证读写一致？"><a href="#10、在并发情况下，ElasticSearch-如果保证读写一致？" class="headerlink" title="10、在并发情况下，ElasticSearch 如果保证读写一致？"></a>10、在并发情况下，ElasticSearch 如果保证读写一致？</h2><p>&emsp;&emsp;可以通过<strong>版本号使用乐观锁</strong>并发控制，以确保新版本不会被旧版本覆盖，由应用层来处理具体的冲突；</p><p>&emsp;&emsp;对于写操作，一致性级别支持 quorum[半数]/one[主分片]/all[所有分片]，默认为 quorum，即只有当大多数分片可用时才允许写操作。但即使大多数可用，也可能存在因为网络等原因导致写入副本失败，这样该副本被认为故障，分片将会在一个不同的节点上重建。</p><p>&emsp;&emsp;对于读操作，可以设置 replication 为 sync(默认)，这使得操作在主分片和副本分片都完成后才会返回； 如果设置 replication 为 async 时，也可以通过设置搜索请求参数_preference 为 primary 来查询主分片， 确保文档是最新版本。</p><h2 id="11、Elasticsearch-中的集群、节点、索引、文档是什么？"><a href="#11、Elasticsearch-中的集群、节点、索引、文档是什么？" class="headerlink" title="11、Elasticsearch 中的集群、节点、索引、文档是什么？"></a>11、Elasticsearch 中的集群、节点、索引、文档是什么？</h2><p>1、集群是<strong>一个或多个节点（服务器）的集合</strong>，它们<strong>共同保存您的整个数据</strong>，并提供<strong>跨所有节点的联合索引和搜索</strong>功能。群集由唯一名称标识，默认情况下为 “elasticsearch“ 。此名称很重要，因为如果节点设置为按名称加入群集，则该节点只能是集群的一部分；</p><p>2、节点是属于<strong>集群一部分（单个服务器）</strong>。它用来<strong>存储数据并参与群集索引和搜索功能</strong>；</p><p>3、索引就像关系数据库中的<strong>数据库</strong>。它有一个定义多种类型的映射。索引是逻辑名称空间，映射到一个或多个主分片，并且可以有零个或多个副本分片。 <strong>MySQL =&gt; 数据库     相当于   Elastic s earch =&gt; 索引</strong>；</p><p>4、文档类似于关系数据库中的<strong>每一行数据</strong>。不同之处在于索引中的每个文档可以具有不同的结构（字段），但是对于<strong>通用字段应该具有相同的数据类型</strong>。 MySQL =&gt; Databases =&gt; Tables =&gt; Columns / Rows<br>ElasticSearch =&gt; Indices =&gt; Types =&gt; 具有属性的文档。</p><h2 id="12、Elasticsearch-中的倒排索引是什么？"><a href="#12、Elasticsearch-中的倒排索引是什么？" class="headerlink" title="12、Elasticsearch 中的倒排索引是什么？"></a>12、Elasticsearch 中的倒排索引是什么？</h2><p>&emsp;&emsp;倒排索引是搜索引擎的核心。搜索引擎的主要目标是在查找发生搜索条件的文档时提供快速搜索。 ES中的倒排索引 其实就是 <strong>Lucene 的倒排索引</strong>，区别于传统的正向索引，倒排索引会<strong>再存储数据时将关键词和数据进行关联</strong>，保存到倒排表中，然后在查询时，将查询内容进行分词后在倒排表中进行查询，最后匹配数据即可。</p><p>参考链接：<a href="https://www.bilibili.com/video/BV1hh411D7sb?p=1">https://www.bilibili.com/video/BV1hh411D7sb?p=1</a></p>]]></content>
      
      
      <categories>
          
          <category> ElasticSearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
            <tag> NoSQL </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch高级篇</title>
      <link href="/blog/2021/04/22/ElasticSearch%E9%AB%98%E7%BA%A7%E7%AF%87/"/>
      <url>/blog/2021/04/22/ElasticSearch%E9%AB%98%E7%BA%A7%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="ElasticSearch高级"><a href="#ElasticSearch高级" class="headerlink" title="ElasticSearch高级"></a>ElasticSearch高级</h1><h2 id="一、ElasticSearch集群的搭建"><a href="#一、ElasticSearch集群的搭建" class="headerlink" title="一、ElasticSearch集群的搭建"></a>一、ElasticSearch集群的搭建</h2><h3 id="1、为何要搭建-Elasticsearch-集群"><a href="#1、为何要搭建-Elasticsearch-集群" class="headerlink" title="1、为何要搭建 Elasticsearch 集群"></a>1、为何要搭建 Elasticsearch 集群</h3><p>&emsp;&emsp;为什么我们需要搭建集群？它有什么优势呢？</p><h4 id="高可用性"><a href="#高可用性" class="headerlink" title="高可用性"></a>高可用性</h4><p>&emsp;&emsp;Elasticsearch 作为一个搜索引擎，我们对它的基本要求就是存储海量数据并且可以在非常短的时间内查询到我们想要的信息。所以第一步我们需要保证的就是 Elasticsearch 的高可用性。</p><p>&emsp;&emsp;那么怎样提高 Elasticsearch 的高可用性呢？这时集群的作用就体现出来了。假如 Elasticsearch 只放在一台服务器上，即单机运行，假如这台主机突然断网了或者被攻击了，那么整个 Elasticsearch 的服务就不可用了。但如果改成 Elasticsearch 集群的话，有一台主机宕机了，还有其他的主机可以支撑，这样就仍然可以保证服务是可用的。</p><p>&emsp;&emsp;那么假如一台主机宕机了，那么不就无法访问这台主机的数据了吗？那假如我要访问的数据正好存在这台主机上，那不就获取不到了吗？难道其他的主机里面也存了一份一模一样的数据？那这岂不是很浪费吗？</p><p>&emsp;&emsp;在 Elasticsearch 中，一台主机宕机了，这台主机里面存的数据依然是可以被访问到的，因为在其他的主机上也有备份，但备份的时候也不是整台主机备份，是分片备份的，那这里就又引出了一个概念——分片。</p><p>&emsp;&emsp;分片，英文叫做 Shard，顾名思义，分片就是对数据切分成了多个部分。我们知道 Elasticsearch 中一个索引（Index）相当于是一个数据库，但索引存储的时候并不是整个存一起的，它是被分片存储的，Elasticsearch 默认会把一个索引分成五个分片，当然这个数字是可以自定义的。分片是数据的容器，数据保存在分片内，分片又被分配到集群内的各个节点里。当你的集群规模扩大或者缩小时， Elasticsearch 会自动的在各节点中迁移分片，使得数据仍然均匀分布在集群里，所以相当于一份数据被分成了多份并保存在不同的主机上。</p><p>&emsp;&emsp;那这还是没解决问题啊，如果一台主机挂掉了，那么这个分片里面的数据不就无法访问了？别的主机都是存储的其他的分片。其实是可以访问的，因为其他主机存储了这个分片的备份，叫做副本，这里就引出了另外一个概念——副本。</p><p>&emsp;&emsp;副本，英文叫做 Replica，同样顾名思义，副本就是对原分片的复制，和原分片的内容是一样的，Elasticsearch 默认会生成一份副本，所以相当于是五个原分片和五个分片副本，相当于一份数据存了两份，并分了十个分片，当然副本的数量也是可以自定义的。这时我们只需要将某个分片的副本存在另外一台主机上，这样当某台主机宕机了，我们依然还可以从另外一台主机的副本中找到对应的数据。所以从外部来看，数据结果是没有任何区别的。</p><p>&emsp;&emsp;一般来说，Elasticsearch 会尽量把一个索引的不同分片存储在不同的主机上，分片的副本也尽可能存在不同的主机上，这样可以提高容错率，从而提高可用性。</p><p>&emsp;&emsp;但这时假如你只有一台主机，那不就没办法了吗？分片和副本其实是没意义的，一台主机挂掉了，就全挂掉了。</p><h4 id="健康状态"><a href="#健康状态" class="headerlink" title="健康状态"></a>健康状态</h4><p>针对一个索引，Elasticsearch 中其实有专门的衡量索引健康状况的标志，分为三个等级：</p><ul><li>green（绿色）：这代表所有的主分片和副本分片都已分配，你的集群是 100% 可用的。</li><li>yellow（黄色）：所有的主分片已经分片了，但至少还有一个副本是缺失的。不会有数据丢失，所以搜索结果依然是完整的。不过，你的高可用性在某种程度上被弱化。如果更多的分片消失，你就会丢数据了。所以可把 yellow 想象成一个需要及时调查的警告。</li><li>red（红色）：至少一个主分片以及它的全部副本都在缺失中。这意味着你在缺少数据，搜索只能返回部分数据，而分配到这个分片上的写入请求会返回一个异常。</li></ul><p>&emsp;&emsp;如果你只有一台主机的话，其实索引的健康状况也是 yellow，因为一台主机，集群没有其他的主机可以防止副本，所以说，这就是一个不健康的状态，因此集群也是十分有必要的。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210415170843264.png" alt="image-20210415170843264"></p><h4 id="存储空间"><a href="#存储空间" class="headerlink" title="存储空间"></a>存储空间</h4><p>&emsp;&emsp;另外，既然是集群，那么存储空间肯定也是联合起来的，假如一台主机的存储空间是固定的，那么集群它相对于单个主机也有更多的存储空间，可存储的数据量也更大。</p><h3 id="2、Linux环境下搭建ElasticSearch集群"><a href="#2、Linux环境下搭建ElasticSearch集群" class="headerlink" title="2、Linux环境下搭建ElasticSearch集群"></a>2、Linux环境下搭建ElasticSearch集群</h3><h4 id="2-1、环境准备"><a href="#2-1、环境准备" class="headerlink" title="2.1、环境准备"></a>2.1、环境准备</h4><ul><li>安装包下载：见上一篇<a href="http://cheng_qiwei.gitee.io/blog/2021/04/14/ElasticSearch%E5%9F%BA%E7%A1%80%E7%AF%87/">文档</a></li></ul><h4 id="2-2、安装部署ElasticSearch"><a href="#2-2、安装部署ElasticSearch" class="headerlink" title="2.2、安装部署ElasticSearch"></a>2.2、安装部署ElasticSearch</h4><h5 id="2-2-1、解压安装包"><a href="#2-2-1、解压安装包" class="headerlink" title="2.2.1、解压安装包"></a>2.2.1、解压安装包</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxf elasticsearch-7.12.0-linux-x86_64.tar.gz -C /usr/local/es/</span><br></pre></td></tr></table></figure><p>这里注意不要安装在<code>/root</code>目录下</p><h5 id="2-2-2、创建data目录和log目录"><a href="#2-2-2、创建data目录和log目录" class="headerlink" title="2.2.2、创建data目录和log目录"></a>2.2.2、创建data目录和log目录</h5><p>在elasticsearch-7.12.0的目录下创建data目录，用于保存数据。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/es/elasticsearch-7.12.0/ &amp;&amp; mkdir data</span><br></pre></td></tr></table></figure><h5 id="2-2-3、修改配置文件"><a href="#2-2-3、修改配置文件" class="headerlink" title="2.2.3、修改配置文件"></a>2.2.3、修改配置文件</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ./config/elasticsearch.yml</span><br></pre></td></tr></table></figure><p>修改结果如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ======================== Elasticsearch Configuration =========================</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 集群名称</span></span><br><span class="line"><span class="attr">cluster.name:</span> <span class="string">myelasticsearch</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 节点名称</span></span><br><span class="line"><span class="attr">node.name:</span> <span class="string">node-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 表示该节点会不会作为主节点，true表示会；false表示不会</span></span><br><span class="line"><span class="attr">node.master:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前节点是否用于存储数据，是：true、否：false</span></span><br><span class="line"><span class="attr">node.data:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据保存路径</span></span><br><span class="line"><span class="attr">path.data:</span> <span class="string">/usr/local/es/elasticsearch-node-1/data</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志保存路径</span></span><br><span class="line"><span class="attr">path.logs:</span> <span class="string">/usr/local/es/elasticsearch-node-1/logs</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Lock the memory on startup</span></span><br><span class="line"><span class="attr">bootstrap.memory_lock:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 节点ip地址</span></span><br><span class="line"><span class="attr">network.host:</span> <span class="number">192.168</span><span class="number">.66</span><span class="number">.128</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set a custom port for HTTP:</span></span><br><span class="line"><span class="attr">http.port:</span> <span class="number">9200</span></span><br><span class="line"><span class="attr">transport.tcp.port:</span> <span class="number">9300</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># es7.x 之后新增的配置，写入候选主节点的设备地址，在开启服务后可以被选为主节点</span></span><br><span class="line"><span class="attr">discovery.seed_hosts:</span> [<span class="string">&quot;192.168.66.128&quot;</span>,<span class="string">&quot;192.168.66.129&quot;</span>,<span class="string">&quot;192.168.66.130&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 防止脑裂</span></span><br><span class="line"><span class="attr">discovery.zen.minimum_master_nodes:</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断结点是否脱离时间配置</span></span><br><span class="line"><span class="attr">discovery.zen.fd.ping_timeout:</span> <span class="string">60s</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断结点是否脱离次数配置</span></span><br><span class="line"><span class="attr">discovery.zen.fd.ping_retries:</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># es7.x 之后新增的配置，初始化一个新的集群时需要此配置来选举master</span></span><br><span class="line"><span class="attr">cluster.initial_master_nodes:</span> [<span class="string">&quot;node-1&quot;</span>,<span class="string">&quot;node-2&quot;</span>,<span class="string">&quot;node-3&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 表示开启跨域访问支持，此值默认为fals</span></span><br><span class="line"><span class="attr">http.cors.enabled:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 表示跨域访问允许的域名地址，可使用正则表达式，“*”则表示允许所有域名访问</span></span><br><span class="line"><span class="attr">http.cors.allow-origin:</span> <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure><h5 id="2-2-4、修改JVM参数"><a href="#2-2-4、修改JVM参数" class="headerlink" title="2.2.4、修改JVM参数"></a>2.2.4、修改JVM参数</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vi config/jvm.options</span><br><span class="line"></span><br><span class="line">-Xms4g  →  -Xms512m</span><br><span class="line">-Xmx4g  →  -Xmx512m</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将配置进行修改</span></span><br><span class="line">8-13:-XX:+UseConcMarkSweepGC</span><br><span class="line"><span class="meta">#</span><span class="bash"> 改为</span></span><br><span class="line">8-13:-XX:+UseG1GC</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618584006615.png" alt="1618584006615"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618586292054.png" alt="1618586292054"></p><h5 id="2-2-5、创建普通用户"><a href="#2-2-5、创建普通用户" class="headerlink" title="2.2.5、创建普通用户"></a>2.2.5、创建普通用户</h5><p>&emsp;&emsp;由于es无法使用root用户启动，所以我们需要创建一个用户用于es的启动，这里要注意密码不要设置过于简单，会不通过。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">创建用户组   groupadd esgroup</span><br><span class="line">创建用户     useradd -g esgroup es</span><br><span class="line">设置权限     chown -R es:esgroup /usr/local/es/</span><br><span class="line">设置密码     passwd es</span><br><span class="line">cqw1314520</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618584684323.png" alt="1618584684323"></p><h5 id="2-2-6、修改linux内核参数"><a href="#2-2-6、修改linux内核参数" class="headerlink" title="2.2.6、修改linux内核参数"></a>2.2.6、修改linux内核参数</h5><p>我们需要修改Linux文件的最大打开数，否则会启动报错</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/security/limits.conf </span><br><span class="line"></span><br><span class="line">* hard nofile 65536</span><br><span class="line">* soft nofile 65536</span><br><span class="line">* soft nproc  4096</span><br><span class="line">* hard nproc  4096</span><br><span class="line">----------------------------------------------------------------------------------</span><br><span class="line">echo &quot;vm.max_map_count=262144&quot; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure><h5 id="2-2-7、修改完成后，复制文件夹，拷贝出新的两个节点并放置到其他两台虚拟机中"><a href="#2-2-7、修改完成后，复制文件夹，拷贝出新的两个节点并放置到其他两台虚拟机中" class="headerlink" title="2.2.7、修改完成后，复制文件夹，拷贝出新的两个节点并放置到其他两台虚拟机中"></a>2.2.7、修改完成后，复制文件夹，拷贝出新的两个节点并放置到其他两台虚拟机中</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 改名</span></span><br><span class="line">mv elasticsearch-7.12.0/ elasticsearch-node-1</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618632686053.png" alt="1618632686053"></p><h5 id="2-2-8、修改子节点配置文件"><a href="#2-2-8、修改子节点配置文件" class="headerlink" title="2.2.8、修改子节点配置文件"></a>2.2.8、修改子节点配置文件</h5><p>&emsp;&emsp;根据截图进行修改对应内容，同时，由于改名，节点1也需要进行data和log目录路径修改。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ======================== Elasticsearch Configuration =========================</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 集群名称</span></span><br><span class="line"><span class="attr">cluster.name:</span> <span class="string">myelasticsearch</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 节点名称</span></span><br><span class="line"><span class="attr">node.name:</span> <span class="string">node-2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 表示该节点会不会作为主节点，true表示会；false表示不会</span></span><br><span class="line"><span class="attr">node.master:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前节点是否用于存储数据，是：true、否：false</span></span><br><span class="line"><span class="attr">node.data:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据保存路径</span></span><br><span class="line"><span class="attr">path.data:</span> <span class="string">/usr/local/es/elasticsearch-node-2/data</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志保存路径</span></span><br><span class="line"><span class="attr">path.logs:</span> <span class="string">/usr/local/es/elasticsearch-node-2/logs</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Lock the memory on startup</span></span><br><span class="line"><span class="attr">bootstrap.memory_lock:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 节点ip地址</span></span><br><span class="line"><span class="attr">network.host:</span> <span class="number">192.168</span><span class="number">.66</span><span class="number">.129</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set a custom port for HTTP:</span></span><br><span class="line"><span class="attr">http.port:</span> <span class="number">9200</span></span><br><span class="line"><span class="attr">transport.tcp.port:</span> <span class="number">9300</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># es7.x 之后新增的配置，写入候选主节点的设备地址，在开启服务后可以被选为主节点</span></span><br><span class="line"><span class="attr">discovery.seed_hosts:</span> [<span class="string">&quot;192.168.66.128&quot;</span>,<span class="string">&quot;192.168.66.129&quot;</span>,<span class="string">&quot;192.168.66.130&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 防止脑裂</span></span><br><span class="line"><span class="attr">discovery.zen.minimum_master_nodes:</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断结点是否脱离时间配置</span></span><br><span class="line"><span class="attr">discovery.zen.fd.ping_timeout:</span> <span class="string">60s</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断结点是否脱离次数配置</span></span><br><span class="line"><span class="attr">discovery.zen.fd.ping_retries:</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># es7.x 之后新增的配置，初始化一个新的集群时需要此配置来选举master</span></span><br><span class="line"><span class="attr">cluster.initial_master_nodes:</span> [<span class="string">&quot;node-1&quot;</span>,<span class="string">&quot;node-2&quot;</span>,<span class="string">&quot;node-3&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 表示开启跨域访问支持，此值默认为fals</span></span><br><span class="line"><span class="attr">http.cors.enabled:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 表示跨域访问允许的域名地址，可使用正则表达式，“*”则表示允许所有域名访问</span></span><br><span class="line"><span class="attr">http.cors.allow-origin:</span> <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618632788502.png" alt="1618632788502"></p><h4 id="2-3、启动ElasticSearch集群"><a href="#2-3、启动ElasticSearch集群" class="headerlink" title="2.3、启动ElasticSearch集群"></a>2.3、启动ElasticSearch集群</h4><p><font color='red'>这里需要注意，至少启动两个节点，如果只启动一个节点，则会出现访问失败、连接失败等问题…</font></p><p>执行命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 切换到es用户</span></span><br><span class="line">su es </span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动命令,这里 -d 代表后台启动</span></span><br><span class="line">bash ./bin/elasticsearch -d</span><br></pre></td></tr></table></figure><p>使用命令开启端口防火墙权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=9200/tcp --permanent</span><br><span class="line">firewall-cmd --zone=public --add-port=9300/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p>7、查看结果：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618633146820.png" alt="1618633146820"></p><p>使用head工具观察：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618647178078.png" alt="1618647178078"></p><p>或者访问：<a href="http://ip:9200/_cluster/health%E6%9F%A5%E7%9C%8B%E5%81%A5%E5%BA%B7%E6%83%85%E5%86%B5">http://IP:9200/_cluster/health查看健康情况</a></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618651033029.png" alt="1618651033029"></p><h2 id="二、Es原理相关知识点"><a href="#二、Es原理相关知识点" class="headerlink" title="二、Es原理相关知识点"></a>二、Es原理相关知识点</h2><h3 id="1、单节点集群"><a href="#1、单节点集群" class="headerlink" title="1、单节点集群"></a>1、单节点集群</h3><p>&emsp;&emsp;使用我们的单机版es，创建索引（最新版本中，集群版本不支持单节点启动）</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618654099201.png" alt="1618654099201"></p><h3 id="2、故障转移"><a href="#2、故障转移" class="headerlink" title="2、故障转移"></a>2、故障转移</h3><p>&emsp;&emsp;当集群中只有一个节点在运行时，意味着会有一个单点故障问题——没有冗余。 幸运的是，我们只需再启动一个节点即可防止数据丢失。当你在同一台机器上启动了第二个节点时，只要它和第一个节点有同样的 cluster.name 配置，它就会自动发现集群并加入到其中。但是在不同机器上启动节点的时候，为了加入到同一集群，你需要配置一个可连接到的单播主机列表。之所以配置为使用单播发现，以防止节点无意中加入集群。只有在同一台机器上运行的节点才会自动组成集群。</p><p>&emsp;&emsp;如果启动了第二个节点，我们的集群将会拥有两个节点的集群: 所有主分片和副本分片都已被分配。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618654360643.png" alt="1618654360643"></p><h3 id="3、水平扩容"><a href="#3、水平扩容" class="headerlink" title="3、水平扩容"></a>3、水平扩容</h3><p>&emsp;&emsp;当启动了第三个节点，我们的集群将会拥有三个节点的集群 : 为了分散负载而对分片进行重新分配。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618654670366.png" alt="1618654670366"></p><h3 id="Question1：在上面的基础上，如果我们想要扩容超过6-个节点怎么办呢？"><a href="#Question1：在上面的基础上，如果我们想要扩容超过6-个节点怎么办呢？" class="headerlink" title="Question1：在上面的基础上，如果我们想要扩容超过6 个节点怎么办呢？"></a>Question1：在上面的基础上，如果我们想要扩容超过6 个节点怎么办呢？</h3><p>&emsp;&emsp;主分片的数目在索引创建时就已经确定了下来。实际上，这个数目定义了这个索引能够存储 的最大数据量。（实际大小取决于你的数据、硬件和使用场景。） 但是，读操作搜索和返回数据 可以同时被主分片 或 副本分片所处理，所以当你拥有越多的副本分片时，也将拥有越高的吞吐量。在运行中的集群上是可以动态调整副本分片数目的，我们可以按需伸缩集群。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618668699205.png" alt="1618668699205"></p><p>&emsp;&emsp;当然，如果只是在相同节点数目的集群上增加更多的副本分片并不能提高性能，因为每个分片从节点上获得的资源会变少。 你需要增加更多的硬件资源来提升吞吐量。但是更多的副本分片数提高了数据冗余量：按照上面的节点配置，我们可以在失去2 个节点的情况下不丢失任何数据。</p><h3 id="4、应对故障"><a href="#4、应对故障" class="headerlink" title="4、应对故障"></a>4、应对故障</h3><p>&emsp;&emsp;此时，我们关闭的节点是一个主节点。而集群必须拥有一个主节点来保证正常工作，所以发生的第一件事情就是选举一个新的主节点： Node 2 。在我们关闭 Node 1 的同时也失去了主分片 1 和 2 ，并且在缺失主分片的时候索引也不能正常工作。 如果此时来检查集群的状况，我们看到的状态将会为red ：不是所有主分片都在正常工作。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618668953595.png" alt="1618668953595"></p><p>&emsp;&emsp;幸运的是，在其它节点上存在着这两个主分片的完整副本，所以新的主节点立即将这些分片在 Node 2 和 Node 3 上对应的副本分片提升为主分片， 此时集群的状态将会为yellow 。这个提升主分片的过程是瞬间发生的。</p><h3 id="Question2：为什么我们集群状态是yellow-而不是-green-呢？"><a href="#Question2：为什么我们集群状态是yellow-而不是-green-呢？" class="headerlink" title="Question2：为什么我们集群状态是yellow 而不是 green 呢？"></a>Question2：为什么我们集群状态是yellow 而不是 green 呢？</h3><p>&emsp;&emsp;虽然我们拥有所有的三个主分片，但是由于我们设置了每个主分片需要对应2 份副本分片，而此时只存在一份副本分片。 所以集群不能为 green 的状态，但是我们不必过于担心：如果我们同样关闭了 Node 2 ，我们的程序 依然 可以保持在不丢任何数据的情况下运行，因为Node 3 为每一个分片都保留着一份副本。如果我们重新启动Node 1 ，集群可以将缺失的副本分片再次进行分配，那么集群的 状态也将恢复成之前的状态。 如果 Node 1 依然拥有着之前的分片，它将尝试去重用它们，同时仅从主分片复制发生了修改的数据文件。和之前的集群相比，只是 Master 节点切换了。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618669319274.png" alt="1618669319274"></p><h3 id="5、路由计算"><a href="#5、路由计算" class="headerlink" title="5、路由计算"></a>5、路由计算</h3><p>&emsp;&emsp;当索引一个文档的时候，文档会被存储到一个主分片中。Elasticsearch 如何知道一个文档应该存放到哪个分片中呢？当我们创建文档时，它如何决定这个文档应当被存储在分片1 还是分片 2 中呢？首先这肯定不会是随机的，否则将来要获取文档的时候我们就不知道从何处寻找了。实际上，这个过程是根据下面这个公式决定的：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618669573377.png" alt="1618669573377"></p><p>公式解析：</p><p>&emsp;&emsp;routing是一个可变值，默认是文档的 _id ，也可以设置成一个自定义的值。 routing 通过hash 函数生成一个数字，然后这个数字再除以 number_of_primary_shards （主分片的数量后得到余数。这个分布在 0 到 number_of_primary_shards（分片数量）-1 之间的余数，就是我们所寻求的文档所在分片的位置。</p><p>&emsp;&emsp;所有的文档的API get 、 index 、 delete 、 bulk 、 update 以及 mget ）都接受一个叫做 routing 的路由参数 ，通过这个参数我们可以自定义文档到分片的映射。一个自定义的路由参数可以用来确保所有相关的文档 例如所有属于同一个用户的文档 都被存储到同一个分片中。</p><h3 id="6、分片控制"><a href="#6、分片控制" class="headerlink" title="6、分片控制"></a>6、分片控制</h3><p>&emsp;&emsp;我们可以发送请求到集群中的任一节点。每个节点都有能力处理任意请求。 每个节点都知道集群中任一文档位置，所以可以直接将请求转发到需要的节点上。 我们将这类转发的节点称为。**协调节点 (coordinating node)**。</p><p>接下来，我们通过写流程、读流程和更新流程来了解协调节点的作用：</p><h4 id="6-1、写流程"><a href="#6-1、写流程" class="headerlink" title="6.1、写流程"></a>6.1、写流程</h4><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618673590979.png" alt="1618673590979"></p><blockquote><p>新建、索引和删除文档所需要的步骤顺序：</p><p>1、客户端向任意集群节点发送请求；</p><p>2、获得请求的节点成为协调节点，该节点使用文档的id计算该文档属于哪个主分片，将文档发送给计算出来结果的那个主分片所在的节点；</p><p>3、主分片负责将数据进行保存，并将数据发送给对应的副本进行同步；</p><p>4、副本保存完成后，向主分片进行反馈；</p><p>5、主分片向客户端进行反馈，客户端获取返回结果。</p></blockquote><p>&emsp;&emsp;在客户端收到成功响应时，文档变更已经在主分片和所有副本分片执行完成，变更是安全的。有一些可选的请求参数允许你影响这个过程，可能以数据安全为代价提升性能。这些选项很少使用，因为 Elasticsearch 已经很快，但是为了完整起见， 请参考下面内容：</p><p>参数： consistency </p><p>&emsp;&emsp;consistency，即一致性。在默认设置下，即使仅仅是在试图执行一个 写 操作之前，主分片都会要求 必须要有 规定数量 ( quorum)（或者换种说法，也即必须要有大多数）的分片副本处于活跃可用状态，才会去执行 写 操作 其中分片副本可以是主分片或者副本分片 。这是为了避免在发生网络分区故障（ networkpartition ）的时候进行 写 操作，进而导致数据不一致。 规定数量 即：                                                                                                                                   &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;int( (primary + number_of_replicas) / 2 ) + 1<br>&emsp;&emsp;consistency参数的值可以设为<font color='red'>one （只要主分片状态 ok 就允许执行 写 操作）,all （必须要主分片和所有副本分片的状态没问题才允许执行 写 操作） , 或quorum 。默认值为 quorum , 即大多数的分片副本状态没问题就允许执行 写操作。</font>注意，规定数量的计算公式中 number_of_replicas 指的是在索引设置中的设定副本分片数，而不是指当前处理活动状态的副本分片数。如果你的索引设置中指定了当前索引拥有三个副本分片，那规定数量的计算结果即：<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;int( (primary + 3 replicas) / 2 ) + 1 = 3<br>&emsp;&emsp;如果此时你只启动两个节点，那么处于活跃状态的分片副本数量就达不到规定数量，也因此您将无法索引和删除任何文档。<br>参数：timeout     </p><p>&emsp;&emsp;如果没有足够的副本分片会发生什么？Elasticsearch 会等待，希望更多的分片出现。默认情况下，它最多等待 1 分钟。 如果你需要，你可以使用 timeout 参数使它更早终止： 100 100 毫秒， 30s 是 30 秒。 </p><p>&emsp;&emsp;新索引默认有1 个副本分片，这意味着为满足规定数量应该需要两个活动的分片副本。 但是，这些默认的设置会阻止我们在单一节点上做任何事情。为了避免这个问题，要求只有当 number_of_replicas 大于 1 的时候，规定数量才会执行。</p><h4 id="6-2、读流程"><a href="#6-2、读流程" class="headerlink" title="6.2、读流程"></a>6.2、读流程</h4><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618673574467.png" alt="1618673574467"></p><blockquote><p> 检索文档的步骤顺序：</p><p>1、客户端发送查询请求到任意节点；</p><p>2、获得请求的节点成为协调节点，该节点计算数据所在的分片及全部副本的位置；</p><p>3、为了能够负债均衡，可以轮询所有节点；</p><p>4、将请求发送给具体的节点进行查询；</p><p>5、节点返回查询结果，并将结果反馈给客户端。</p></blockquote><h4 id="6-3、更新流程"><a href="#6-3、更新流程" class="headerlink" title="6.3、更新流程"></a>6.3、更新流程</h4><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618673859453.png" alt="1618673859453"></p><blockquote><p>1、客户端发送查询请求到任意节点；</p><p>2、获得请求的节点成为协调节点，该节点使用文档的id计算该文档属于哪个主分片，将需要修改的内容发送给计算出来结果的那个主分片所在的节点；</p><p>3、节点从主分片上检索文档，修改数据，并且尝试重新索引主分片的文档。 如果文档已经被另一个进程修改，它会重试本步骤 ，超过 retry_on_conflict 次后放弃。</p><p>4、如果 该节点成功地更新文档，它将新版本的文档并行转发到 其他的副本上覆盖，重新建立索引。一旦所有副本分片都返回成功， 该节点将向协调节点也返回成功，协调节点向客户端返回成功。</p></blockquote><p>注意：当主分片把更改转发到副本分片时，它不会转发更新请求。 相反，它会<strong>转发完整文档的新版本</strong>。请记住，这些更改将会异步转发到副本分片，并且不能保证它们以发送它们相同的顺序到达。 如果 Elasticsearch 仅转发更改请求，则可能以错误的顺序应用更改，导致得到损坏的文档。</p><h3 id="7、分片原理"><a href="#7、分片原理" class="headerlink" title="7、分片原理"></a>7、分片原理</h3><p>&emsp;&emsp;分片是 Elasticsearch <font color='red'>最小的工作单元</font>。传统的数据库每个字段存储单个值，但这对全文检索并不够。文本字段中的每个单词需要被搜索，对数据库意味着需要单个字段有索引多值的能力。最好的支持 是 一个字段多个值需求的数据结构是<font color='red'>倒排索引</font>。</p><h4 id="7-1、倒排索引"><a href="#7-1、倒排索引" class="headerlink" title="7.1、倒排索引"></a>7.1、倒排索引</h4><p>&emsp;&emsp;说起倒排索引，就不得不说一下与他对应的正向索引。</p><p>&emsp;&emsp;所谓的正向索引，就是搜索引擎会将待搜索的文件都对应一个文件ID ，搜索时将这个ID 和搜索关键字进行对应，形成 K V 对，然后对关键字进行统计计数。从广义来说，正向索引（doc values） 本质上是一个序列化的 列式存储 。列式存储 适用于聚合、排序、脚本等操作，所有的数字、地理坐标、日期、IP 和不分析（ not_analyzed ）字符类型都会默认开启。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618720994762.png" alt="1618720994762"></p><p>&emsp;&emsp;但是互联网上收录在搜索引擎中的文档的数目是个天文数字，这样的索引结构根本无法满足实时返回排名结果的要求。 而倒排索引的优势在于<strong>查找包含某个项的文档</strong>。所以，搜索引擎会将正向索引重新构建为倒排索引，即把文件ID 对应到关键词的映射转换为关键词到文件 ID 的映射，每个关键词都对应着一系列的文件，这些文件中都出现这个关键词。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618731007150.png" alt="1618731007150"></p><h4 id="7-2、文档搜索"><a href="#7-2、文档搜索" class="headerlink" title="7.2、文档搜索"></a>7.2、文档搜索</h4><p>&emsp;&emsp;早期的全文检索会为整个文档集合建立一个很大的倒排索引并将其写入到磁盘。一旦新的索引就绪，旧的就会被其替换，这样最近的变化便可以被检索到。倒排索引被写入磁盘后是不可改变的。</p><p>而这个不变性具有重要的价值：</p><blockquote><p>1、<strong>不需要锁</strong>。如果你从来不更新索引，你就不需要担心多进程同时修改数据的问题。</p><p>2、一旦索引被读入内核的文件系统缓存，便会留在那里，由于其不变性，只要文件系统缓存中还有足够的空间，那么大部分读请求会直接请求内存，而不会命中磁盘。这提供了很大的性能提升。</p><p>3、而对于其他缓存（像上面讲到的filter缓存），在索引的生命周期内始终有效。它们不需要在每次数据改变时被重建，因为数据不会变化。</p><p>4、写入单个大的倒排索引允许数据被压缩，减少磁盘 I/O 和需要被缓存到内存的索引的使用量。</p></blockquote><p>&emsp;&emsp;当然，一个不变的索引也有不好的地方。主要事实是它是不可改变的! 假如你需要让一个新的文档可被搜索，你需要重建整个索引。这要么对一个索引所能包含的数据量造成了很大的限制，要么对索引可被更新的频率造成了很大的限制。那么如何在保留不变性的基础上实现倒排索引的更新呢？</p><h4 id="7-3、动态更新索引"><a href="#7-3、动态更新索引" class="headerlink" title="7.3、动态更新索引"></a>7.3、动态更新索引</h4><p>&emsp;&emsp;实现倒排索引的更新，唯一的方式是<font color='red'>使用更多的索引</font>。通过增加新的补充索引来反映修改，而不是直接重写整个倒排索引。每一个倒排索引都会被轮流查询到 从最早的开始查询完后再对结果进行合并。这也是ElasticSearch基于Lucene所引入的<font color='red'>按段搜索</font>的概念。</p><p>&emsp;&emsp;当一个查询被触发，所有已知的段按顺序被查询。词项统计会对所有段的结果进行聚合，以保证每个词和每个文档的关联都被准确计算。 这种方式可以用相对较低的成本将新文档添加到索引。<br>&emsp;&emsp;段是不可改变的，所以既不能把文档从旧的段中移除，也不能修改旧的段来进行反映文档的更新。 取而代之的是，每个提交点会包含一个 .del 文件，文件中会列出这些被删除文档的段信息。</p><p><font color='red'>注意：</font></p><blockquote><p>&emsp;&emsp;当一个文档被 “删除” 时，它实际上只是在 .del 文件中被 标记 删除。一个被标记删除的文档仍然可以被查询匹配到，文档仍然可以被查询匹配到， 但它会在最终结果被返回前从结果集中移除。但它会在最终结果被返回前从结果集中移除。<br>&emsp;&emsp;文档更新也是类似的操作方式：当一个文档被更新时，旧版本文档被标记删除，文档的新版本被索引到一个新的段中。 可能两个版本的文档都会被一个查询匹配到，但被删除的那个旧版本文档在结果集返回前就已经被移除。</p></blockquote><h4 id="7-4、近实时搜索"><a href="#7-4、近实时搜索" class="headerlink" title="7.4、近实时搜索"></a>7.4、近实时搜索</h4><p>&emsp;&emsp;随着按段搜索的发展，一个新的文档从索引到可被 搜索的延迟显著降低了。新文档在几分钟之内即可被检索，但这样还是不够快。如图，一个新的文档从索引到可被搜索的延时为：</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>延时 = 主分片操作时的延时 + 并行写入副本的最大延时</strong></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618746041856.png" alt="1618746041856"></p><h5 id="7-4-1、写操作在内存与磁盘中的流程"><a href="#7-4-1、写操作在内存与磁盘中的流程" class="headerlink" title="7.4.1、写操作在内存与磁盘中的流程"></a>7.4.1、写操作在内存与磁盘中的流程</h5><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618757764643.png" alt="1618757764643"></p><blockquote><p>1、一个文档被索引之后，就会被添加到内存缓冲区，然后追加到了 translog；</p><p>2、分片每秒会被刷新1次在（refresh：1s）；</p><p>把内存缓冲区中的文档写入文件系统缓存os cache中，同时使该缓存能够被搜索，同时清空内存缓冲区</p><p>3、每隔一段较长的时间文件系统缓存执行一次刷新（flush：30min，或者transLog太大时）</p><p>此时会将之前追加的日志创建成一个新的transLog，并将一个提交点写入磁盘，旧的translog被删除。</p><p>在flush到磁盘时，此时就会合并之前的操作，例如，之前修改一个文档是保存一份文档的新版本，同时对旧版本标记删除，合并时就真的会将旧版本进行删除，删除文档同理。</p></blockquote><h2 id="三、文档分析"><a href="#三、文档分析" class="headerlink" title="三、文档分析"></a>三、文档分析</h2><p>ElasticSearch对文档分析，其实包含下面的过程：<br>a、将一块文本分成适合于倒排索引的独立的 词条；<br>b、将这些词条统一化为标准格式以提高它们的 可搜索性 ，或者 recall。</p><h3 id="1、分析器的功能"><a href="#1、分析器的功能" class="headerlink" title="1、分析器的功能"></a>1、分析器的功能</h3><p>&emsp;&emsp;分析器执行分析的操作，其实是将字符过滤器、分词器和Token过滤器三个功能封装在一起。</p><h4 id="1-1、字符过滤器（character-filter）"><a href="#1-1、字符过滤器（character-filter）" class="headerlink" title="1.1、字符过滤器（character filter）"></a>1.1、字符过滤器（character filter）</h4><p>&emsp;&emsp;字符过滤器会在最早执行，它的功能主要是在分此前整理字符串。例如：去掉html标签，或者转换字符（&amp; –&gt;  and）等等。</p><blockquote><p>字符过滤器的类型一般有三种</p><p>a、<strong>html_scrip 自动去除html过滤器</strong>：把过滤内容中所有的html标签进行过滤；</p><p>&emsp;&emsp;它包含一个配置项：escaped_tags 功能是保留某些标签，例如保留<code>&lt;a&gt;&lt;/a&gt;</code>标签，则配置”escaped_tags”: [“a”]即可。</p><p>b、<strong>mapping 映射过滤器</strong>：把某些内容映射为其他内容；</p><p>&emsp;&emsp;例如：把<code>&amp;</code>转换为<code>and</code>，把<code>|</code>转为<code>or</code>。</p><p>c、<strong>Pattern 正则过滤器</strong>：可以通过正则表达式对文档内容进行替换。</p><p>&emsp;&emsp;例如：把文档中所有的<code>-</code>替换成<code>_</code>，他有一个配置项：replacement 功能是填写替换的内容。</p></blockquote><h4 id="1-2、分词器（tokenizer）"><a href="#1-2、分词器（tokenizer）" class="headerlink" title="1.2、分词器（tokenizer）"></a>1.2、分词器（tokenizer）</h4><p>&emsp;&emsp;紧接其后，字符串会来到分词器这里，将字符串分成单个的词条。一个简单的分词器遇到空格或标点符号的时候，可能会将文本拆分成词条。</p><h4 id="1-3、Token过滤器（token-filter）"><a href="#1-3、Token过滤器（token-filter）" class="headerlink" title="1.3、Token过滤器（token filter）"></a>1.3、Token过滤器（token filter）</h4><p>&emsp;&emsp;最后词条按照顺序通过每个Token过滤器，在这个过程中，可能会对词条进行改变，例如：删除一些没意义的词条（a 、the 、and），或者改变词条（将Quick –&gt; quick），或者增加词条（类似jump和leap这种同义词）等等。</p><h3 id="2、ElasticSearch的内置分析器"><a href="#2、ElasticSearch的内置分析器" class="headerlink" title="2、ElasticSearch的内置分析器"></a>2、ElasticSearch的内置分析器</h3><p>&emsp;&emsp;Elasticsearch附带了可以直接使用的预包装的分析器。接下来我们简单介绍几种：</p><h4 id="2-1、简单分析器"><a href="#2-1、简单分析器" class="headerlink" title="2.1、简单分析器"></a>2.1、简单分析器</h4><p>&emsp;&emsp;简单分析器会在任何不是字母的地方分割文本并将词条小写。如：</p><p>set,a.file_index  ===&gt;   set,a,file,index</p><h4 id="2-2、空格分析器"><a href="#2-2、空格分析器" class="headerlink" title="2.2、空格分析器"></a>2.2、空格分析器</h4><p>&emsp;&emsp;空格分析器会在任何空格的地方划分文本。如：</p><p>set   a  file_index ===&gt;  set,a,file_index</p><h4 id="2-3、语言分析器"><a href="#2-3、语言分析器" class="headerlink" title="2.3、语言分析器"></a>2.3、语言分析器</h4><p>&emsp;&emsp;特定的语言分析器可以对不同语言进行分析，由于可以考虑语言的特点，它们分析的结果往往更加符合实际情况。例如：英语分析器自带一组英语无用词库，可以将一些没有意义的词汇进行删除（the 、a），亦或者可以提取英语单词的词干（logs  ==&gt;  log），亦或者我们之前提到的IK分词器，能够对中文进行合理的分割。</p><h3 id="3、测试分析器"><a href="#3、测试分析器" class="headerlink" title="3、测试分析器"></a>3、测试分析器</h3><p>测试命令：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET http://localhost:9200/_analyze</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;standard&quot;</span>,<span class="comment">//标准分析器</span></span><br><span class="line">    <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;Text to analyze&quot;</span><span class="comment">//分析内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618841410863.png" alt="1618841410863"></p><p>名词解释：</p><p>token：指实际存储到索引的词条；</p><p>position：指词条在原始文本中出现的位置；</p><p>start_offset  和  end_offset：指字符在原始字符串中的位置。</p><h3 id="4、自定义分析器"><a href="#4、自定义分析器" class="headerlink" title="4、自定义分析器"></a>4、自定义分析器</h3><p>&emsp;&emsp;虽然Elasticsearch 带有一些现成的分析器，然而在分析器上 Elasticsearch 真正的强大之处在于，你可以通过在一个适合你的特定数据的设置之中组合字符过滤器、分词器、词汇单元过滤器来创建自定义的分析器。</p><p>自定义一个分析器：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;settings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;analysis&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;char_filter&quot;</span>: &#123;  <span class="comment">//自定义字符过滤器，设置映射规则</span></span><br><span class="line">          <span class="attr">&quot;&amp;_to_and&quot;</span>: &#123;</span><br><span class="line">              <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;mapping&quot;</span>,</span><br><span class="line">              <span class="attr">&quot;mappings&quot;</span>: [ <span class="string">&quot;&amp;=&gt; and &quot;</span>]</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;filter&quot;</span>:&#123;  <span class="comment">//过滤器，过滤指定字符</span></span><br><span class="line">        <span class="attr">&quot;my_stopwords&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;stop&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;stopwords&quot;</span>: [ <span class="string">&quot;the&quot;</span>, <span class="string">&quot;a&quot;</span> ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;analyzer&quot;</span>: &#123;   <span class="comment">//自定义分词器</span></span><br><span class="line">        <span class="attr">&quot;my_analyzer&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;custom&quot;</span>,  <span class="comment">//告诉ES这是一个自定义分词器</span></span><br><span class="line">          <span class="attr">&quot;char_filter&quot;</span>: [ <span class="string">&quot;html_strip&quot;</span>, <span class="string">&quot;&amp;_to_and&quot;</span> ],  <span class="comment">//设置两个字符过滤器</span></span><br><span class="line">          <span class="attr">&quot;tokenizer&quot;</span>: <span class="string">&quot;standard&quot;</span>,  <span class="comment">//设置内置分词器作为基本分词器</span></span><br><span class="line">          <span class="attr">&quot;filter&quot;</span>: [ <span class="string">&quot;lowercase&quot;</span>, <span class="string">&quot;my_stopwords&quot;</span> ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分词测试：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618846054509.png" alt="1618846054509"></p><h2 id="四、文档冲突"><a href="#四、文档冲突" class="headerlink" title="四、文档冲突"></a>四、文档冲突</h2><p>&emsp;&emsp;Elasticsearch是分布式的。当文档创建、更新或删除时， 新版本的文档必须复制到集群中的其他节点。 Elasticsearch 也是异步和并发的，这意味着这些复制请求被并行发送，并且到达目的地时也许顺序是乱的 。 所以Elasticsearch 需要一种方法确保文档的旧版本不会覆盖新的版本。</p><p>&emsp;&emsp;我们之前在做各种各样的操作的时候，我们都知道每个文档中都存在一个版本号，当文件被修改时，版本号就会递增。ElasticSearch使用<font color='red'>CAS加版本号</font>来确保变更是被顺序执行的。如果版本不是当前版本号，我们的请求就会失败。</p><p>&emsp;&emsp;当然，旧的版本使用的是version，但是新的版本不建议了，会提示以下错误，提示我们使用 if_seq_no和 if_primary_term。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618847618574.png" alt="1618847618574"></p><p>参考链接：<a href="https://www.bilibili.com/video/BV1hh411D7sb?p=1">https://www.bilibili.com/video/BV1hh411D7sb?p=1</a></p>]]></content>
      
      
      <categories>
          
          <category> ElasticSearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
            <tag> NoSQL </tag>
            
            <tag> 搜索 </tag>
            
            <tag> 原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch基础篇</title>
      <link href="/blog/2021/04/14/ElasticSearch%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
      <url>/blog/2021/04/14/ElasticSearch%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="ElasticSearch基础篇"><a href="#ElasticSearch基础篇" class="headerlink" title="ElasticSearch基础篇"></a>ElasticSearch基础篇</h1><h1 id="一、入门介绍"><a href="#一、入门介绍" class="headerlink" title="一、入门介绍"></a>一、入门介绍</h1><p>&emsp;&emsp;Lucene是一套信息检索工具包，是一个<font color='red'>jar包</font>，不包含搜索引擎系统！它包含：索引结构、读写索引的工具、排序，搜索规则。。。工具类！<br>Lucene和ElasticSearch关系：<br>&emsp;&emsp;ElasticSearch是基于Lucene做了一些封装和增强（上手十分简单！）</p><h2 id="1、ElasticSearch概述"><a href="#1、ElasticSearch概述" class="headerlink" title="1、ElasticSearch概述"></a>1、ElasticSearch概述</h2><p>&emsp;&emsp;Elaticsearch，简称为ES， ES是一个开源的高扩展的分布式全文检索引擎，它可以近乎实时的存储、检索数据；本身扩展性很好，可以扩展到上百台服务器，处理PB级别的数据。ES也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。<br>&emsp;&emsp;据国际权威的数据库产品评测机构DB Engines的统计，在2016年1月，ElasticSearch已超过Solr等，成为排名第一的搜索引擎类应用。</p><h2 id="2、历史"><a href="#2、历史" class="headerlink" title="2、历史"></a>2、历史</h2><p>&emsp;&emsp;多年前，一个叫做Shay Banon的刚结婚不久的失业开发者，由于妻子要去伦敦学习厨师，他便跟着也去了。在他找工作的过程中，为了给妻子构建一个食谱的搜索引擎，他开始构建一个早期版本的Lucene。<br>&emsp;&emsp;直接基于Lucene工作会比较困难，所以Shay开始抽象Lucene代码以便Java程序员可以在应用中添加搜索功能。他发布了他的第一个开源项目，叫做“Compass”。<br>&emsp;&emsp;后来Shay找到一份工作，这份工作处在高性能和内存数据网格的分布式环境中，因此高性能的、实时的、分布式的搜索引擎也是理所当然需要的。然后他决定重写Compass库使其成为一个独立的服务叫做Elasticsearch。<br>&emsp;&emsp;第一个公开版本出现在2010年2月，在那之后Elasticsearch已经成为Github上最受欢迎的项目之一，代码贡献者超过300人。一家主营Elasticsearch的公司就此成立，他们一边提供商业支持一边开发新功能，不过Elasticsearch将永远开源且对所有人可用。<br>Shay的妻子依旧等待着她的食谱搜索……</p><h2 id="3、谁在使用ES"><a href="#3、谁在使用ES" class="headerlink" title="3、谁在使用ES"></a>3、谁在使用ES</h2><p>1、维基百科，类似百度百科，全文检索，高亮，搜索推荐</p><p>2、The Guardian（国外新闻网站），类似搜狐新闻，用户行为日志（点击，浏览，收藏，评论）+社交网络数据（对某某新闻的相关看法），数据分析，给到每篇新闻文章的作者，让他知道他的文章的公众反馈（好，坏，热门，垃圾，鄙视，崇拜）</p><p>3、Stack Overflow（国外的程序异常讨论论坛），IT问题，程序的报错，提交上去，有人会跟你讨论和回答，全文检索，搜索相关问题和答案，程序报错了，就会将报错信息粘贴到里面去，搜索有没有对应的答案</p><p>4、GitHub（开源代码管理），搜索上千亿行代码</p><p>5、电商网站，检索商品</p><p>6、日志数据分析，logstash采集日志，ES进行复杂的数据分析，ELK技术，elasticsearch+logstash+kibana</p><p>7、商品价格监控网站，用户设定某商品的价格阈值，当低于该阈值的时候，发送通知消息给用户，比如说订阅牙膏的监控，如果高露洁牙膏的家庭套装低于50块钱，就通知我，我就去买</p><p>8、BI系统，商业智能，Business Intelligence。比如说有个大型商场集团，BI，分析一下某某区域最近3年的用户消费金额的趋势以及用户群体的组成构成，产出相关的数张报表，**区，最近3年，每年消费金额呈现100%的增长，而且用户群体85%是高级白领，开一个新商场。ES执行数据分析和挖掘，Kibana进行数据可视化</p><p>9、国内：站内搜索（电商，招聘，门户，等等），IT系统搜索（OA，CRM，ERP，等等），数据分析（ES热门的一个使用场景）</p><h1 id="二、ES和solr的差别"><a href="#二、ES和solr的差别" class="headerlink" title="二、ES和solr的差别"></a>二、ES和solr的差别</h1><h2 id="1、Elasticsearch简介"><a href="#1、Elasticsearch简介" class="headerlink" title="1、Elasticsearch简介"></a>1、Elasticsearch简介</h2><p>&emsp;&emsp;Elasticsearch是一个实时分布式搜索和分析引擎。它让你以前所未有的速度处理大数据成为可能。它用于<font color='red'>全文搜索、结构化搜索、分析以及将这三者混合使用</font>：</p><p>&emsp;&emsp;维基百科使用Elasticsearch提供全文搜索并高亮关键字，以及输入实时搜索(search-asyou-type)和搜索纠错(did-you-mean)等搜索建议功能。</p><p>&emsp;&emsp;英国卫报使用Elasticsearch结合用户日志和社交网络数据提供给他们的编辑以实时的反馈，以便及时了解公众对新发表的文章的回应。</p><p>&emsp;&emsp;StackOverflow结合全文搜索与地理位置查询，以及more-like-this功能来找到相关的问题和答案。</p><p>&emsp;&emsp;Github使用Elasticsearch检索1300亿行的代码。</p><p>&emsp;&emsp;但是Elasticsearch不仅用于大型企业，它还让像DataDog以及Klout这样的创业公司将最初的想法变成可扩展的解决方案。Elasticsearch可以在你的笔记本上运行，也可以在数以百计的服务器上处理PB级别的数据 。</p><p>&emsp;&emsp;Elasticsearch是一个基于Apache Lucene™的开源搜索引擎。无论在开源还是专有领域，Lucene可以被认为是迄今为止最先进、性能最好的、功能最全的搜索引擎库。</p><p>&emsp;&emsp;但是，Lucene只是一个库。想要使用它，你必须使用Java来作为开发语言并将其直接集成到你的应用中，更糟糕的是，Lucene非常复杂，你需要深入了解检索的相关知识来理解它是如何工作的。</p><p>&emsp;&emsp;Elasticsearch也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的<strong>RESTful API</strong>  来隐藏Lucene的复杂性，从而让全文搜索变得简单。</p><h2 id="2、Solr简介"><a href="#2、Solr简介" class="headerlink" title="2、Solr简介"></a>2、Solr简介</h2><p>&emsp;&emsp;Solr 是Apache下的一个顶级开源项目，采用Java开发，它是基于Lucene的全文搜索服务器。Solr提供了比Lucene更为丰富的查询语言，同时实现了可配置、可扩展，并对索引、搜索性能进行了优化。</p><p>&emsp;&emsp;Solr可以独立运行，运行在Jetty、Tomcat等这些Servlet容器中，Solr 索引的实现方法很简单，<strong>用 POST方法向 Solr 服务器发送一个描述 Field 及其内容的 XML 文档，Solr根据xml文档添加、删除、更新索引</strong>。Solr 搜索只需要发送 HTTP GET 请求，然后对 Solr 返回Xml、json等格式的查询结果进行解析，组织页面布局。Solr不提供构建UI的功能，Solr提供了一个管理界面，通过管理界面可以查询Solr的配置和运行情况。</p><p>&emsp;&emsp;solr是基于lucene开发企业级搜索服务器，实际上就是封装了lucene。</p><p>&emsp;&emsp;Solr是一个独立的企业级搜索应用服务器，它对外提供类似于<strong>Web-service</strong>的API接口。用户可以通过http请求，向搜索引擎服务器提交一定格式的文件，生成索引；也可以通过提出查找请求，并得到返回结果。</p><h2 id="3、Lucene简介"><a href="#3、Lucene简介" class="headerlink" title="3、Lucene简介"></a>3、Lucene简介</h2><p>&emsp;&emsp;Lucene是apache软件基金会4 jakarta项目组的一个子项目，是一个开放源代码的全文检索引擎工具包，但它不是一个完整的全文检索引擎，而是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎，部分文本分析引擎（英文与德文两种西方语言）。Lucene的目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能，或者是以此为基础建立起完整的全文检索引擎。Lucene是一套用于全文检索和搜寻的开源程式库，由Apache软件基金会支持和提供。Lucene提供了一个简单却强大的应用程式接口，能够做全文索引和搜寻。在Java开发环境里Lucene是一个成熟的免费开源工具。就其本身而言，Lucene是当前以及最近几年最受欢迎的免费Java信息检索程序库。人们经常提到信息检索程序库，虽然与搜索引擎有关，但不应该将信息检索程序库与搜索引擎相混淆。</p><p>&emsp;&emsp;Lucene是一个全文检索引擎的架构。那什么是全文搜索引擎？</p><p>&emsp;&emsp;全文搜索引擎是名副其实的搜索引擎，国外具代表性的有Google、Fast/AllTheWeb、AltaVista、Inktomi、Teoma、WiseNut等，国内著名的有百度（Baidu）。它们都是通过从互联网上提取的各个网站的信息（以网页文字为主）而建立的数据库中，检索与用户查询条件匹配的相关记录，然后按一定的排列顺序将结果返回给用户，因此他们是真正的搜索引擎。</p><p>&emsp;&emsp;从搜索结果来源的角度，全文搜索引擎又可细分为两种，一种是拥有自己的检索程序（Indexer），俗称“蜘蛛”（Spider）程序或“机器人”（Robot）程序，并自建网页数据库，搜索结果直接从自身的数据库中调用，如上面提到的7家引擎；另一种则是租用其他引擎的数据库，并按自定的格式排列搜索结果，如Lycos引擎。</p><h2 id="4、ElasticSearch和solr比较"><a href="#4、ElasticSearch和solr比较" class="headerlink" title="4、ElasticSearch和solr比较"></a>4、ElasticSearch和solr比较</h2><p><img src="http://cheng_qiwei.gitee.io/blog/img/354604-20180122010705803-1082290454.png"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/354604-20180122010730865-1548826450.png" alt="354604-20180122010730865-1548826450"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/354604-20180122010754100-1951694800.png" alt="354604-20180122010754100-1951694800"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/354604-20180122011131225-347761833.png"></p><h1 id="三、ElasticSearch安装"><a href="#三、ElasticSearch安装" class="headerlink" title="三、ElasticSearch安装"></a>三、ElasticSearch安装</h1><p>&emsp;&emsp;声明：由于ElasticSearch使用Java开发，所以需要Java开发环境，其对JDK的版本最低要求是：JDK1.8！同时，由于要使用ElasticSearch客户端，界面工具，所以还需要nodejs的环境！</p><h2 id="1、下载资源【基于21-04-07】"><a href="#1、下载资源【基于21-04-07】" class="headerlink" title="1、下载资源【基于21-04-07】"></a>1、下载资源【基于21-04-07】</h2><h3 id="1-1、官方环境"><a href="#1-1、官方环境" class="headerlink" title="1.1、官方环境"></a>1.1、官方环境</h3><p>ElasticSearch[目前最新7.12.0]：<a href="https://www.elastic.co/cn/downloads/elasticsearch">https://www.elastic.co/cn/downloads/elasticsearch</a></p><p>logstash[目前最新7.12.0]：<a href="https://www.elastic.co/cn/downloads/logstash">https://www.elastic.co/cn/downloads/logstash</a></p><p>kibana[目前最新7.12.0]：<a href="https://www.elastic.co/cn/downloads/kibana">https://www.elastic.co/cn/downloads/kibana</a></p><p>ik分词器[目前最新7.12.0]：<a href="https://github.com/medcl/elasticsearch-analysis-ik/releases">https://github.com/medcl/elasticsearch-analysis-ik/releases</a></p><p>elasticsearch-head-master下载[目前最新5.0.0]：<a href="https://github.com/mobz/elasticsearch-head/releases/tag/v5.0.0">https://github.com/mobz/elasticsearch-head/releases/tag/v5.0.0</a></p><h3 id="1-2、华为云的镜像去下载"><a href="#1-2、华为云的镜像去下载" class="headerlink" title="1.2、华为云的镜像去下载"></a>1.2、华为云的镜像去下载</h3><p>速度很快，自己找对应版本就可以<br>ElasticSearch[目前最新7.9.3]： <a href="https://mirrors.huaweicloud.com/elasticsearch/?C=N&amp;O=D">https://mirrors.huaweicloud.com/elasticsearch/?C=N&amp;O=D</a></p><p>logstash[目前最新7.9.3]： <a href="https://mirrors.huaweicloud.com/logstash/?C=N&amp;O=D">https://mirrors.huaweicloud.com/logstash/?C=N&amp;O=D</a></p><p>kibana[目前最新7.9.3]： <a href="https://mirrors.huaweicloud.com/kibana/?C=N&amp;O=D">https://mirrors.huaweicloud.com/kibana/?C=N&amp;O=D</a></p><h2 id="2、window环境安装ElasticSearch"><a href="#2、window环境安装ElasticSearch" class="headerlink" title="2、window环境安装ElasticSearch"></a>2、window环境安装ElasticSearch</h2><h3 id="2-1、安装ElasticSearch"><a href="#2-1、安装ElasticSearch" class="headerlink" title="2.1、安装ElasticSearch"></a>2.1、安装ElasticSearch</h3><p>&emsp;&emsp;解压安装包即可</p><h3 id="2-2、熟悉目录"><a href="#2-2、熟悉目录" class="headerlink" title="2.2、熟悉目录"></a>2.2、熟悉目录</h3><p>bin：启动文件(.bat)<br>config：配置文件<br>​    log4j2.properties：日志配置文件<br>​    jvm.options：java虚拟机的配置<br>​    elasticsearch.yml：ES的配置文件 端口9200 ！跨域问题<br>data：索引数据目录<br>lib：相关Jar包<br>logs：日志<br>modules：功能模块<br>plugins：插件</p><p>jvm的配置调整一下，需要更改虚拟机配置改为256M</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210407155353343.png" alt="image-20210407155353343"></p><p>调整ElasticSearch.yml文件，添加以下内容，解决跨域问题</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">http.cors.enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">http.cors.allow-origin:</span> <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure><h3 id="2-3、启动"><a href="#2-3、启动" class="headerlink" title="2.3、启动"></a>2.3、启动</h3><p>&emsp;&emsp;双击ElasticSearch下的bin目录中的elasticsearch.bat启动，控制台显示的日志（等待启动完<br>毕！）：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210407173536506.png" alt="image-20210407173536506"></p><h3 id="2-4、访问测试"><a href="#2-4、访问测试" class="headerlink" title="2.4、访问测试"></a>2.4、访问测试</h3><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210407173520663.png" alt="image-20210407173520663"></p><h2 id="3、windows环境安装可视化界面ES-head"><a href="#3、windows环境安装可视化界面ES-head" class="headerlink" title="3、windows环境安装可视化界面ES head"></a>3、windows环境安装可视化界面ES head</h2><p>&emsp;&emsp;Head是elasticsearch的集群管理工具，可以用于数据的浏览查询。</p><h3 id="3-1、安装head"><a href="#3-1、安装head" class="headerlink" title="3.1、安装head"></a>3.1、安装head</h3><h4 id="3-1-1、解压安装包即可"><a href="#3-1-1、解压安装包即可" class="headerlink" title="3.1.1、解压安装包即可"></a>3.1.1、解压安装包即可</h4><h4 id="3-1-2、解压之后安装依赖并启动，访问端口9100"><a href="#3-1-2、解压之后安装依赖并启动，访问端口9100" class="headerlink" title="3.1.2、解压之后安装依赖并启动，访问端口9100"></a>3.1.2、解压之后安装依赖并启动，访问端口9100</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cnpm install</span><br><span class="line">npm run start</span><br></pre></td></tr></table></figure><p><font color='red'>&emsp;&emsp;注：由于ES进程和客户端进程端口号不同，存在跨域问题，所以我们要在ES的配置文件中配置下跨域问题</font></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210408100717533.png" alt="image-20210408100717533"></p><p>初学就把ES当做一个数据库！可以建立索引（库），文档（库中的数据）</p><p>head就当做一个数据展示工具！后面所有的查询用Kibana！</p><h2 id="4、了解ELK"><a href="#4、了解ELK" class="headerlink" title="4、了解ELK"></a>4、了解ELK</h2><p>&emsp;&emsp;ELK是Elasticsearch、Logstash、Kibana三大开源框架首字母大写简称。市面上也被成为Elastic Stack。其中Elasticsearch是一个基于Lucene、分布式、通过Restful方式进行交互的近实时搜索平台框架。像类似百度、谷歌这种大数据全文搜索引擎的场景都可以使用Elasticsearch作为底层支持框架，可见Elasticsearch提供的搜索能力确实强大,市面上很多时候我们简称Elasticsearch为ES。Logstash是ELK的中央数据流引擎，用于从不同目标（文件/数据存储/MQ）收集的不同格式数据，经过过滤后支持输出到不同目的地（文件/MQ/redis/elasticsearch/kafka等）。Kibana可以将elasticsearch的数据通过友好的页面展示出来，提供实时分析的功能。</p><p>&emsp;&emsp;市面上很多开发只要提到ELK能够一致说出它是一个日志分析架构技术栈总称，但实际上ELK不仅仅适用于**<font color='red'>日志分析，它还可以支持其它任何数据分析和收集的场景，日志分析和收集只是更具有代表性。并非唯一性。</font>**</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210408102825233.png" alt="image-20210408102825233"></p><h2 id="5、windows环境安装Kibana"><a href="#5、windows环境安装Kibana" class="headerlink" title="5、windows环境安装Kibana"></a>5、windows环境安装Kibana</h2><p>&emsp;&emsp;Kibana是一个针对Elasticsearch的开源分析及可视化平台，用来搜索、查看交互存储在Elasticsearch索引中的数据。使用Kibana，可以通过各种图表进行高级数据分析及展示。Kibana让海量数据更容易理解。它操作简单，基于浏览器的用户界面可以快速创建仪表板（dashboard）实时显示Elasticsearch查询动态。设置Kibana非常简单。无需编码或者额外的基础架构，几分钟内就可以完成Kibana安装并启动Elasticsearch索引监测。</p><h3 id="5-1、安装Kibana"><a href="#5-1、安装Kibana" class="headerlink" title="5.1、安装Kibana"></a>5.1、安装Kibana</h3><p>5.1.1、将压缩包解压即可（需要一些时间），是一个标准的工程<br>5.1.2、然后进入到bin目录下，启动服务就可以了（需要等待启动完成），ELK基本上都是拆箱即用的</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210408102253163.png" alt="image-20210408102253163"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210408102401994.png" alt="image-20210408102401994"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210408102414725.png" alt="image-20210408102414725"></p><h3 id="5-2、语言配置"><a href="#5-2、语言配置" class="headerlink" title="5.2、语言配置"></a>5.2、语言配置</h3><p>&emsp;&emsp;Kibana支持中文，中文包位置：kibana\x-pack\plugins\translations\ translations\zh-CN.json，只需要在配置文件 kibana.yml 中加入如下内容并重启Kibana即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i18n.locale: &quot;zh-CN&quot;</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210408103349839.png" alt="image-20210408103349839"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210408103659934.png" alt="image-20210408103659934"></p><h1 id="四、ES核心概念"><a href="#四、ES核心概念" class="headerlink" title="四、ES核心概念"></a>四、ES核心概念</h1><h2 id="1、ElasticSearch与传统关系型数据库的比较"><a href="#1、ElasticSearch与传统关系型数据库的比较" class="headerlink" title="1、ElasticSearch与传统关系型数据库的比较"></a>1、ElasticSearch与传统关系型数据库的比较</h2><p>&emsp;&emsp;在前面的学习中，我们已经掌握了es是什么，同时也把es的服务已经安装启动，那么es是如何去存储数据，数据结构是什么，又是如何实现搜索的呢？我们先来聊聊ElasticSearch的相关概念吧！</p><p>问题：集群，节点，索引，类型，文档，分片，映射是什么？</p><h2 id="2、索引（index）"><a href="#2、索引（index）" class="headerlink" title="2、索引（index）"></a>2、索引（index）</h2><p>&emsp;&emsp;索引是ES的一个逻辑存储，对应关系型数据库中的数据库，ES可以把索引数据存放到服务器中，也可以sharding(分片)后存储到多台服务器上。每个索引有一个或多个分片，每个分片可以有多个副本。</p><p>&emsp;&emsp;一个ElasticSearch可以就是一个集群，默认的集群名称就是elasticsearch。一个集群至少有一个节点，而一个节点就是一个elasricsearch进程，节点可以有多个索引默认的，如果你创建索引，那么索引将会有个5个分片 ( primary shard ,又称主分片 ) 构成的，<font color='red'>每份分片是一个Lucene的索引</font>，每一个主分片会有一个副本 ( replica shard ,又称复制分片 )。</p><p>&emsp;&emsp;在一个多节点的ElasticSearch集群中，<font color='red'>主分片和对应的复制分片都不会在同一个节点内，这样有利于某个节点挂掉 了，数据也不至于丢失</font>。 实际上，一个分片是一个Lucene索引，一个包含倒排索引的文件目录，倒排索引的结构使 得elasticsearch在不扫描全部文档的情况下，就能告诉你哪些文档包含特定的关键字。</p><h3 id="2-1、分片（shard）"><a href="#2-1、分片（shard）" class="headerlink" title="2.1、分片（shard）"></a><font color='red'>2.1、分片（shard）</font></h3><p>&emsp;&emsp;如果我们的索引数据量很大，超过硬件存放单个文件的限制，就会影响查询请求的速度，ES引入了分片技术。一个分片本身就是一个完整的搜索引擎，文档存储在分片中，而分片会被分配到集群中的各个节点中，随着集群的扩大和缩小，ES会自动的将分片在节点之间进行迁移，以保证集群能保持一种平衡。分片有以下特点：</p><ol><li>ES的一个索引可以包含多个分片（shard）；</li><li>每一个分片（shard）都是一个最小的工作单元，承载部分数据；</li><li>每个shard都是一个lucene实例，有完整的建立索引和处理请求的能力；</li><li>增减节点时，shard会自动在nodes中负载均衡；</li><li>一个文档只能完整的存放在一个shard上（主节点）</li><li>一个索引中含有shard的数量，默认值为5，在索引创建后这个值是不能被更改的。</li><li>优点：水平分割和扩展我们存放的内容索引；分发和并行跨碎片操作提高性能/吞吐量；</li><li>每一个shard关联的副本分片（replica shard）的数量，默认值为1，这个设置在任何时候都可以修改。</li><li>Pshard（主分片）和对应的Rshard（副本）<strong>不能同时存在于同一个节点</strong>，所以最低的可用配置是两个节点，互为主备。</li><li>primary shard【主分片】是可读可写的，而replica shard【分片副本】是只读的。</li></ol><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">分片的好处：</span><br><span class="line">1.当某一台服务器宕机，可以保证其他数据的完整性（非最优方案）</span><br><span class="line">2.横向扩容：当数据量增大时，只需要添加一个新的结点，然后创建新的索引，操作非常简单</span><br><span class="line">3.看似占用了更多的服务器资源，实际上replica shard带来了性能和集群吞吐量的提升，这点和横向扩容是相同的。</span><br><span class="line">不同的是，横向扩容是可以承载更多的数据，而replica shard是单纯的增加数据的副本，带来的是性能和高可用。</span><br></pre></td></tr></table></figure><p><font color='red'>&emsp;&emsp;被混淆的概念是，一个 Lucene 索引 我们在 Elasticsearch 称作 分片 。 一个 Elasticsearch 索引 是分片的集合。 当 Elasticsearch 在索引中搜索的时候， 他发送查询到每一个属于索引的分片(Lucene 索引)，然后合并每个分片的结果到一个全局的结果集。</font></p><h3 id="2-2、副本（replica）"><a href="#2-2、副本（replica）" class="headerlink" title="2.2、副本（replica）"></a>2.2、副本（replica）</h3><p>副本（replica shard）就是shard的冗余备份，它的主要作用：</p><ol><li>冗余备份，防止数据丢失；</li><li>shard异常时负责容错和负载均衡；</li></ol><h2 id="3、类型（type）"><a href="#3、类型（type）" class="headerlink" title="3、类型（type）"></a>3、类型（type）</h2><p>&emsp;&emsp;ES中，一个索引可以存储多个用于不同用途的对象，可以通过类型来区分索引中的不同对象，对应关系型数据库中表的概念。类型在各个版本的elasticsearch中的变化如下图：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618651424501.png" alt="1618651424501"></p><p>&emsp;&emsp;我们都知道elasticsearch是基于Lucene开发的搜索引擎，而ES中不同type下名称相同的filed最终在Lucene中的处理方式是一样的。举个例子，两个不同type下的两个user_name，在ES同一个索引下其实被认为是同一个filed，你必须在两个不同的type中定义相同的filed映射。否则，不同type中的相同字段名称就会在处理中出现冲突的情况，导致Lucene处理效率下降。</p><p>&emsp;&emsp;去掉type能够使数据存储在独立的index中，这样即使有相同的字段名称也不会出现冲突，就像ElasticSearch出现的第一句话一样“你知道的，为了搜索····”，去掉type就是为了提高ES处理数据的效率。</p><p>&emsp;&emsp;除此之外，在同一个索引的不同type下存储字段数不一样的实体会导致存储中出现稀疏数据，影响Lucene压缩文档的能力，导致ES查询效率的降低。</p><h2 id="4、文档（document）"><a href="#4、文档（document）" class="headerlink" title="4、文档（document）"></a>4、文档（document）</h2><p>&emsp;&emsp;存储在ES中的主要实体叫文档，可以理解为关系型数据库中表的一行数据记录。每个文档由多个<strong>字段（field）</strong>组成。区别于关系型数据库的是，ES是一个非结构化的数据库，每个文档可以有不同的字段，并且有一个唯一标识。</p><p>&emsp;&emsp;ElasticSearch是面向文档的，那么就意味着索引和搜索数据的最小单位是文档，在ElasticSearch中，文档有几个 重要属性 :</p><ul><li><p>自我包含，一篇文档同时包含字段和对应的值，也就是同时包含 key:value</p></li><li><p>可以是层次型的，一个文档中包含自文档，复杂的逻辑实体就是这么来的！{就是一个JSON对象}</p></li><li><p>灵活的结构，文档不依赖预先定义的模式，我们知道关系型数据库中，要提前定义字段才能使用，在elasticsearch中，对于字段是非常灵活的，有时候，我们可以忽略该字段，或者动态的添加一个新的字段。</p></li></ul><p>&emsp;&emsp;尽管我们可以随意的新增或者忽略某个字段，但是，每个字段的类型非常重要，比如一个年龄字段类型，可以是字符 串也可以是整形。因为elasticsearch会保存字段和类型之间的映射及其他的设置。这种映射具体到每个映射的每种类型，这也是为什么在elasticsearch中，类型有时候也称为映射类型。</p><h2 id="5、映射（mapping）"><a href="#5、映射（mapping）" class="headerlink" title="5、映射（mapping）"></a>5、映射（mapping）</h2><p>&emsp;&emsp;mapping是处理数据的方式和规则方面做一些限制，如：某个字段的数据类型、默认值、分析器、是否被索引等等。这些都是映射里面可以设置的，其它就是处理ES里面数据的一些使用规则设置也叫做映射，按着最优规则处理数据对性能提高很大，因此才需要建立映射，并且需要思考如何建立映射才能对性能更好。</p><h1 id="五、IK分词器"><a href="#五、IK分词器" class="headerlink" title="五、IK分词器"></a>五、IK分词器</h1><h2 id="1、什么是分词器？什么是IK分词器？"><a href="#1、什么是分词器？什么是IK分词器？" class="headerlink" title="1、什么是分词器？什么是IK分词器？"></a>1、什么是分词器？什么是IK分词器？</h2><p>&emsp;&emsp;分词器，是将用户输入的一段文本，分析成符合逻辑的一种工具。而IK分词器，则是把一段中文划分成一个个的关键字，我们在搜索时候会把自己的信息进行分词，会把数据库中或者索引库中的数据进行分词，然后进行一个匹配操作。ElasticSearch默认的分词是将每个字看成一个词，比如 “我是程序员” 会被分为”我”,“是”,“程”,“序”,“员”，这显然是不符合要求的，所以我们需要安装使用IK中文分词器来解决这个问题。<br>&emsp;&emsp;IK提供了两个分词算法：ik_smart 和 ik_max_word，其中 ik_smart 为最少切分，ik_max_word为最细粒度划分。</p><h2 id="2、ElasticSearch安装IK分词器"><a href="#2、ElasticSearch安装IK分词器" class="headerlink" title="2、ElasticSearch安装IK分词器"></a>2、ElasticSearch安装IK分词器</h2><p>2.1、下载后解压，并将目录拷贝到ElasticSearch根目录下的 plugins 目录中</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210408153808172.png" alt="image-20210408153808172"></p><p>2.2、重新启动 ElasticSearch 服务，在启动过程中，你可以看到正在加载”analysis-ik”插件的提示信息，服务启动后，可以在命令行运行 elasticsearch-plugin list 命令，确认IK 插件安装成功。（ plugins 文件中不要放压缩包，否则会运行闪退！！）</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210408154000428.png" alt="image-20210408154000428"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210408154054397.png" alt="image-20210408154054397"></p><p>2.3、在 kibana 中测试 IK分词器，并就相关分词结果和 icu 分词器进行对比。<br>IK提供了两个分词算法：ik_smart 和 ik_max_word。</p><p>ik_smart ：最少切分</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210408160321714.png" alt="image-20210408160321714"></p><p>ik_max_word： 最细粒度分词</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210408160345465.png" alt="image-20210408160345465"></p><h2 id="3、IK分词器自定义词库"><a href="#3、IK分词器自定义词库" class="headerlink" title="3、IK分词器自定义词库"></a>3、IK分词器自定义词库</h2><p>这里先说一下IK分词器中的词库文件的意思：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IKAnalyzer.cfg.xml：IK分词配置文件</span><br><span class="line">主词库：main.dic</span><br><span class="line">英文停用词：stopword.dic，不会建立在倒排索引中</span><br><span class="line">特殊词库：</span><br><span class="line">    quantifier.dic：特殊词库：计量单位等</span><br><span class="line">    suffix.dic：特殊词库：后缀名</span><br><span class="line">    surname.dic：特殊词库：百家姓</span><br><span class="line">    preposition：特殊词库：语气词</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;虽然IK分词器能够帮助我们给中文进行分词，但是，随着当前互联网环境，各种热词的出现，使用IK分词器并不能完全满足我们的需求，所以，此时就需要我们自定义词库。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210408162006057.png" alt="image-20210408162006057"></p><p>如图，如果我们想让系统识别“雨女无瓜”是一个词，需要编辑自定义词库。<br>自定义词库步骤：</p><h3 id="3-1、进入elasticsearch-plugins-ik-config目录"><a href="#3-1、进入elasticsearch-plugins-ik-config目录" class="headerlink" title="3.1、进入elasticsearch/plugins/ik/config目录"></a>3.1、进入elasticsearch/plugins/ik/config目录</h3><h3 id="3-2、新建一个owner-dic文件，编辑自定义内容"><a href="#3-2、新建一个owner-dic文件，编辑自定义内容" class="headerlink" title="3.2、新建一个owner.dic文件，编辑自定义内容"></a>3.2、新建一个owner.dic文件，编辑自定义内容</h3><p><font color='red'>注意查看创建的文件一定要是UTF-8编码，否则无效！</font></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210408162954456.png" alt="image-20210408162954456"></p><h3 id="3-3、修改IKAnalyzer-cfg-xml（在ik-config目录下）"><a href="#3-3、修改IKAnalyzer-cfg-xml（在ik-config目录下）" class="headerlink" title="3.3、修改IKAnalyzer.cfg.xml（在ik/config目录下）"></a>3.3、修改IKAnalyzer.cfg.xml（在ik/config目录下）</h3><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210408163107567.png" alt="image-20210408163107567"></p><h3 id="3-4、修改完配置重新启动elasticsearch和Kibana，再次测试"><a href="#3-4、修改完配置重新启动elasticsearch和Kibana，再次测试" class="headerlink" title="3.4、修改完配置重新启动elasticsearch和Kibana，再次测试"></a>3.4、修改完配置重新启动elasticsearch和Kibana，再次测试</h3><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210408163702063.png" alt="image-20210408163702063"></p><h3 id="3-5、再次测试，发现雨女无瓜变成了一个词"><a href="#3-5、再次测试，发现雨女无瓜变成了一个词" class="headerlink" title="3.5、再次测试，发现雨女无瓜变成了一个词"></a>3.5、再次测试，发现雨女无瓜变成了一个词</h3><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210408164619279.png" alt="image-20210408164619279"></p><h1 id="六、ElasticSearch基于Rest风格的操作"><a href="#六、ElasticSearch基于Rest风格的操作" class="headerlink" title="六、ElasticSearch基于Rest风格的操作"></a>六、ElasticSearch基于Rest风格的操作</h1><h2 id="1、Rest风格说明"><a href="#1、Rest风格说明" class="headerlink" title="1、Rest风格说明"></a>1、Rest风格说明</h2><p>&emsp;&emsp;Rest风格是一种软件架构风格，而不是标准，它只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p><p>操作命令：</p><table><thead><tr><th align="center">method</th><th align="center">url地址</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">PUT</td><td align="center">ip:9200/索引名称/类型名称/文档id</td><td align="center">创建文档（指定文档id）</td></tr><tr><td align="center">POST</td><td align="center">ip:9200/索引名称/类型名称</td><td align="center">创建文档（随机文档id）</td></tr><tr><td align="center">POST</td><td align="center">ip:9200/索引名称/类型名称/文档id/_update</td><td align="center">修改文档</td></tr><tr><td align="center">DELETE</td><td align="center">ip:9200/索引名称/类型名称/文档id</td><td align="center">删除文档</td></tr><tr><td align="center">GET</td><td align="center">ip:9200/索引名称/类型名称/文档id</td><td align="center">通过文档id查询文档</td></tr><tr><td align="center">POST</td><td align="center">ip:9200/索引名称/类型名称/_search</td><td align="center">查询所有数据</td></tr></tbody></table><p>拓展命令</p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>GET _cat/health</td><td>查看ElasticSearch的健康状态</td></tr><tr><td>GET _cat/indices?v</td><td>查看所有的索引信息</td></tr></tbody></table><h2 id="2、关于索引和文档的操作"><a href="#2、关于索引和文档的操作" class="headerlink" title="2、关于索引和文档的操作"></a>2、关于索引和文档的操作</h2><blockquote><p><strong>基础操作</strong></p></blockquote><h3 id="2-1、创建一个索引和文档，当索引存在时，仅创建文档"><a href="#2-1、创建一个索引和文档，当索引存在时，仅创建文档" class="headerlink" title="2.1、创建一个索引和文档，当索引存在时，仅创建文档"></a>2.1、创建一个索引和文档，当索引存在时，仅创建文档</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT test1/type1/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;:&quot;张三&quot;,</span><br><span class="line">  &quot;age&quot;:20,</span><br><span class="line">  &quot;date&quot;:&quot;2021-04-11&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618128008636.png" alt="1618128008636"></p><p>返回结果 （也是以REST ful 风格返回的 ）：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#! [types removal] Specifying types in document index requests is deprecated, use the typeless endpoints instead (/&#123;index&#125;/_doc/&#123;id&#125;, /&#123;index&#125;/_doc, or /&#123;index&#125;/_create/&#123;id&#125;).</span><br><span class="line"><span class="comment">// 警告信息：不支持在文档索引请求中指定类型，而是使用无类型的端点(/&#123;index&#125;/_doc/&#123;id&#125;， /&#123;index&#125;/_doc，或&#123;index&#125;/_create/&#123;id&#125;)。</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;test1&quot;</span>,<span class="comment">// 索引</span></span><br><span class="line">  <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;type1&quot;</span>,<span class="comment">// 类型</span></span><br><span class="line">  <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_version&quot;</span> : <span class="number">1</span>,<span class="comment">// 版本</span></span><br><span class="line">  <span class="attr">&quot;result&quot;</span> : <span class="string">&quot;created&quot;</span>,<span class="comment">// 操作类型</span></span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span> : &#123;<span class="comment">// 分片信息</span></span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;successful&quot;</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;failed&quot;</span> : <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;_seq_no&quot;</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;_primary_term&quot;</span> : <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>那么我们是否需要指定字段的类型呢？最好还是进行指定。</li></ul><table><thead><tr><th align="center">类型</th><th align="center">内容</th></tr></thead><tbody><tr><td align="center">字符串</td><td align="center">text、 keyword</td></tr><tr><td align="center">数值类型</td><td align="center">long, integer, short, byte, double, float, half_float, scaled_float</td></tr><tr><td align="center">日期类型</td><td align="center">date</td></tr><tr><td align="center">布尔类型</td><td align="center">boolean</td></tr><tr><td align="center">二进制类型</td><td align="center">binary</td></tr><tr><td align="center">…</td><td align="center">…</td></tr></tbody></table><h3 id="2-2、创建一个索引，并指定类型"><a href="#2-2、创建一个索引，并指定类型" class="headerlink" title="2.2、创建一个索引，并指定类型"></a>2.2、创建一个索引，并指定类型</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PUT test2</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;name&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;age&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;long&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;birthday&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;date&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618128978419.png" alt="1618128978419"></p><h3 id="2-3、查看索引-查看文档"><a href="#2-3、查看索引-查看文档" class="headerlink" title="2.3、查看索引/查看文档"></a>2.3、查看索引/查看文档</h3><h4 id="2-3-1、查看索引"><a href="#2-3-1、查看索引" class="headerlink" title="2.3.1、查看索引"></a>2.3.1、查看索引</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET test2</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618129163728.png" alt="1618129163728"><br>&emsp;&emsp;假设按照2.1，我们并没有为我们的字段设置类型，那么当我们插入数据时，ElasticSearch就会去猜我们的类型，然后默认给我配置字段类型。</p><ul><li>这里需要注意的一个点：在elastisearch5版本之前，一个索引下可以创建多个类型，但是在elastisearch5后，一个索引只能对应一个类型，而id相当于关系型数据库的主键id若果不指定就会默认生成一个20位的uuid，属性相当关系型数据库的column(列)。</li></ul><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618129965125.png" alt="1618129965125"></p><h4 id="2-3-2、查看文档"><a href="#2-3-2、查看文档" class="headerlink" title="2.3.2、查看文档"></a>2.3.2、查看文档</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET test1/type1/1</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618152483087.png" alt="1618152483087"></p><h3 id="2-4、修改文档"><a href="#2-4、修改文档" class="headerlink" title="2.4、修改文档"></a>2.4、修改文档</h3><blockquote><p>&emsp;&emsp;修改文档有两种方法进行修改，第一种如下图，使用和创建一样的命令 “<strong>PUT test1/type1/1</strong>”，但是这种方法需要我们把所有的字段都填充好，然后只修改我们需要修改的字段即可，如果漏掉不修改的字段的话，则会把其他文档删除。所以并不是建议使用这种方法进行修改操作。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PUT test1/type1/1/_update</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;:&quot;王五&quot; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618130388644.png" alt="1618130388644"></p><blockquote><p>&emsp;&emsp;另一个修改的方法是使用 “<strong>post test1/type1/1/_update</strong>” 来进行修改，该方法可以值修改目标字段，而不会影响其他不需要修改的字段。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">post test1/type1/1/_update</span><br><span class="line">&#123;</span><br><span class="line">  &quot;doc&quot;:&#123;</span><br><span class="line">    &quot;name&quot;:&quot;王五&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618139591034.png" alt="1618139591034"></p><h3 id="2-5、删除索引-删除文档"><a href="#2-5、删除索引-删除文档" class="headerlink" title="2.5、删除索引/删除文档"></a>2.5、删除索引/删除文档</h3><h4 id="2-5-1、删除文档"><a href="#2-5-1、删除文档" class="headerlink" title="2.5.1、删除文档"></a>2.5.1、删除文档</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE test1/type1/1</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618151944650.png" alt="1618151944650"></p><p> <img src="http://cheng_qiwei.gitee.io/blog/img/1618151983146.png" alt="1618151983146"></p><h4 id="2-5-2、删除索引"><a href="#2-5-2、删除索引" class="headerlink" title="2.5.2、删除索引"></a>2.5.2、删除索引</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE test1</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618152072436.png" alt="1618152072436"></p><blockquote><p>复杂搜索</p></blockquote><p>添加测试数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">PUT test1/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;:&quot;狂神说&quot;,</span><br><span class="line">  &quot;age&quot;:23,</span><br><span class="line">  &quot;desc&quot;:&quot;一顿操作猛如虎&quot;,</span><br><span class="line">  &quot;tags&quot;:[&quot;技术宅&quot;,&quot;暖那&quot;,&quot;指南&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT test1/_doc/2</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;:&quot;张珊&quot;,</span><br><span class="line">  &quot;age&quot;:3,</span><br><span class="line">  &quot;desc&quot;:&quot;格雷福斯&quot;,</span><br><span class="line">  &quot;tags&quot;:[&quot;路由&quot;,&quot;交友&quot;,&quot;指南&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT test1/_doc/3</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;:&quot;李四&quot;,</span><br><span class="line">  &quot;age&quot;:30,</span><br><span class="line">  &quot;desc&quot;:&quot;mmp，不知道怎么形容&quot;,</span><br><span class="line">  &quot;tags&quot;:[&quot;靓女&quot;,&quot;旅游&quot;,&quot;唱歌&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618153275904.png" alt="1618153275904"></p><h3 id="2-6、根据单条件查询"><a href="#2-6、根据单条件查询" class="headerlink" title="2.6、根据单条件查询"></a>2.6、根据单条件查询</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET test1/_search?q=name:狂神</span><br><span class="line">GET test1/_search?q=name:狂神说</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618154163657.png" alt="1618154163657"></p><p>&emsp;&emsp;我们发现，只要查询的目标字段包含我们的查询值，就能够被查询出来。</p><h3 id="2-7、多条件复杂查询"><a href="#2-7、多条件复杂查询" class="headerlink" title="2.7、多条件复杂查询"></a>2.7、多条件复杂查询</h3><p>添加数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PUT test1/_doc/4</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;:&quot;狂神说说说&quot;,</span><br><span class="line">  &quot;age&quot;:3,</span><br><span class="line">  &quot;desc&quot;:&quot;程序员~~~&quot;,</span><br><span class="line">  &quot;tags&quot;:[&quot;敲代码&quot;,&quot;码代码&quot;,&quot;删库跑路&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-7-1、指定输出内容"><a href="#2-7-1、指定输出内容" class="headerlink" title="2.7.1、指定输出内容"></a>2.7.1、指定输出内容</h3><p>&emsp;&emsp;有时候，我们并不需要输出文档中所有的内容，可能只需要输出某些字段就可以了。相当于sql中：SELECT name，age from ……</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET test1/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;狂神&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  , &quot;_source&quot;: [&quot;name&quot;,&quot;desc&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618156586615.png" alt="1618156586615"></p><p>&emsp;&emsp;这里我们会发现在结果中会有一项<code>_score</code>，这一项的作用是分数，用来判定结果应该怎么排序，分数越高说明越符合结果。</p><h3 id="2-7-2、对结果根据指定内容进行排序"><a href="#2-7-2、对结果根据指定内容进行排序" class="headerlink" title="2.7.2、对结果根据指定内容进行排序"></a>2.7.2、对结果根据指定内容进行排序</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GET test1/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;狂神&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  , &quot;sort&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;age&quot;: &#123;</span><br><span class="line">        &quot;order&quot;: &quot;asc&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210412172751973.png" alt="image-20210412172751973"></p><p>&emsp;注意:在排序的过程中，只能使用可排序的属性进行排序。可以排序的属性有：<font color='red'>数字、日期、ID</font>，其他字段都不允许使用排序。在排序后，由于不需要使用<code>_score</code>发挥排序功能，所以该值被赋予null。</p><h3 id="2-7-3、分页查询"><a href="#2-7-3、分页查询" class="headerlink" title="2.7.3、分页查询"></a>2.7.3、分页查询</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET test1/_search</span><br><span class="line">&#123;</span><br><span class="line">   &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;狂神&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;from&quot;: 1,</span><br><span class="line">  &quot;size&quot;: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618235374696.png" alt="1618235374696"></p><h3 id="2-7-4、布尔查询"><a href="#2-7-4、布尔查询" class="headerlink" title="2.7.4、布尔查询"></a>2.7.4、布尔查询</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">GET test1/_search</span><br><span class="line">&#123;</span><br><span class="line">   &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;match&quot;: &#123;</span><br><span class="line">            &quot;name&quot;: &quot;狂神&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;match&quot;: &#123;</span><br><span class="line">            &quot;age&quot;: 23</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618235830392.png" alt="1618235830392"></p><p>同类型的关键词还有：</p><table><thead><tr><th>关键词</th><th>作用</th></tr></thead><tbody><tr><td>must</td><td>必须符合，必须包含，相当于关系数据库的条件and</td></tr><tr><td>must_not</td><td>必须不符合，必须不包含，相当于关系数据库的not XXX and not XXX</td></tr><tr><td>should</td><td>应该符合、应该包含，相当于关系数据库的条件or</td></tr></tbody></table><h3 id="2-7-5、过滤器查询"><a href="#2-7-5、过滤器查询" class="headerlink" title="2.7.5、过滤器查询"></a>2.7.5、过滤器查询</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">GET test1/_search</span><br><span class="line">&#123;</span><br><span class="line">   &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;match&quot;: &#123;</span><br><span class="line">            &quot;name&quot;: &quot;狂神&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;filter&quot;: &#123;</span><br><span class="line">        &quot;range&quot;: &#123;</span><br><span class="line">          &quot;age&quot;: &#123;</span><br><span class="line">            &quot;gte&quot;: 5,</span><br><span class="line">            &quot;lte&quot;: 30</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618236985421.png" alt="1618236985421"></p><p>过滤器中同类型的关键词还有：</p><table><thead><tr><th>关键词</th><th>作用</th></tr></thead><tbody><tr><td>gte</td><td>大于等于</td></tr><tr><td>gt</td><td>大于</td></tr><tr><td>lte</td><td>小于等于</td></tr><tr><td>lt</td><td>小于</td></tr></tbody></table><h3 id="2-7-6、同一个字段多条件查询"><a href="#2-7-6、同一个字段多条件查询" class="headerlink" title="2.7.6、同一个字段多条件查询"></a>2.7.6、同一个字段多条件查询</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET test1/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;tags&quot;: &quot;南 技术宅&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  , &quot;_source&quot;: [&quot;name&quot;,&quot;tags&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618237486207.png" alt="1618237486207"></p><p>&emsp;&emsp;条件越符合，分数越高！</p><h3 id="2-7-7、精确查询"><a href="#2-7-7、精确查询" class="headerlink" title="2.7.7、精确查询"></a>2.7.7、精确查询</h3><p>&emsp;&emsp;关于精确查询，就需要说明一下分词，刚刚上面都是使用match关键词来进行查询，match在使用的时候会使用分词器进行解析，先解析文档，再通过文档进行查询，而如果需要进行精确查询，则应该使用关键词term。</p><p>&emsp;&emsp;另外，关于字符串的两个类型text和keyword，如果使用keyword作为字符串的类型时，系统会默认将其当成一个简单字符串而不会对其进行分词解析，如果使用text，则会进行解析，如下图：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618238101807.png" alt="1618238101807"></p><p>创建测试数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">PUT test3</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;name&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;keyword&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;desc&quot;:&#123;</span><br><span class="line">        &quot;type&quot;: &quot;text&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT test3/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;:&quot;狂神说Java&quot;,</span><br><span class="line">  &quot;desc&quot;:&quot;狂神说Java&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">POST test3/_doc/2</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;:&quot;狂神说前端&quot;,</span><br><span class="line">  &quot;desc&quot;:&quot;狂神说前端&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET test3/_search</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618240186908.png" alt="1618240186908"></p><p>&emsp;&emsp;如上图：如果是对name进行查询，由于name是keyword类型，不会进行分词，所以只查询<code>狂</code>没办法查出内容，而desc是text类型，在查询的时候会进行分词，故能查询到数据。</p><h3 id="2-7-8、高亮查询"><a href="#2-7-8、高亮查询" class="headerlink" title="2.7.8、高亮查询"></a>2.7.8、高亮查询</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET test1/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;狂神&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;highlight&quot;: &#123;</span><br><span class="line">    &quot;fields&quot;: &#123;</span><br><span class="line">      &quot;name&quot;:&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618240573753.png" alt="1618240573753"></p><p>&emsp;&emsp;<code>&lt;em&gt;</code>是ElasticSearch的默认高亮标签，如果需要自定义高亮标签，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GET test1/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;狂神&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;highlight&quot;: &#123;</span><br><span class="line">    &quot;fields&quot;: &#123;</span><br><span class="line">      &quot;name&quot;:&#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;pre_tags&quot;: &quot;&lt;p class=&#x27;key&#x27; style=&#x27;color:red&#x27;&gt;&quot;,</span><br><span class="line">    &quot;post_tags&quot;: &quot;&lt;/p&gt;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618240745932.png" alt="1618240745932"></p><h1 id="七、springboot集成ElasticSearch"><a href="#七、springboot集成ElasticSearch" class="headerlink" title="七、springboot集成ElasticSearch"></a>七、springboot集成ElasticSearch</h1><h2 id="1、创建测试工程"><a href="#1、创建测试工程" class="headerlink" title="1、创建测试工程"></a>1、创建测试工程</h2><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618241960363.png" alt="1618241960363"></p><h2 id="2、修改pom文件"><a href="#2、修改pom文件" class="headerlink" title="2、修改pom文件"></a>2、修改pom文件</h2><p>&emsp;&emsp;创建工程后，我们需要做一个修改，要不然没办法和当前版本【7.12.0】进行连接，我们当前的springboot的版本是2.3.7，已经算是一个比较高的版本，但是其兼容的ElasticSearch的版本只是7.6.2版本，没办法与我们最新的7.12.0版本进行兼容，所以需要修改其版本。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618243216191.png" alt="1618243216191"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">elasticsearch.version</span>&gt;</span>7.12.0<span class="tag">&lt;/<span class="name">elasticsearch.version</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618243784374.png" alt="1618243784374"></p><h2 id="3、编写RestHighLevelClient作为连接与操作es的对象"><a href="#3、编写RestHighLevelClient作为连接与操作es的对象" class="headerlink" title="3、编写RestHighLevelClient作为连接与操作es的对象"></a>3、编写RestHighLevelClient作为连接与操作es的对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.g4b.cheng.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.http.HttpHost;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.RestClient;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.RestHighLevelClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建esClient连接对象</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElasticSearchConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestHighLevelClient <span class="title">restHighLevelClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestHighLevelClient(RestClient.builder(<span class="keyword">new</span> HttpHost(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">9200</span>,<span class="string">&quot;http&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、关于索引的操作"><a href="#4、关于索引的操作" class="headerlink" title="4、关于索引的操作"></a>4、关于索引的操作</h2><h3 id="4-1、创建索引"><a href="#4-1、创建索引" class="headerlink" title="4.1、创建索引"></a>4.1、创建索引</h3><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618327422965.png" alt="1618327422965"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618327458353.png" alt="1618327458353"></p><h3 id="4-2、判断索引是否存在"><a href="#4-2、判断索引是否存在" class="headerlink" title="4.2、判断索引是否存在"></a>4.2、判断索引是否存在</h3><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618327882435.png" alt="1618327882435"></p><h3 id="4-3、删除索引"><a href="#4-3、删除索引" class="headerlink" title="4.3、删除索引"></a>4.3、删除索引</h3><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618327936525.png" alt="1618327936525"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618327960755.png" alt="18327960755"></p><h3 id="4-4、创建文档"><a href="#4-4、创建文档" class="headerlink" title="4.4、创建文档"></a>4.4、创建文档</h3><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618329606711.png" alt="1618329606711"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618329648338.png" alt="1618329648338"></p><h3 id="4-5、判断文档是否存在"><a href="#4-5、判断文档是否存在" class="headerlink" title="4.5、判断文档是否存在"></a>4.5、判断文档是否存在</h3><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618329950424.png" alt="1618329950424"></p><h3 id="4-6、查询文档信息"><a href="#4-6、查询文档信息" class="headerlink" title="4.6、查询文档信息"></a>4.6、查询文档信息</h3><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618330069068.png" alt="1618330069068"></p><h3 id="4-7、修改文档"><a href="#4-7、修改文档" class="headerlink" title="4.7、修改文档"></a>4.7、修改文档</h3><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618330309597.png" alt="1618330309597"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618330331727.png" alt="1618330331727"></p><h3 id="4-8、删除文档"><a href="#4-8、删除文档" class="headerlink" title="4.8、删除文档"></a>4.8、删除文档</h3><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618330487465.png" alt="1618330487465"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1618330503605.png" alt="1618330503605"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除文档记录</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testDeleteDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        DeleteRequest deleteRequest = <span class="keyword">new</span> DeleteRequest(<span class="string">&quot;zzy_index&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">        deleteRequest.timeout(<span class="string">&quot;1s&quot;</span>);</span><br><span class="line">        DeleteResponse deleteResponse = client.delete(deleteRequest, RequestOptions.DEFAULT);</span><br><span class="line">        System.out.println(deleteResponse.status());</span><br><span class="line">        System.out.println(deleteResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//特殊的，真是的项目一般都会批量插入数据！</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testBulkRequest</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BulkRequest bulkRequest = <span class="keyword">new</span> BulkRequest();</span><br><span class="line">        bulkRequest.timeout(<span class="string">&quot;10s&quot;</span>);</span><br><span class="line">        ArrayList&lt;User&gt; userList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        userList.add(<span class="keyword">new</span> User(<span class="string">&quot;zzy1&quot;</span>, <span class="number">3</span>));</span><br><span class="line">        userList.add(<span class="keyword">new</span> User(<span class="string">&quot;zzy2&quot;</span>, <span class="number">3</span>));</span><br><span class="line">        userList.add(<span class="keyword">new</span> User(<span class="string">&quot;zzy3&quot;</span>, <span class="number">3</span>));</span><br><span class="line">        userList.add(<span class="keyword">new</span> User(<span class="string">&quot;zhao1&quot;</span>, <span class="number">3</span>));</span><br><span class="line">        userList.add(<span class="keyword">new</span> User(<span class="string">&quot;zhao2&quot;</span>, <span class="number">3</span>));</span><br><span class="line">        userList.add(<span class="keyword">new</span> User(<span class="string">&quot;zhao3&quot;</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//批处理请求</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; userList.size(); i++) &#123;</span><br><span class="line">            <span class="comment">//批量更新和批量删除，就在这里修改对应的请求就可以了</span></span><br><span class="line">            bulkRequest.add(<span class="keyword">new</span> IndexRequest(<span class="string">&quot;zzy_index&quot;</span>)</span><br><span class="line">                    .id(<span class="string">&quot;&quot;</span> + (i + <span class="number">1</span>))<span class="comment">//不指定ID，会生成随机ID</span></span><br><span class="line">                    .source(JSON.toJSONString(userList.get(i)), XContentType.JSON));</span><br><span class="line">        &#125;</span><br><span class="line">        BulkResponse bulkResponse = client.bulk(bulkRequest, RequestOptions.DEFAULT);</span><br><span class="line">        System.out.println(bulkResponse.hasFailures());<span class="comment">//是否失败 返回false 表示成功</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询</span></span><br><span class="line">    <span class="comment">//SearchRequest 搜索请求</span></span><br><span class="line">    <span class="comment">//SearchSourceBuilder 条件构造</span></span><br><span class="line">    <span class="comment">//HighlightBuilder 构建高亮</span></span><br><span class="line">    <span class="comment">//TermQueryBuilder 精确查询</span></span><br><span class="line">    <span class="comment">//MatchAllQueryBuilder  匹配所有</span></span><br><span class="line">    <span class="comment">// xxxbulider  对应刚才看到的所有命令！</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testSearch</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SearchRequest searchRequest = <span class="keyword">new</span> SearchRequest(ESconst.ES_INDEX);</span><br><span class="line">        <span class="comment">//构建搜索条件</span></span><br><span class="line">        SearchSourceBuilder sourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查询条件 可以使用QueryBuilders工具来实现</span></span><br><span class="line">        <span class="comment">//QueryBuilders.termQuery() 精确匹配</span></span><br><span class="line">        <span class="comment">//QueryBuilders.matchAllQuery() 匹配所有</span></span><br><span class="line">        TermQueryBuilder termQueryBuilder = QueryBuilders.termQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;zhao1&quot;</span>);</span><br><span class="line">        <span class="comment">//MatchAllQueryBuilder matchAllQueryBuilder = QueryBuilders.matchAllQuery();</span></span><br><span class="line">        sourceBuilder.query(termQueryBuilder);</span><br><span class="line">        sourceBuilder.from();<span class="comment">//分页</span></span><br><span class="line">        sourceBuilder.size();</span><br><span class="line">        sourceBuilder.timeout(<span class="keyword">new</span> TimeValue(<span class="number">60</span>, TimeUnit.SECONDS));</span><br><span class="line"></span><br><span class="line">        searchRequest.source(sourceBuilder);</span><br><span class="line">        SearchResponse searchResponse = client.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line">        System.out.println(JSON.toJSONString(searchResponse.getHits()));</span><br><span class="line">        System.out.println(<span class="string">&quot;====================&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (SearchHit documentFields : searchResponse.getHits().getHits()) &#123;</span><br><span class="line">            System.out.println(documentFields.getSourceAsMap());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-11、批量插入数据"><a href="#4-11、批量插入数据" class="headerlink" title="4.11、批量插入数据"></a>4.11、批量插入数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 批量插入文档</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: cheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/4/14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testBulkDoc</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    BulkRequest request = <span class="keyword">new</span> BulkRequest(ES_INDEX);</span><br><span class="line">    request.timeout(TimeValue.timeValueSeconds(<span class="number">3</span>));</span><br><span class="line">    List&lt;User&gt; userList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Collections.addAll(userList ,<span class="keyword">new</span> User(<span class="string">&quot;小A&quot;</span>,<span class="number">10</span>,<span class="keyword">new</span> Date(<span class="number">1586849562</span>))</span><br><span class="line">            ,<span class="keyword">new</span> User(<span class="string">&quot;小B&quot;</span>,<span class="number">12</span>,<span class="keyword">new</span> Date(<span class="number">766308762</span>))</span><br><span class="line">            ,<span class="keyword">new</span> User(<span class="string">&quot;小C&quot;</span>,<span class="number">13</span>,<span class="keyword">new</span> Date(<span class="number">158449562</span>))</span><br><span class="line">            ,<span class="keyword">new</span> User(<span class="string">&quot;小D&quot;</span>,<span class="number">40</span>,<span class="keyword">new</span> Date(<span class="number">766306762</span>))</span><br><span class="line">            ,<span class="keyword">new</span> User(<span class="string">&quot;小E&quot;</span>,<span class="number">30</span>,<span class="keyword">new</span> Date(<span class="number">1586549562</span>))</span><br><span class="line">            ,<span class="keyword">new</span> User(<span class="string">&quot;小F&quot;</span>,<span class="number">32</span>,<span class="keyword">new</span> Date(<span class="number">1586849562</span>))</span><br><span class="line">            ,<span class="keyword">new</span> User(<span class="string">&quot;小G&quot;</span>,<span class="number">21</span>,<span class="keyword">new</span> Date(<span class="number">1586009562</span>)));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; userList.size(); i++) &#123;</span><br><span class="line">        request.add(<span class="keyword">new</span> IndexRequest().id(String.valueOf(i+<span class="number">1</span>))</span><br><span class="line">                .source(JSON.toJSONString(userList.get(i)),XContentType.JSON));</span><br><span class="line">    &#125;</span><br><span class="line">    BulkResponse response = restHighLevelClient.bulk(request,RequestOptions.DEFAULT);</span><br><span class="line">    log.info(<span class="string">&quot;返回批量插入文档结果是否失败：&quot;</span>+response.hasFailures());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210414160453565.png" alt="image-20210414160453565"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210414160505801.png" alt="image-20210414160505801"></p><h3 id="4-10、搜索"><a href="#4-10、搜索" class="headerlink" title="4.10、搜索"></a>4.10、搜索</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 搜索文档</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: cheng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2021/4/14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testSearchDoc</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest(ES_INDEX);</span><br><span class="line">    SearchSourceBuilder searchBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    searchBuilder.timeout(TimeValue.timeValueSeconds(<span class="number">1</span>));</span><br><span class="line">    <span class="comment">//所有的搜索方式都可以通过QueryBuilders工具类进行获取</span></span><br><span class="line">    MatchQueryBuilder matchQueryBuilder = QueryBuilders.matchQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;小&quot;</span>);</span><br><span class="line">    searchBuilder.query(matchQueryBuilder)</span><br><span class="line">                .from(<span class="number">0</span>)</span><br><span class="line">                .size(<span class="number">3</span>);</span><br><span class="line">    request.source(searchBuilder);</span><br><span class="line">    SearchResponse response = restHighLevelClient.search(request,RequestOptions.DEFAULT);</span><br><span class="line">    log.info(<span class="string">&quot;返回查询结果：&#123;&#125;&quot;</span>,JSON.toJSONString(response.getHits()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210414161722807.png" alt="image-20210414161722807"></p><p>所有的内容都放在<strong>sourceAsMap</strong>中，可以遍历进行获取。</p>]]></content>
      
      
      <categories>
          
          <category> ElasticSearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
            <tag> NoSQL </tag>
            
            <tag> 搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap和ConCurrentHashMap总结与面试</title>
      <link href="/blog/2021/04/10/HashMap%E5%92%8CConCurrentHashMap%E6%80%BB%E7%BB%93%E4%B8%8E%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/blog/2021/04/10/HashMap%E5%92%8CConCurrentHashMap%E6%80%BB%E7%BB%93%E4%B8%8E%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="HashMap和ConCurrentHashMap总结与面试"><a href="#HashMap和ConCurrentHashMap总结与面试" class="headerlink" title="HashMap和ConCurrentHashMap总结与面试"></a>HashMap和ConCurrentHashMap总结与面试</h1><h1 id="一、HashMap"><a href="#一、HashMap" class="headerlink" title="一、HashMap"></a>一、HashMap</h1><h2 id="1、HashMap底层数据结构"><a href="#1、HashMap底层数据结构" class="headerlink" title="1、HashMap底层数据结构"></a>1、HashMap底层数据结构</h2><p><strong>JDK7</strong>：数组+链表；</p><p><strong>JDK8</strong>:  数组+链表+红黑树（JDK8中即使用了单向链表，也使用了双向链表，双向链表主要是为了链表操作方便，应该在插入，扩容，链表转红黑树，红黑树转链表的过程中都要操作链表）；</p><h2 id="2、JDK8中的HashMap为什么要使用红黑树？"><a href="#2、JDK8中的HashMap为什么要使用红黑树？" class="headerlink" title="2、JDK8中的HashMap为什么要使用红黑树？"></a>2、JDK8中的HashMap为什么要使用红黑树？</h2><p>&emsp;&emsp;当元素个数小于一个阈值时，链表整体的插入查询效率要高于红黑树，当元素个数大于此阈值时，链表整体的插入查询效率要低于红黑树。此阈值在HashMap中为<font color='red'>8</font>；</p><h2 id="3、JDK8中的HashMap什么时候将链表转化为红黑树？"><a href="#3、JDK8中的HashMap什么时候将链表转化为红黑树？" class="headerlink" title="3、JDK8中的HashMap什么时候将链表转化为红黑树？"></a>3、JDK8中的HashMap什么时候将链表转化为红黑树？</h2><p>&emsp;&emsp;当发现<font color='red'>链表中的元素个数大于8</font>之后，还会判断一下当前数组的总长度，如果数组长度小于64时，此时并不会转化为红黑树，而是进行扩容。只有当链表中的<font color='red'>元素个数大于8</font>，并且<font color='red'>数组的长度大于等于64</font>时才会将链表转为红黑树。而之所以小于64个则进行扩容，是因为如果只有元素大于8个的条件，则后面可能出现remove元素的况，当元素低于6个时，则需要进行退化，<strong>频繁的相互转化</strong>是一笔不小的开销。通过<strong>标准的泊松分布</strong>计算出来链表的元素要大于8×8个，则可以进行树化。</p><h2 id="4、JDK8中HashMap的put方法的实现过程？"><a href="#4、JDK8中HashMap的put方法的实现过程？" class="headerlink" title="4、JDK8中HashMap的put方法的实现过程？"></a>4、JDK8中HashMap的put方法的实现过程？</h2><blockquote><ol><li><p>根据key值生成hashcode</p></li><li><p>判断当前HashMap对象中的数组是否为空，如果为空则初始化该数组</p></li><li><p>根据逻辑与运算，算出hashcode基于当前数组对应的数组下标i</p></li><li><p>判断数组的第i个位置的元素（tab[i]）是否为空</p><p>4.1、如果为空，则将key，value封装为Node对象赋值给tab[i]</p><p>4.2、如果不为空：</p><p>&emsp;4.2.1、如果put方法传入进来的key等于tab[i].key，那么证明存在相同的key</p><p>&emsp;4.2.2、如果不等于tab[i].key，则：</p><p>&emsp;&emsp;&emsp;4.2.2.1、如果tab[i]的类型是TreeNode，则表示数组的第i位置上是一颗红黑树，那么将key和value插入到红黑树中，并且在插入之前会判断在红黑树中是否存在相同的key</p><p>&emsp;&emsp;&emsp;4.2.2.2、如果tab[i]的类型不是TreeNode，则表示数组的第i位置上是一个链表，那么遍历链表寻找是否存在相同的key，并且在遍历的过程中会对链表中的结点数进行计数，当遍历到最后一个结点时，会将key,value封装为Node插入到链表的尾部，同时判断在插入新结点之前的链表结点个数是不是大于等于8（元素总数大于64），如果是，则将链表改为红黑树。</p><p>&emsp;4.2.3、如果上述步骤中发现存在相同的key，则根据onlyIfAbsent标记来判断是否需要更新value值，然后返回oldValue</p></li><li><p>modCount++</p></li><li><p>HashMap的元素个数size加1</p></li><li><p>如果size大于扩容的阈值，则进行扩容</p></li></ol></blockquote><h2 id="5、JDK8中HashMap的get方法的实现过程"><a href="#5、JDK8中HashMap的get方法的实现过程" class="headerlink" title="5、JDK8中HashMap的get方法的实现过程"></a>5、JDK8中HashMap的get方法的实现过程</h2><ol><li><p>根据key生成hashcode</p></li><li><p>如果数组为空，则直接返回空</p></li><li><p>如果数组不为空，则利用hashcode和数组长度通过逻辑与操作算出key所对应的数组下标i</p></li><li><p>如果数组的第i个位置上没有元素，则直接返回空</p></li><li><p>如果数组的第1个位上的元素的key等于get方法所传进来的key，则返回该元素，并获取该元素的value</p></li><li><p>如果不等于则判断该元素还有没有下一个元素，如果没有，返回空</p></li><li><p>如果有则判断该元素的类型是链表结点还是红黑树结点，如果是链表则遍历链表，如果是红黑树则遍历红黑树</p></li><li><p>找到即返回元素，没找到的则返回空</p></li></ol><h2 id="6、JDK7与JDK8中HashMap的不同点"><a href="#6、JDK7与JDK8中HashMap的不同点" class="headerlink" title="6、JDK7与JDK8中HashMap的不同点"></a>6、JDK7与JDK8中HashMap的不同点</h2><p>1、JDK8中使用了红黑树。</p><p>2、JDK7中链表的插入使用的<strong>头插法</strong>（扩容转移元素的时候也是使用的头插法，<strong>头插法速度更快，无需遍历链表</strong>，但是在<strong>多线程扩容的情况下使用头插法会出现循环链表的问题</strong>，导致CPU飙升），JDK8中链表使用的<strong>尾插法</strong>（JDK8中反正要去计算链表当前结点的个数，反正要遍历的链表的，所以直接使用尾插法）。</p><p>3、JDK7的Hash算法比JDK8中的更复杂，Hash算法越复杂，生成的hashcode则更散列，那么hashmap中的元素则更散列，更散列则hashmap的查询性能更好，由于JDK7中没有红黑树，所以只能优化Hash算法使得元素更散列，而JDK8中增加了红黑树，查询性能得到了保障，所以可以简化一下Hash算法。</p><p>4、扩容的过程中JDK7中有可能会重新对key进行哈希（重新Hash跟哈希种子有关系），而JDK8中（包括JDK7和JDK8的ConcurrentHashMap）都没有这部分逻辑。</p><p>5、JDK8中扩容的条件和JDK7中不一样，除开判断size是否大于阈值之外，JDK7中还判断了tab[i]是否为空，不为空的时候才会进行扩容，而JDK8中则移除该条件了。</p><p>6、JDK8中还多了一个API：putIfAbsent(key,value)【该健存在值，则不修改值】。</p><p>7、JDK7和JDK8扩容过程中转移元素的逻辑不一样，JDK7是每次转移一个元素，JDK8是先算出来当前位置上哪些元素在新数组的低位上，哪些在新数组的高位上，然后在一次性转移。</p><h1 id="二、ConcurrentHashMap"><a href="#二、ConcurrentHashMap" class="headerlink" title="二、ConcurrentHashMap"></a>二、ConcurrentHashMap</h1><h2 id="1、JDK7中的ConcurrentHashMap是怎么保证并发安全的？"><a href="#1、JDK7中的ConcurrentHashMap是怎么保证并发安全的？" class="headerlink" title="1、JDK7中的ConcurrentHashMap是怎么保证并发安全的？"></a>1、JDK7中的ConcurrentHashMap是怎么保证并发安全的？</h2><p>主要利用<font color='red'>Unsafe操作+ReentrantLock+分段思想</font>。</p><p>主要使用了Unsafe操作中的：</p><ul><li>compareAndSwapObject：通过cas的方式修改对象的属性</li><li>putOrderedObject：并发安全的给数组的某个位置赋值</li><li>getObjectVolatile：并发安全的获取数组某个位置的元素</li></ul><p>&emsp;&emsp;分段思想是为了提高ConcurrentHashMap的并发量，分段数越高则支持的最大并发量越高，程序员可以通过concurrencyLevel参数来指定并发量。ConcurrentHashMap的内部类Segment就是用来表示某一个段的。</p><p>&emsp;&emsp;每个Segment就是一个小型的HashMap的，当调用ConcurrentHashMap的put方法时，最终会调用到Segment的put方法，而Segment类继承了ReentrantLock，所以Segment自带可重入锁，当调用到Segment的put方法时，会先利用可重入锁加锁，加锁成功后再将待插入的key,value插入到小型HashMap中，插入完成后解锁。</p><h2 id="2、JDK7中的ConcurrentHashMap的底层原理"><a href="#2、JDK7中的ConcurrentHashMap的底层原理" class="headerlink" title="2、JDK7中的ConcurrentHashMap的底层原理"></a>2、JDK7中的ConcurrentHashMap的底层原理</h2><p>ConcurrentHashMap底层是由两层嵌套数组来实现的：</p><ol><li>ConcurrentHashMap对象中有一个属性segments，类型为Segment[];</li><li>Segment对象中有一个属性table，类型为HashEntry[];</li></ol><p>&emsp;&emsp;当调用ConcurrentHashMap的put方法时，先根据key计算出对应的Segment[]的数组下标j，确定好当前key,value应该插入到哪个Segment对象中，如果segments[j]为空，则利用自旋锁的方式在j位置生成一个Segment对象。然后调用Segment对象的put方法。</p><p>&emsp;&emsp;Segment对象的put方法会先加锁，然后也根据key计算出对应的HashEntry[]的数组下标i，然后将key,value封装为HashEntry对象放入该位置，此过程和JDK7的HashMap的put方法一样，然后解锁。</p><p>&emsp;&emsp;在加锁的过程中逻辑比较复杂，属于尝试加锁阶段，先通过自旋加锁，如果超过一定次数就会直接阻塞加锁。</p><h2 id="3、JDK8中的ConcurrentHashMap是怎么保证并发安全的？"><a href="#3、JDK8中的ConcurrentHashMap是怎么保证并发安全的？" class="headerlink" title="3、JDK8中的ConcurrentHashMap是怎么保证并发安全的？"></a>3、JDK8中的ConcurrentHashMap是怎么保证并发安全的？</h2><p>JDK8中主要利用<font color='red'>Unsafe操作+synchronized关键字</font>。</p><p>&emsp;&emsp;Unsafe操作的使用仍然和JDK7中的类似，主要负责并发安全的修改对象的属性或数组某个位置的值。</p><p>&emsp;&emsp;而synchronized主要负责在需要操作某个位置时进行加锁（该位置不为空），比如向某个位置的链表进行插入结点，向某个位置的红黑树插入结点。</p><p>JDK8中其实仍然有分段锁的思想，只不过JDK7中段数是可以控制的，而JDK8中是数组的每一个位置都有一把锁。</p><h2 id="4、JDK8中的ConcurrentHashMap为什么使用synchronized来进行加锁？"><a href="#4、JDK8中的ConcurrentHashMap为什么使用synchronized来进行加锁？" class="headerlink" title="4、JDK8中的ConcurrentHashMap为什么使用synchronized来进行加锁？"></a>4、JDK8中的ConcurrentHashMap为什么使用synchronized来进行加锁？</h2><p>&emsp;&emsp;JDK8中使用synchronized加锁时，是对链表头结点和红黑树根结点来加锁的，而ConcurrentHashMap会保证，数组中某个位置的元素一定是链表的头结点或红黑树的根结点，所以JDK8中的ConcurrentHashMap在对某个桶进行并发安全控制时，只需要使用synchronized对当前那个位置的数组上的元素进行加锁即可，对于每个桶，只有获取到了第一个元素上的锁，才能操作这个桶，不管这个桶是一个链表还是红黑树。</p><p>&emsp;&emsp;想比于JDK7中使用ReentrantLock来加锁，因为JDK7中使用了分段锁，所以对于一个ConcurrentHashMap对象而言，分了几段就得有几个ReentrantLock对象，表示得有对应的几把锁。</p><p>&emsp;&emsp;而JDK8中使用synchronized关键字来加锁就会更节省内存，并且jdk也已经对synchronized的底层工作机制进行了优化，效率更好。</p><h2 id="5、JDK8中的ConcurrentHashMap的put方法的实现流程"><a href="#5、JDK8中的ConcurrentHashMap的put方法的实现流程" class="headerlink" title="5、JDK8中的ConcurrentHashMap的put方法的实现流程"></a>5、JDK8中的ConcurrentHashMap的put方法的实现流程</h2><ol><li><p>首先根据key计算对应的数组下标i，如果该位置没有元素，则通过自旋的方法去向该位置赋值。</p></li><li><p>如果该位置有元素，则synchronized会加锁</p></li><li><p>加锁成功之后，在判断该元素的类型：</p><p>3.1、如果是链表节点则进行添加节点到链表中</p><p>3.2、如果是红黑树则添加节点到红黑树</p></li><li><p>添加成功后，判断是否需要进行树化</p></li><li><p>addCount，并发安全地对ConcurrentHashMap元素个数 + 1(采用了LongAdder思想)，然后判断是否需要扩容，并且元素个数加1成功后，会继续判断是否要进行扩容，如果需要，则会进行扩容。</p></li><li><p>同时一个线程在put时如果发现当前ConcurrentHashMap正在进行扩容则会去帮助扩容。</p></li></ol><h2 id="6、DK7和JDK8中，统计元素个数的实现逻辑有什么区别？"><a href="#6、DK7和JDK8中，统计元素个数的实现逻辑有什么区别？" class="headerlink" title="6、DK7和JDK8中，统计元素个数的实现逻辑有什么区别？"></a>6、DK7和JDK8中，统计元素个数的实现逻辑有什么区别？</h2><blockquote><p>JDK7:<br>1.第一次遍历累加Segment[]数组中的count属性<br>2.第二次遍历累加Segmeng[]数组中的count属性<br>3.如果在两次遍历过程中，结果不相等，则再遍历第三次累加，和第二次的结果对比，若相等则返回<br>4.若还是不等，则对Segment数组的上的所有元素加锁，然后计算</p></blockquote><blockquote><p>JDK8：<br>1.有一个baseCount的属性，供以CAS操作，并借鉴了LongAdder的设计思想<br>2.当baseCount在CAS竞争激烈时，使用CounterCell[]数组提供多个篮子进行资源分散<br>3.只要能对篮子中的值CAS成功后，即可<br>4.最终统计时，通过累加baseCount + CounterCell[] 得到结果。</p></blockquote><h2 id="7、JDK7和JDK8中的ConcurrentHashMap的不同点"><a href="#7、JDK7和JDK8中的ConcurrentHashMap的不同点" class="headerlink" title="7、JDK7和JDK8中的ConcurrentHashMap的不同点"></a>7、JDK7和JDK8中的ConcurrentHashMap的不同点</h2><p>包括了HashMap中的不同点以外，也有其他不同点，比如：</p><ol><li>JDK8中没有分段锁了，而是使用synchronized来进行控制</li><li>JDK8中的扩容性能更高，支持多线程同时扩容，实际上JDK7中也支持多线程扩容，因为JDK7中的扩容是针对每个Segment的，所以也可能多线程扩容，但是性能没有JDK8高，因为JDK8中对于任意一个线程都可以去帮助扩容</li><li>JDK8中的元素个数统计的实现也不一样了，JDK8中增加了CounterCell来帮助计数，而JDK7中没有，JDK7中是put的时候每个Segment内部计数，统计的时候是遍历每个Segment对象加锁统计。</li></ol><h2 id="8、JDK7和JDK8中，都支持多线程并发扩容吗？"><a href="#8、JDK7和JDK8中，都支持多线程并发扩容吗？" class="headerlink" title="8、JDK7和JDK8中，都支持多线程并发扩容吗？"></a>8、JDK7和JDK8中，都支持多线程并发扩容吗？</h2><p>都支持多线程扩容。<br>&emsp;&emsp;在JDK7中，扩容只是针对一个Segment对象中的HashEntry[]对象，所以能够达到多个线程同时扩容不同的Segment对象。<br>&emsp;&emsp;在JDK8中，每个线程迁移指定步长下标的元素，并发操作，达到多线程同时扩容一个tab数组。</p><p><strong>JDK8的扩容性能更高，因为JDK8对任意一个线程都可以帮助扩容，而JDK7一个线程扩容一个Segment</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> Java源码 </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashMap </tag>
            
            <tag> ConCurrentHashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap和ConCurrentHashMap源码解析</title>
      <link href="/blog/2021/04/10/HashMap%E5%92%8CConCurrentHashMap/"/>
      <url>/blog/2021/04/10/HashMap%E5%92%8CConCurrentHashMap/</url>
      
        <content type="html"><![CDATA[<h1 id="HashMap和ConCurrentHashMap源码解析"><a href="#HashMap和ConCurrentHashMap源码解析" class="headerlink" title="HashMap和ConCurrentHashMap源码解析"></a>HashMap和ConCurrentHashMap源码解析</h1><h1 id="一、Hashing哈希法的概念"><a href="#一、Hashing哈希法的概念" class="headerlink" title="一、Hashing哈希法的概念"></a>一、Hashing哈希法的概念</h1><p>&emsp;&emsp;散列法（Hashing）是一种将字符组成的字符串转换为固定长度（一般是更短长度）的数值或索引值的方法，称为散列法，也叫哈希法。由于通过更短的哈希值比用原始值进行数据库搜索更快，这种方法一般用来在数据库中建立索引并进行搜索，同时还用在各种解密算法中。</p><h2 id="1、由Hashing引申的HashTable、HashMap、TreeMap"><a href="#1、由Hashing引申的HashTable、HashMap、TreeMap" class="headerlink" title="1、由Hashing引申的HashTable、HashMap、TreeMap"></a>1、由Hashing引申的HashTable、HashMap、TreeMap</h2><p>&emsp;&emsp;HashTable 是早期Java类库提供的一个哈希表实现，本身是同步的，不支持 null 键和值，由于同步导致的性能开销，所以现在已经很少被推荐使用。</p><p>&emsp;&emsp;HashMap与 HashTable主要区别在于 HashMap 不是同步的，支持 null 键和值等。通常情况下，HashMap 进行 put 或者 get 操作，可以达到常数时间的性能，所以它是绝大部分利用键值对存取场景的首选。</p><p>&emsp;&emsp;TreeMap 则是基于红黑树的一种提供顺序访问的 Map，和 HashMap 不同，它的 get、put、remove 之类操作都是 O（log(n)）的时间复杂度，具体顺序可以由指定的 Comparator 来决定，或者根据键的自然顺序来判断。</p><h1 id="二、HashMap"><a href="#二、HashMap" class="headerlink" title="二、HashMap"></a>二、HashMap</h1><h2 id="1、HashMap的概念和底层结构"><a href="#1、HashMap的概念和底层结构" class="headerlink" title="1、HashMap的概念和底层结构"></a>1、HashMap的概念和底层结构</h2><p>&emsp;&emsp;HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p><hr><h4 id="面试题1、HashMap的工作原理"><a href="#面试题1、HashMap的工作原理" class="headerlink" title="面试题1、HashMap的工作原理"></a><font color='red'>面试题1、HashMap的工作原理</font></h4><p>&emsp;&emsp;HashMap的工作原理 ：HashMap是基于散列法（又称哈希法）的原理，使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，返回的hashCode用于找到bucket（桶）位置来储存Entry对象。HashMap是在bucket中储存键对象和值对象，作为Map.Entry。并不是仅仅只在bucket中存储值。</p><h4 id="面试题2：什么叫哈希碰撞（哈希冲突）？"><a href="#面试题2：什么叫哈希碰撞（哈希冲突）？" class="headerlink" title="面试题2：什么叫哈希碰撞（哈希冲突）？"></a><font color='red'>面试题2：什么叫哈希碰撞（哈希冲突）？</font></h4><p>&emsp;&emsp;不同的键值通过哈希函数运算得到相同的哈希值，解决哈希冲突的方式有开放寻址法和链表法，ThreadLocalMap由于其元素个数较少，采用的是开放寻址法，而HashMap采用的是链表法来解决哈希冲突，即所有散列值相同的元素都放在相同槽对应的链表中（也就是数组+链表的方式）。</p><hr><p>&emsp;&emsp;我们都知道，在JDK8之前，HashMap的数据结构是：<font color='red'>数组+链表</font>  的复合结构，数组被分为一个个的桶（bucket）每一个桶都是存储着一个或多个Entry对象，我们查看Entry对象的源码，发现每一个Entry对象包含Key【键】、value【值】、next【指向下一个Entry对象】,通过哈希值决定Entry对象在这个数组的寻址，哈希值相同的Entry对象，则以链表的形式存储。</p><p>我们可以通过源码看到，Entry有一个构造函数，该构造函数第三个参数是<strong>Entry&lt;K,V&gt; n</strong>，<strong>主要用于链表的头插入，传入链表的链表头，将新生成的Entry对象作为链表的头部，next属性指向原链表头，如下图2。</strong>这个也就是所谓的<font color='red'>“头插法”</font></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1616083123591.png" alt="1616083123591"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1616312977244.png" alt="1616312977244"></p><h2 id="2、HashMap的查询时间复杂度"><a href="#2、HashMap的查询时间复杂度" class="headerlink" title="2、HashMap的查询时间复杂度"></a>2、HashMap的查询时间复杂度</h2><p>&emsp;&emsp;HashMap的本质是一个数组，数组的每个索引被称为桶，每个桶里放着一个单链表，一个节点连着一个节点。很明显通过下标来检索数组元素时间复杂度为O(1)，而且遍历链表的时间复杂度是O(n)，所以在链表长度尽可能短的前提下，HashMap的查询复杂度接近O(1)。</p><p>问题：为什么HashMap会选择数组+链表的数据结构来保存数据？</p><p>&emsp;&emsp;对于数组，其存储区间连续，占用内存严重，寻址容易，插入与删除困难；而对于链表，存储区间离散，占用内存比较宽松，寻址困难，插入与删除容易；而HashMap综合应用了这两种结构，实现了寻址容易，插入与删除也容易。</p><h2 id="3、HashMap源码中各个常量、成员变量的意思"><a href="#3、HashMap源码中各个常量、成员变量的意思" class="headerlink" title="3、HashMap源码中各个常量、成员变量的意思"></a>3、HashMap源码中各个常量、成员变量的意思</h2><p>常量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建 HashMap 时未指定初始容量情况下的默认容量   </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; </span><br><span class="line">【<span class="number">1</span>&lt;&lt;<span class="number">4</span> =》  <span class="number">0000</span> <span class="number">0001</span> 左移<span class="number">4</span>位，变成 <span class="number">0001</span> <span class="number">0000</span> =》 <span class="number">16</span>】</span><br><span class="line"><span class="comment">//HashMap 的最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//HashMap 默认的装载因子,当 HashMap 中元素数量超过 容量*装载因子 时，进行　resize()扩容操作</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//保存Node&lt;K,V&gt;节点的数组</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">//由　hashMap 中 Node&lt;K,V&gt;　节点构成的 set</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录 hashMap 当前存储的元素的数量</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录　hashMap 发生结构性变化的次数（注意　value 的覆盖不属于结构性变化）</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">//threshold的值应等于 table.length * loadFactor, size 超过这个值时进行　resize()扩容</span></span><br><span class="line"><span class="keyword">int</span> threshold; </span><br><span class="line"></span><br><span class="line"><span class="comment">//记录 hashMap 加载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><h2 id="4、JDK1-7-HashMap源码"><a href="#4、JDK1-7-HashMap源码" class="headerlink" title="4、JDK1.7 HashMap源码"></a>4、JDK1.7 HashMap源码</h2><h3 id="4-1、HashMap的构造函数"><a href="#4-1、HashMap的构造函数" class="headerlink" title="4.1、HashMap的构造函数"></a>4.1、HashMap的构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里主要是判断一些初始化参数，例如初始化容量不小于0且不超过最大值，加载因子不小于等于0</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">//正常情况下，threshold的值应等于 table.length * loadFactor, size 超过这个值时进行　resize()扩容，但由于现在还未初始化table，所以默认设置该值为初始化容量大小。</span></span><br><span class="line">    threshold = initialCapacity;</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2、HashMap的put方法"><a href="#4-2、HashMap的put方法" class="headerlink" title="4.2、HashMap的put方法"></a>4.2、HashMap的put方法</h3><p> <img src="http://cheng_qiwei.gitee.io/blog/img/1617286646051.png" alt="1617286646051"></p><p>&emsp;&emsp;我们从HashMap的构造方法中，我们发现，在new一个HashMap对象时，他并没有去真正赋予数组的大小，它其实是使用了懒加载，在put的时候才进行赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断table是否为空，为空则初始化table</span></span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当key为null时，把该对象添加到数组下标为0的位置上</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="comment">//计算key的hash值</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">//根据hash值和数组长度计算下标【存放在数组的位置上，方法是hash &amp; （length -1）】</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="comment">//遍历下标对应的列表，获取是否该Key存在于列表中，存在则替换该值并将旧的值返回</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//增加修改次数</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//若上面遍历不存在，则进行插入操作；</span></span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-1、inflateTable-int-toSize"><a href="#4-2-1、inflateTable-int-toSize" class="headerlink" title="4.2.1、inflateTable(int toSize);"></a>4.2.1、inflateTable(int toSize);</h4><p>该方法主要是初始化table数组，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inflateTable</span><span class="params">(<span class="keyword">int</span> toSize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Find a power of 2 &gt;= toSize</span></span><br><span class="line">    <span class="comment">//返回2的次方，需要返回值大于等于toSize</span></span><br><span class="line">    <span class="keyword">int</span> capacity = roundUpToPowerOf2(toSize);</span><br><span class="line"></span><br><span class="line">    threshold = (<span class="keyword">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">    table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">    initHashSeedAsNeeded(capacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回2的次方，需要返回值大于等于number</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">roundUpToPowerOf2</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert number &gt;= 0 : &quot;number must be non-negative&quot;;</span></span><br><span class="line">    <span class="keyword">return</span> number &gt;= MAXIMUM_CAPACITY</span><br><span class="line">        ? MAXIMUM_CAPACITY</span><br><span class="line">        : (number &gt; <span class="number">1</span>) ? Integer.highestOneBit((number - <span class="number">1</span>) &lt;&lt; <span class="number">1</span>) : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化中最重要的方法，返回大于等于i的2的次方数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">highestOneBit</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">1</span>);</span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">2</span>);</span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">4</span>);</span><br><span class="line">    i |= (i &gt;&gt;  <span class="number">8</span>);</span><br><span class="line">    i |= (i &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> i - (i &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里以一个例子验证roundUpToPowerOf2方法    </p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">eg:获取7最接近的2次平方的值</span><br><span class="line">0000 0111    =》7</span><br><span class="line">0000 0110    =》7 - 1 = 6</span><br><span class="line">&lt;&lt; 1</span><br><span class="line">0000 1100    =》12</span><br><span class="line">i |= (i &gt;&gt;  1);//0000 1100 | 0000 0110 = 0000 1110</span><br><span class="line">i |= (i &gt;&gt;  2);//0000 1110 | 0000 0011 = 0000 1111</span><br><span class="line">i |= (i &gt;&gt;  4);//以下也如此，主要是为了把后面的位数都填充为1但到此就已经完成，后面没意义</span><br><span class="line">i |= (i &gt;&gt;  8);</span><br><span class="line">i |= (i &gt;&gt; 16);</span><br><span class="line"></span><br><span class="line">return i - (i &gt;&gt;&gt; 1);  //0000 1111 - 0000 0111 = 0000 1000  =》 8</span><br></pre></td></tr></table></figure><h4 id="4-2-2、indexFor-int-h-int-length"><a href="#4-2-2、indexFor-int-h-int-length" class="headerlink" title="4.2.2、indexFor(int h, int length);"></a>4.2.2、indexFor(int h, int length);</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;</span></span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法主要是用来计算下标，例如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0010 0100  =》36(hash)</span><br><span class="line">length = 16</span><br><span class="line">hash &amp; length - 1</span><br><span class="line">0010 0100</span><br><span class="line">&amp;</span><br><span class="line">0000 1111</span><br><span class="line">0000 0100 =》 4</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里将低位全部变成1，再进行与运算后，下标必定会落在其范围中，这也是为什么规定了<strong>HashMap的容量必须是2的次方数</strong>的原因。但是，由于这里都是使用低位进行运算，而高位没有进行运算，所以可能会出现数据分布不均，所以在该方法的上一层计算hash的时候，做了很多右移并进行异或运算的操作，解决分布不均衡的问题。</p><h4 id="4-2-3、addEntry-int-hash-K-key-V-value-int-bucketIndex"><a href="#4-2-3、addEntry-int-hash-K-key-V-value-int-bucketIndex" class="headerlink" title="4.2.3、addEntry(int hash, K key, V value, int bucketIndex);"></a>4.2.3、addEntry(int hash, K key, V value, int bucketIndex);</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        <span class="comment">//当数组长度大于等于扩容的阈值时且数组下标对应链表不为空时，进行扩容，扩容的长度为原来的两倍</span></span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;<span class="comment">//rehash大几率时false，除非自己去修改hashSeed的值</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">             <span class="comment">//替换数组中的链表头位置</span></span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;addEntry这个方法包含几个重要的逻辑，第一个是resize扩容，当数组长度大于等于扩容的阈值时且数组下标对应链表不为空时，进行扩容，扩容的长度为原来的两倍。而之所以需要进行扩容，是因为数组的长度固定时，当元素过多时，那么每个链表的元素就会增加，当链表过长时，根据上面讲的HashMap的查询时间复杂度，调用get方法就会更耗性能，所以通过扩容，将数据分散开来，提升访问性能。<strong>在Hash值未被重新计算的前提下，若链表元素被分配到其他新链表时，其新链表的下标=原下标+原数组长度</strong>。</p><p>&emsp;&emsp;在扩容的源码中，有一个initHashSeedAsNeeded的方法来计算是否需要进行重新hash的操作，在默认情况下，是永远不会进行该操作，除非配置了JVM启动参数<code>jdk.map.althashing.threshold</code>，这个操作是为了将链表打散，使扩容后的数据分布更加均匀。</p><h4 id="面试题3、JDK8之前HashMap多线程resize的时候造成闭环链表问题，如何解决"><a href="#面试题3、JDK8之前HashMap多线程resize的时候造成闭环链表问题，如何解决" class="headerlink" title="面试题3、JDK8之前HashMap多线程resize的时候造成闭环链表问题，如何解决"></a><font color='red'>面试题3、JDK8之前HashMap多线程resize的时候造成闭环链表问题，如何解决</font></h4><p>a、单线程正常的扩容过程</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210313231117108.png" alt="image-20210313231117108"></p><p>&emsp;&emsp;当数组的size从2扩容为4时，所有的值会进行重排【重新算出数组下标，下标只会是原来的位置或原来的下标+原数组的长度】，然后赋值到新的map上面，赋值完成后，当所有值都同时被保存在一测时，会出现当前的链表是之前链表的倒序的情况。</p><p>b、并发下的扩容</p><p>会出现问题的代码在下图：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/20170125112507421.png" alt="20170125112507421"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1615903731791.png" alt="1615903731791"></p><p>由于线程1、2同时执行，当线程2执行到红框那一行之后就被CPU挂起，而线程1把代码执行完毕后，就会如图2第二行最后的结果一致，接着CPU切换到线程1上来，先把K1安置，接着</p><p>e = next = K2；</p><p>e != null;此时循环继续；</p><p>next = e.next = K1；由于发生了改变，此时的next指回K1</p><p>但是由于K1已存在，所以指针直接指向K1，此时整个链表变成一个闭环，从而造成闭环链表问题。</p><p>在复杂的生产环境中，这种情况尽管不常见，但是可能会碰到。</p><p><font color='red'>解决方案是：在已知hashMap的数据长度时，在初始化的时候直接指定hashMap的长度，避免其进行扩容，就不会出现该情况。</font></p><h4 id="4-2-4、modCount"><a href="#4-2-4、modCount" class="headerlink" title="4.2.4、modCount++;"></a>4.2.4、modCount++;</h4><p>&emsp;&emsp;在put方法中，还有一个modCount++;的操作，modCount这个参数是用来计算该对象被修改的次数，是hashMap提供的一种快速失败的机制，用于迭代遍历时校验对象是否被修改，当集合在迭代过程中被其他线程修改时，就会抛出<code>ConcurrentModificationException</code>。【并发修改异常】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">nextEntry</span><span class="params">()</span> </span>&#123;    </span><br><span class="line"><span class="comment">//在遍历集合之前会将modCount赋值给expectedModCount，接着遍历过程中会不断验证modCount是否发生变化</span></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)        </span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();    </span><br><span class="line">    Entry&lt;K,V&gt; e = next;    </span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)        </span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();    </span><br><span class="line">    <span class="keyword">if</span> ((next = e.next) == <span class="keyword">null</span>) &#123;        </span><br><span class="line">        Entry[] t = table;        </span><br><span class="line">        <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);    </span><br><span class="line">    &#125;    </span><br><span class="line">    current = e;    </span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题：那想要在遍历集合的过程中删除集合的元素，该如何实现？</p><p>&emsp;&emsp;我们可以通过使用Iterator迭代器遍历集合，调用迭代器的<code>remove</code>方法删除元素，该方法在删除元素的时候会重新对<code>expectedModCount</code>赋值，保证了<code>modCount == expectedModCount</code>。</p><h1 id="三、JDK1-7-ConcurrentHashMap源码"><a href="#三、JDK1-7-ConcurrentHashMap源码" class="headerlink" title="三、JDK1.7 ConcurrentHashMap源码"></a>三、JDK1.7 ConcurrentHashMap源码</h1><p>&emsp;&emsp;我们都知道，HashMap是线程不安全的，而HashTable是线程安全的，但是我们几乎不怎么使用HashTable，那是因为HashTable使用synchroized来保证线程安全，但这就导致在多线程竞争激烈的情况下HashTable的使用率极其低下。当一个线程在访问HashTable的同步方法时，其他线程也需要访问HashTable的同步方法时，会进入阻塞或轮询状态。</p><p>&emsp;&emsp;既然HashTable在多线程中是由于争抢一把锁导致性能低下，那么我们是否可以在容器中设置多把锁，每一把锁锁住一部分数据，那么在多线程访问中，线程间就不会出现锁竞争，从而提高并发访问效率。而这个设想，就是ConcurrentHashMap所使用的锁分离技术。首先将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p><h2 id="1、ConcurrentHashMap源码的常量与成员变量"><a href="#1、ConcurrentHashMap源码的常量与成员变量" class="headerlink" title="1、ConcurrentHashMap源码的常量与成员变量"></a>1、ConcurrentHashMap源码的常量与成员变量</h2><p>&emsp;&emsp;与HashMap相比，ConcurrentHashMap增加的属性有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//并发级别，用于计算一个Segment负责管理多少个Entry数组</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br><span class="line"><span class="comment">//规定了segment中的HashEntry数组最小容量，数组容量必须是2的次方数,次方数至少为1</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_SEGMENT_TABLE_CAPACITY = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//规定了segment数组的最大值不能超过2的16次方</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SEGMENTS = <span class="number">1</span> &lt;&lt; <span class="number">16</span>;</span><br><span class="line"><span class="comment">//segmentMask = segment[].length - 1 用来执行【haschCode &amp; segmentMask】计算Hash值</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> segmentMask;</span><br></pre></td></tr></table></figure><h2 id="2、ConcurrentHashMap源码"><a href="#2、ConcurrentHashMap源码" class="headerlink" title="2、ConcurrentHashMap源码"></a>2、ConcurrentHashMap源码</h2><h3 id="2-1、ConcurrentHashMap的构造函数"><a href="#2-1、ConcurrentHashMap的构造函数" class="headerlink" title="2.1、ConcurrentHashMap的构造函数"></a>2.1、ConcurrentHashMap的构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">//这里规定segment的最大容量不能超过2的16次方</span></span><br><span class="line">    <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">        concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">    <span class="comment">// 这里的sshift用于保存segment数组容量的2的次方数，ssize保存的是segment数组容量的2的次方值</span></span><br><span class="line">    <span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//用来获取大于等于concurrencyLevel的2的次方数</span></span><br><span class="line">    <span class="comment">//默认的concurrencyLevel=16，循环4次后，sshift=4,ssize=16</span></span><br><span class="line">    <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">        ++sshift;</span><br><span class="line">        ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">    <span class="keyword">this</span>.segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//这里规定map的最大容量不能超过2的30次方</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="comment">//按照默认值计算 c = 1</span></span><br><span class="line">    <span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line">    <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">        ++c;</span><br><span class="line">    <span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY;</span><br><span class="line">    <span class="comment">//因为cap = 2 &gt; c = 1，所以cap = 2</span></span><br><span class="line">    <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">        cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//在初始化Segment数组时默认初始化segment[0]，主要是为了生成原型，当初始化其他segment对象时无需再计算HashEntry数组大小</span></span><br><span class="line">    Segment&lt;K,V&gt; s0 =</span><br><span class="line">        <span class="keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="keyword">int</span>)(cap * loadFactor),</span><br><span class="line">                         (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap]);</span><br><span class="line">    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> Segment[ssize];</span><br><span class="line">    UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></span><br><span class="line">    <span class="comment">//将segment保存下来</span></span><br><span class="line">    <span class="keyword">this</span>.segments = ss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2、ConcurrentHashMap的put方法"><a href="#2-2、ConcurrentHashMap的put方法" class="headerlink" title="2.2、ConcurrentHashMap的put方法"></a>2.2、ConcurrentHashMap的put方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Segment&lt;K,V&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">     <span class="comment">//计算需要存储的segment数组中的下标</span></span><br><span class="line">    <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">    <span class="comment">//判断数组里面的Segment对象是否初始化，为空者执行ensureSegment(j);方法创建Segment对象</span></span><br><span class="line">    <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          </span><br><span class="line">         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>)</span><br><span class="line">        s = ensureSegment(j);</span><br><span class="line">    <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">【计算需要存储的segment数组中的下标    <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;】</span><br><span class="line">按照上面的默认值计算 segmentShift = <span class="number">32</span> - <span class="number">4</span> = <span class="number">28</span>；segmentMask = <span class="number">16</span> -<span class="number">1</span> = <span class="number">15</span></span><br><span class="line">那么此时：hash右移<span class="number">28</span>位后，其值范围就只落在<span class="number">0</span>~<span class="number">15</span>之间，再去与上<span class="number">15</span>，既可以得到对应的下标。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接下来，如果发现该数组下的Segment对象为空，则会进行初始化</span></span><br><span class="line"><span class="comment">//在初始化之前会一直去尝试获取锁，在尝试获取的过程中就会去判断是否有其他线程为其生成对象，如果已经生成，这获取对应对象后直接跳出该方法，否则到最后使用cas自旋，将生成的Segment对象置入数组对应位置中，当有多个线程同时并发执行创建同一个数组下标的segment对象时，由于CAS自旋机制，最终只会有一个线程创建成功，其他线程将获取数组对象并返回，从而达到在并发情况下的线程安全。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Segment&lt;K,V&gt; <span class="title">ensureSegment</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Segment&lt;K,V&gt;[] ss = <span class="keyword">this</span>.segments;</span><br><span class="line">        <span class="keyword">long</span> u = (k &lt;&lt; SSHIFT) + SBASE; <span class="comment">// raw offset</span></span><br><span class="line">        Segment&lt;K,V&gt; seg;</span><br><span class="line">        <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Segment&lt;K,V&gt; proto = ss[<span class="number">0</span>]; <span class="comment">// use segment 0 as prototype</span></span><br><span class="line">            <span class="keyword">int</span> cap = proto.table.length;</span><br><span class="line">            <span class="keyword">float</span> lf = proto.loadFactor;</span><br><span class="line">            <span class="keyword">int</span> threshold = (<span class="keyword">int</span>)(cap * lf);</span><br><span class="line">            HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap];</span><br><span class="line">            <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">                == <span class="keyword">null</span>) &#123; <span class="comment">// recheck</span></span><br><span class="line">                Segment&lt;K,V&gt; s = <span class="keyword">new</span> Segment&lt;K,V&gt;(lf, threshold, tab);</span><br><span class="line">                <span class="keyword">while</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">                       == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(ss, u, <span class="keyword">null</span>, seg = s))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> seg;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最后，当前面的Segment对象创建出来后，就会执行put的方法将数据保存到Segment对象中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//尝试加锁 tryLock不阻塞</span></span><br><span class="line">    HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> : scanAndLockForPut(key, hash, value);</span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="comment">//计算存储的HashEntry数组下标</span></span><br><span class="line">        <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">        <span class="comment">//获取HashEntry数组中的index下标，这里命名的first指的是HashEntry中的链表的头结点</span></span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">        <span class="comment">//遍历链表</span></span><br><span class="line">        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                K k;</span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                    oldValue = e.value;</span><br><span class="line">                    <span class="comment">//如果是ifAbsent,则不更新值，直接返回旧值</span></span><br><span class="line">                    <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                        e.value = value;</span><br><span class="line">                        ++modCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//假设遍历到最后节点均未匹配到相同的key由于它是最后的链表节点，e.next==null</span></span><br><span class="line">                <span class="comment">//再次循环时，将会运行到下面的else条件新建节点</span></span><br><span class="line">                e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//当获取锁失败时，会调用scanAndLockForPut提前生成node对象，这里只需设置链表头即可</span></span><br><span class="line">                <span class="keyword">if</span> (node != <span class="keyword">null</span>)</span><br><span class="line">                    node.setNext(first);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">//创建HashEntry对象，采用头插法，新的HashEntry对象的next属性指向first</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                <span class="comment">//HashEntry总数+1</span></span><br><span class="line">                <span class="keyword">int</span> c = count + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//如果数量达到了扩容的阈值，则进行扩容</span></span><br><span class="line">                <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                    rehash(node);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">//添加HashEntry对象到数组中，并替换数组中的链表头（替换成新创建的HashEntry对象）</span></span><br><span class="line">                    setEntryAt(tab, index, node);</span><br><span class="line">                <span class="comment">//Setment中累加变化次数</span></span><br><span class="line">                ++modCount;</span><br><span class="line">                <span class="comment">//赋值新计算的count值</span></span><br><span class="line">                count = c;</span><br><span class="line">                oldValue = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//解锁ReentrantLock</span></span><br><span class="line">        unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这个put方法首先会去尝试获取一把锁【tryLock】不会阻塞，如果没有获得锁，则会去执行scanAndLockForPut(key, hash, value)这个方法。这个方法的目的就是不断尝试获取锁（不会阻塞），获取不到则提前创建这次put操作的Entry对象，最后尝试超过设置的最大次数后，就直接调用阻塞的lock方法获取锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> HashEntry&lt;K,V&gt; <span class="title">scanAndLockForPut</span><span class="params">(K key, <span class="keyword">int</span> hash, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据Hash值计算数组下标并获取链表的表头</span></span><br><span class="line">    HashEntry&lt;K,V&gt; first = entryForHash(<span class="keyword">this</span>, hash);</span><br><span class="line">    HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">    HashEntry&lt;K,V&gt; node = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//用这个变量来控制循环的逻辑</span></span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// negative while locating node</span></span><br><span class="line">    <span class="comment">//循环尝试获取锁</span></span><br><span class="line">    <span class="keyword">while</span> (!tryLock()) &#123;</span><br><span class="line">        HashEntry&lt;K,V&gt; f; <span class="comment">// to recheck first below</span></span><br><span class="line">        <span class="keyword">if</span> (retries &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//当链表的表头 == null 或者遍历链表后未匹配到元素时，创建HashEntry对象</span></span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="comment">// speculatively create node</span></span><br><span class="line">                    node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                <span class="comment">//设置retries=0用以下次循环时调用其他逻辑</span></span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当链表表头不为空时，遍历链表，寻址到链表元素时设置retries=0调用其他逻辑</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (key.equals(e.key))</span><br><span class="line">                retries = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//当链表遍历到最后一个节点，e.next=null,当再次循环时，会调用创建HashEntry对象的逻辑</span></span><br><span class="line">                e = e.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当重试次数大于一定的次数时，直接调用阻塞的Lock方法</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//(retries &amp; 1) == 0 ：当retries是偶数时，返回true，表示每隔一次才去判断链表表头是否发生变化</span></span><br><span class="line">        <span class="comment">//重新获取链表表头，当链表表头与原来获取的first不同时，设置retries=-1，重新遍历</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((retries &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                 (f = entryForHash(<span class="keyword">this</span>, hash)) != first) &#123;</span><br><span class="line">            e = first = f; <span class="comment">// re-traverse if entry changed</span></span><br><span class="line">            retries = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在获取锁之后，接着就是计算下标，获取存放数组的位置，在插入时，就需要判断是否需要扩容，当满足条件<code>count + 1 &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY</code>时，将调用扩容方法**<font color='red'>rehash</font>**，这里扩容的方法与HashMap有所不同，首先ConcurrentHashMap不需要执行HashMap的reHash方法（重新计算数组下标），所以扩容后链表的元素只会存在于原来的下标或原来的下标+原数组长度，同时，在扩容的时候，也不是说直接遍历整个链表然后一个一个插进新的链表上，而是先遍历整个列表，计算所有元素的新下标，当在某一个元素开始直至结束，其下标均为相同的，则到时候会在该元素开始，将这一整节元素直接迁移到新节点上。然后再依次把其他元素拷贝过来。如图：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/123456789000.jpg" alt="123456789000.jpg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意：这里传的参数是新的HashEntry对象，其next属性指向原链表的头部</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">(HashEntry&lt;K,V&gt; node)</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="comment">//向左偏移1位，扩容一倍大小</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//重新计算阈值</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">    <span class="comment">//初始化新的HashEntry数组</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] newTable =</span><br><span class="line">        (HashEntry&lt;K,V&gt;[]) <span class="keyword">new</span> HashEntry[newCapacity];</span><br><span class="line">    <span class="comment">//HashEntry[].length - 1 用于计算Hash值</span></span><br><span class="line">    <span class="keyword">int</span> sizeMask = newCapacity - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">        <span class="comment">//遍历旧的HashEntry数组</span></span><br><span class="line">        HashEntry&lt;K,V&gt; e = oldTable[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="comment">//计算出新的HashEntry数组下标</span></span><br><span class="line">            <span class="keyword">int</span> idx = e.hash &amp; sizeMask;</span><br><span class="line">            <span class="comment">//当链表中只有一个元素时，直接将该元素赋值到数组中</span></span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)   <span class="comment">//  Single node on list</span></span><br><span class="line">                newTable[idx] = e;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// Reuse consecutive sequence at same slot</span></span><br><span class="line">                HashEntry&lt;K,V&gt; lastRun = e;</span><br><span class="line">                <span class="keyword">int</span> lastIdx = idx;</span><br><span class="line">                <span class="comment">//该循环的目的是从链表尾部截取出一条与链表末尾节点的新数组下标相同，并且相连的链表</span></span><br><span class="line">                <span class="comment">//并存储该截取链表的头对象到lastRun对象，存储新数组下标到lastIdx中</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; last = next;</span><br><span class="line">                     last != <span class="keyword">null</span>;</span><br><span class="line">                     last = last.next) &#123;</span><br><span class="line">                    <span class="keyword">int</span> k = last.hash &amp; sizeMask;</span><br><span class="line">                    <span class="keyword">if</span> (k != lastIdx) &#123;</span><br><span class="line">                        lastIdx = k;</span><br><span class="line">                        lastRun = last;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//直接移动尾部截取的链表到新的数组下标中</span></span><br><span class="line">                newTable[lastIdx] = lastRun;</span><br><span class="line">                <span class="comment">// Clone remaining nodes</span></span><br><span class="line">                <span class="comment">//重新顺着从原链表头开始遍历，遍历到lastRun，也就是链表截取处时，跳出循环</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">                    V v = p.value;</span><br><span class="line">                    <span class="keyword">int</span> h = p.hash;</span><br><span class="line">                    <span class="keyword">int</span> k = h &amp; sizeMask;</span><br><span class="line">                    HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">                    <span class="comment">//采用头插法讲一个个元素分别插入到链表头中，并赋值给HashEntry数组</span></span><br><span class="line">                    newTable[k] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(h, p.key, v, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对原链表扩容完成之后，计算新的HashEntry的下标</span></span><br><span class="line">    <span class="keyword">int</span> nodeIndex = node.hash &amp; sizeMask; <span class="comment">// add the new node</span></span><br><span class="line">    <span class="comment">//替换链表头</span></span><br><span class="line">    node.setNext(newTable[nodeIndex]);</span><br><span class="line">    <span class="comment">//赋值到HashEntry数组中</span></span><br><span class="line">    newTable[nodeIndex] = node;</span><br><span class="line">    table = newTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、红黑树"><a href="#四、红黑树" class="headerlink" title="四、红黑树"></a>四、红黑树</h1><p>&emsp;&emsp;要讲红黑树，要先讲二叉查找树（Binary Search Tree，简称BST），它是一棵二叉树，它的左子节点的值比父节点的值要小，右节点的值要比父节点的值大。它的高度决定了它的查找效率。在理想的情况下，二叉查找树增删查改的时间复杂度为O(logN)（其中N为节点数），最坏的情况下为O(N)。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1617441217214.png" alt="1617441217214"></p><p>&emsp;&emsp;基于二叉查找树的弊端，就出现了一种新的树——平衡二叉树，平衡二叉树在插入和删除的时候，会通过旋转的操作将高度保持在logN，它的两种最经典的实现就是AVL树和红黑树，而由于AVL树的实现比较复杂且插入和删除效率低，所以在实际环境下的应用不如红黑树。在Java8中由于HashMap使用了红黑树取代链表，所以性能有所提升。</p><h2 id="1、红黑树的定义"><a href="#1、红黑树的定义" class="headerlink" title="1、红黑树的定义"></a>1、红黑树的定义</h2><p>在《算法导论》中对红黑树的定义如下：</p><ol><li>每个节点或是红的，或是黑的；</li><li>根节点是黑的；</li><li>每个叶节点是黑的（注意每一个节点都存在黑色的null节点）；</li><li>如果一个节点是红的，则它的两个儿子都是黑的（父子节点不能出现连个连续的红色结点）；</li><li>对每个节点，从该节点到其子孙节点的所有路径上包含相同数目的黑节点（黑色节点平衡）。</li></ol><h2 id="2、红黑树节点的调整"><a href="#2、红黑树节点的调整" class="headerlink" title="2、红黑树节点的调整"></a>2、红黑树节点的调整</h2><p>&emsp;&emsp;我们假设要插入的节点为N，其父节点为P，其祖父节点为G，其叔叔节点（父亲的兄弟节点）为U。假设其父节点P为黑色，则由于插入的新节点必定为红色节点，所以整棵树就满足红黑树的所有性质，不需要进行调整。但是，当父亲节点P为红色时，则出现连续两个红色节点，则不满足定义4的内容，父子节点不能出现连续的红色节点，所以此时就需要进行调整。</p><p>&emsp;&emsp;那么在调整的时候就会出现以下三种情况：</p><h3 id="2-1、新节点N的叔叔节点U是红色，将父节点和叔叔节点改为黑色，祖父节点G修改为红色"><a href="#2-1、新节点N的叔叔节点U是红色，将父节点和叔叔节点改为黑色，祖父节点G修改为红色" class="headerlink" title="2.1、新节点N的叔叔节点U是红色，将父节点和叔叔节点改为黑色，祖父节点G修改为红色"></a>2.1、新节点N的叔叔节点U是红色，将父节点和叔叔节点改为黑色，祖父节点G修改为红色</h3><p><img src="http://cheng_qiwei.gitee.io/blog/img/1617613492816.png" alt="1617613492816"></p><h3 id="2-2、新节点N的叔叔U是黑色的，且N是左边的孩子，对祖父节点G进行一次右旋转即可"><a href="#2-2、新节点N的叔叔U是黑色的，且N是左边的孩子，对祖父节点G进行一次右旋转即可" class="headerlink" title="2.2、新节点N的叔叔U是黑色的，且N是左边的孩子，对祖父节点G进行一次右旋转即可"></a>2.2、新节点N的叔叔U是黑色的，且N是左边的孩子，对祖父节点G进行一次右旋转即可</h3><p><img src="http://cheng_qiwei.gitee.io/blog/img/1617614066471.png" alt="1617614066471"></p><h3 id="2-3、新节点N的叔叔U是黑色的，且N是右边的孩子，此时对父节点进行一次左旋转，再进行2-2的操作即可"><a href="#2-3、新节点N的叔叔U是黑色的，且N是右边的孩子，此时对父节点进行一次左旋转，再进行2-2的操作即可" class="headerlink" title="2.3、新节点N的叔叔U是黑色的，且N是右边的孩子，此时对父节点进行一次左旋转，再进行2.2的操作即可"></a>2.3、新节点N的叔叔U是黑色的，且N是右边的孩子，此时对父节点进行一次左旋转，再进行2.2的操作即可</h3><p><img src="http://cheng_qiwei.gitee.io/blog/img/1617614877460.png" alt="1617614877460"></p><h1 id="五、JDK1-8-HashMap源码"><a href="#五、JDK1-8-HashMap源码" class="headerlink" title="五、JDK1.8 HashMap源码"></a>五、JDK1.8 HashMap源码</h1><h2 id="1、HashMap1-8版本新增常量"><a href="#1、HashMap1-8版本新增常量" class="headerlink" title="1、HashMap1.8版本新增常量"></a>1、HashMap1.8版本新增常量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当链表长度达到阈值8时，转换成红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="comment">//满足树化的最小数组长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"><span class="comment">//当扩容红黑树拆分链表后判断其数量是否大于6，大于则重组红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><h2 id="2、红黑树存储的对象TreeNode"><a href="#2、红黑树存储的对象TreeNode" class="headerlink" title="2、红黑树存储的对象TreeNode"></a>2、红黑树存储的对象TreeNode</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//父节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    <span class="comment">//左子节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    <span class="comment">//右子节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    <span class="comment">//双向链表的前一个结点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="comment">//颜色</span></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line">    <span class="comment">//继承Node得到，双向链表的下一个结点</span></span><br><span class="line">    <span class="comment">//Node&lt;K,V&gt; next;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TreeNode继承的LinkedHashMap.Entry</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//LinkedHashMap.Entry继承Map.Entry&lt;K,V&gt;</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里parent、left、right、red四个参数是红黑树相关的参数，prev和next两个属性说明TreeNode是一个双向链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里计算Hash值的方法相对于1.7的版本来讲，没有1,7版本那么复杂了，这是因为有了红黑树的保障。</p><h2 id="3、HashMap的put方法"><a href="#3、HashMap的put方法" class="headerlink" title="3、HashMap的put方法"></a>3、HashMap的put方法</h2><p><img src="http://cheng_qiwei.gitee.io/blog/img/9f382ca8fdd5ac711b569b980a6de59e.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    <span class="comment">//对数组初始化或扩容</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//(n - 1) &amp; hash 计算数组下标</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//如果头结点的key等于插入的key，赋值给e</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">//如果P是个红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果P是个链表，HashMap默认</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//使用尾插法插入链表尾部</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//当插入第九个元素（大于8个）时，调用树化方法</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//当插入的数据刚好落在链表中时</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断是否要更新，1.8新加上putIfAbsent的方法，只能插入新的key，如果是重复的key则不插入，并且返回旧值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//自增size后判断是否超过扩容因子（JDK1.7时还有判断当前链表是否有元素）</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在JDK1.7中，采用头插法插入到链表的头部，而在JDK1.8中，采用的是尾插法插入到链表中，并且当链表的数量大于8时，也就是添加第九个元素时，会调用树化方法treeifyBin，根据条件将链表转换成红黑树。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链表树化红黑树</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">//如果当前数组为空 或者 数组长度小于64时</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        <span class="comment">//对数组进行扩容</span></span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//遍历链表</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">//把Node类型转换成红黑树的TreeNode类型</span></span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">//缓存头结点</span></span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//建立双向链表关系</span></span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//hd作为链表的头结点，也是红黑树的根节点，遍历链表把其他数值逐个插入到红黑树中</span></span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/1617632286838.png" alt="1617632286838"></p><p>接下里这里是真正的将链表树化的逻辑，也是红黑树的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; root = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//this（链表的头结点），开始遍历</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">        <span class="comment">//获取链表的下一个结点</span></span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">        <span class="comment">//设置结点左右子结点都是NULL</span></span><br><span class="line">        x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//如果root根节点对象等于null，则赋值root根节点对象，并且变黑色</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            x.parent = <span class="keyword">null</span>;</span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            root = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//新增结点的Key的值</span></span><br><span class="line">            K k = x.key;</span><br><span class="line">            <span class="comment">//新增结点的hash值</span></span><br><span class="line">            <span class="keyword">int</span> h = x.hash;</span><br><span class="line">            <span class="comment">//Key的数据类型</span></span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> dir, ph;</span><br><span class="line">                <span class="comment">//根节点的key值</span></span><br><span class="line">                K pk = p.key;</span><br><span class="line">                <span class="comment">//如果根结点的hash值大于新增结点的hash值，则放在左树上（dir = -1）代表左边</span></span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//否则放在右边</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//如果hash值相同，获取key的数据类型，判断是否实现Comparable接口，则调用实现的compareTo方法</span></span><br><span class="line">                <span class="comment">//如果compareTo还相同或者没实现Compareable接口，则调用tieBreakOrder</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                          (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">//比较getClass().getName() 和 System.identityHashCode</span></span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line">        </span><br><span class="line">                <span class="comment">//一直遍历直到想放的位置没有结点，等于 null</span></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//赋值新节点x的父节点</span></span><br><span class="line">                    x.parent = xp;</span><br><span class="line">                    <span class="comment">//如果左边放左边，如果右边放右边</span></span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    <span class="comment">//执行插入红黑树过程</span></span><br><span class="line">                    root = balanceInsertion(root, x);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把根节点存储到数组中,并且把红黑树的根节点设置成双向链表的根节点</span></span><br><span class="line">    moveRootToFront(tab, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">moveRootToFront</span><span class="params">(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span> &amp;&amp; tab != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; root.hash;</span><br><span class="line">        TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index];</span><br><span class="line">        <span class="keyword">if</span> (root != first) &#123;</span><br><span class="line">            Node&lt;K,V&gt; rn;</span><br><span class="line">            <span class="comment">//把红黑树的根节点赋值在数组上</span></span><br><span class="line">            tab[index] = root;</span><br><span class="line">            <span class="comment">//获取红黑树的根节点在双向链表中的前一个结点rp</span></span><br><span class="line">            TreeNode&lt;K,V&gt; rp = root.prev;</span><br><span class="line">            <span class="comment">//如果红黑树根节点在双线链表中的下一个结点rn不为空</span></span><br><span class="line">            <span class="keyword">if</span> ((rn = root.next) != <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//下一个结点的prev指向rp（等于跳过了root）</span></span><br><span class="line">                ((TreeNode&lt;K,V&gt;)rn).prev = rp;</span><br><span class="line">            <span class="comment">//如果上一个结点rp不为空，它的next指向rn（等于跳过了root）</span></span><br><span class="line">            <span class="keyword">if</span> (rp != <span class="keyword">null</span>)</span><br><span class="line">                rp.next = rn;</span><br><span class="line">            <span class="comment">//如果原数组中的存储的链表头结点不为空，则通过头插法，把root插入到first之上</span></span><br><span class="line">            <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">                first.prev = root;</span><br><span class="line">            root.next = first;</span><br><span class="line">            root.prev = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当插入一个新的节点时，该下标位置的数组为红黑树，则使用以下逻辑插入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">            dir = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">            dir = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                  (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                 (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                searched = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//查找key是否属于红黑树中</span></span><br><span class="line">                <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                     (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                    ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                     (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">            &#125;</span><br><span class="line">            dir = tieBreakOrder(k, pk);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">        <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">            TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">            <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                xp.left = x;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                xp.right = x;</span><br><span class="line">            xp.next = x;</span><br><span class="line">            x.parent = x.prev = xp;</span><br><span class="line">            <span class="keyword">if</span> (xpn != <span class="keyword">null</span>)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">            moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1、红黑树的插入逻辑"><a href="#3-1、红黑树的插入逻辑" class="headerlink" title="3.1、红黑树的插入逻辑"></a>3.1、红黑树的插入逻辑</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  红黑树的插入逻辑</span></span><br><span class="line"><span class="comment">  @Params</span></span><br><span class="line"><span class="comment">  root 根节点</span></span><br><span class="line"><span class="comment">  x即将插入的结点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//新节点默认为红色</span></span><br><span class="line">    x.red = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//xp表示父节点，xpp表示x的祖父节点，xppl表示xpp的左孩子结点，xppr表示xpp的右孩子结点</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line">        <span class="comment">//如果x没有父节点，则表示x是第一个结点，自动成为根节点，根节点为黑色</span></span><br><span class="line">        <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果父节点是黑色的，不需要做调整</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">//上面逻辑已经处理了父节点是黑色的情况，所以下面的逻辑父节点一定是红色的</span></span><br><span class="line">        <span class="comment">//当新节点的父节点是xpp的左叶子节点时</span></span><br><span class="line">        <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;</span><br><span class="line">            <span class="comment">//叔叔节点不为空 且 叔叔节点等于红色（2.1的调整方式）</span></span><br><span class="line">            <span class="keyword">if</span> ((xppr = xpp.right) != <span class="keyword">null</span> &amp;&amp; xppr.red) &#123;</span><br><span class="line">                <span class="comment">//叔叔节点变黑色</span></span><br><span class="line">                xppr.red = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">//父节点变黑色</span></span><br><span class="line">                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">//祖父节点变红色</span></span><br><span class="line">                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//子树调整完成，可能需要递归调整，把祖父节点赋值给x，递归调整</span></span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//进入else语句 叔叔节点为空或者等于黑色</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//当新节点落在父节点的右边时（2.3的调整方式）</span></span><br><span class="line">                <span class="keyword">if</span> (x == xp.right) &#123;</span><br><span class="line">                    root = rotateLeft(root, x = xp);</span><br><span class="line">                    <span class="comment">//重新赋值xp 和xpp的值</span></span><br><span class="line">                    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果xp（也就是之前插入的新节点）不为null（2.2的调整方式）</span></span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//把xp变成黑色</span></span><br><span class="line">                    xp.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">//祖父节点不为null时，变成红色</span></span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="comment">//进行右旋</span></span><br><span class="line">                        root = rotateRight(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//当新节点的父节点是xpp的右叶子节点，且它的叔叔节点不为空且红色</span></span><br><span class="line">            <span class="keyword">if</span> (xppl != <span class="keyword">null</span> &amp;&amp; xppl.red) &#123;</span><br><span class="line">                xppl.red = <span class="keyword">false</span>;</span><br><span class="line">                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == xp.left) &#123;</span><br><span class="line">                    root = rotateRight(root, x = xp);</span><br><span class="line">                    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    xp.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                        root = rotateLeft(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2、HashMap的扩容和红黑树的扩容"><a href="#3-2、HashMap的扩容和红黑树的扩容" class="headerlink" title="3.2、HashMap的扩容和红黑树的扩容"></a>3.2、HashMap的扩容和红黑树的扩容</h3><h4 id="3-2-1、HashMap的扩容"><a href="#3-2-1、HashMap的扩容" class="headerlink" title="3.2.1、HashMap的扩容"></a>3.2.1、HashMap的扩容</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">//扩容，长度左移，相当于原来长度翻倍</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//新数组的大小乘以扩容因子</span></span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">//如果老数组不为空，也就是扩容逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//如果链表上只有一个元素，直接移动过去并且赋值到数组中</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">//如果数组上的是红黑树</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="comment">//如果是链表，则先计算链表中的，应该落在原Index或者新Index（原index+原数组size）的</span></span><br><span class="line">                    <span class="comment">//拆分成两个链表，分别塞到数组两个下标中</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">//hash值和原数组长度相与，等于0原数组</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">//赋值低位index的头结点</span></span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                <span class="comment">//链接低位index的结点</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            <span class="comment">//更新末尾结点</span></span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                             <span class="comment">//赋值高位index的头结点</span></span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                <span class="comment">//链接高位index的结点</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            <span class="comment">//更新末尾结点</span></span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//链表赋值到数组的低位index中</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                     <span class="comment">//链表赋值到数组的高位index中</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里普通数组进行扩容，是将原来的链表通过计算新的Hash值之后，存到两个新的链表上面，再重新设置到新数组的两个对应新位置上，通过上面的说明，新的两个链表只会是原链表的相应位置以及该位置再加上原数组长度的对应位置上。</p><h4 id="3-2-2、红黑树的扩容"><a href="#3-2-2、红黑树的扩容" class="headerlink" title="3.2.2、红黑树的扩容"></a>3.2.2、红黑树的扩容</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//数组上的红黑树根节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; b = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// Relink into lo and hi lists, preserving order</span></span><br><span class="line">    TreeNode&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//遍历红黑树的双向链表</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="keyword">null</span>; e = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)e.next;</span><br><span class="line">        e.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">            loTail = e;</span><br><span class="line">            <span class="comment">//计数低位index的链表的个数</span></span><br><span class="line">            ++lc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">            hiTail = e;</span><br><span class="line">            <span class="comment">//计数高位index的链表的个数</span></span><br><span class="line">            ++hc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//拆分成两个链表之后，比较</span></span><br><span class="line">    <span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果链表长度&lt;=6</span></span><br><span class="line">        <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            <span class="comment">//退化成链表赋值到数组中</span></span><br><span class="line">            tab[index] = loHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//当hiHead == null时，则等于红黑树不需要拆分，直接把整棵树（也就是根节点）移动到数组上</span></span><br><span class="line">            tab[index] = loHead;</span><br><span class="line">            <span class="comment">//hiHead不为空时，对低位链表进行树化，整个链表重新创建红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) <span class="comment">// (else is already treeified)</span></span><br><span class="line">                loHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以下逻辑和低位链表逻辑相同</span></span><br><span class="line">    <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            <span class="comment">//新数组下标 = 原数组下标 + 原数组长度</span></span><br><span class="line">            tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index + bit] = hiHead;</span><br><span class="line">            <span class="keyword">if</span> (loHead != <span class="keyword">null</span>)</span><br><span class="line">                hiHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;红黑树的扩容逻辑是：首先的部分和链表相似，先遍历整颗红黑树，并向链表一样分成两个链表，这时会出现几种情况，如果1号链表的元素数量小于红黑树的最小值，那么首先说明两个链表都分到元素，才会导致原来红黑树的元素数量不足的情况，此时就需要进行树的退化，其次，如果元素的数量达到红黑树的最小值且另一个数组为空，那么说明整个红黑树都在该位置，那么此时将原红黑树（根节点）整个移植过来即可，否则再去重新创建新的红黑树。</p><h3 id="3-3、红黑树的退化"><a href="#3-3、红黑树的退化" class="headerlink" title="3.3、红黑树的退化"></a>3.3、红黑树的退化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历双向链表，把TreeNode类型转换成Node类型，建立单向链表，返回头结点</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">untreeify</span><span class="params">(HashMap&lt;K,V&gt; map)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt; q = <span class="keyword">this</span>; q != <span class="keyword">null</span>; q = q.next) &#123;</span><br><span class="line">        Node&lt;K,V&gt; p = map.replacementNode(q, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">            hd = p;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tl.next = p;</span><br><span class="line">        tl = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、HashMap的get方法"><a href="#4、HashMap的get方法" class="headerlink" title="4、HashMap的get方法"></a>4、HashMap的get方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            <span class="comment">//如果刚好等于根节点，返回</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果它是红黑树，则调用红黑树的查找算法</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">//否则循环链表查找</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">getTreeNode</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>).find(h, k, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* h: get的Key的hash值</span></span><br><span class="line"><span class="comment">* k: get的key</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> ph, dir; K pk;</span><br><span class="line">        TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;</span><br><span class="line">        <span class="comment">//判断hash在左边</span></span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">            p = pl;</span><br><span class="line">        <span class="comment">//在右边</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">            p = pr;</span><br><span class="line">        <span class="comment">//相等且key相同，返回节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="comment">//如果左边等于null直接找右边</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="keyword">null</span>)</span><br><span class="line">            p = pr;</span><br><span class="line">        <span class="comment">//如果右边等于null直接找右边</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="keyword">null</span>)</span><br><span class="line">            p = pl;</span><br><span class="line">        <span class="comment">//如果key自定义了比较算法，compare之类的判断走哪一边</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="keyword">null</span> ||</span><br><span class="line">                  (kc = comparableClassFor(k)) != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">                 (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)</span><br><span class="line">            p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line">        <span class="comment">//否则递归查询</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> q;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = pl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="六、JDK1-8-ConcurrentHashMap源码"><a href="#六、JDK1-8-ConcurrentHashMap源码" class="headerlink" title="六、JDK1.8 ConcurrentHashMap源码"></a>六、JDK1.8 ConcurrentHashMap源码</h1><h2 id="1、ConcurrentHashMap新增的常量"><a href="#1、ConcurrentHashMap新增的常量" class="headerlink" title="1、ConcurrentHashMap新增的常量"></a>1、ConcurrentHashMap新增的常量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示当前的整个ConcurrentHashMap正在扩容</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVED     = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">//创建数组时用于Cas操作，设置成 -1 则代表CAS操作成功，然后创建数组，计算扩容的阈值并赋值到sizeCtl上</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ConcurrentHashMap中元素的最大值 2的31次方</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当扩容数组时，待迁移的数组长度值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> transferIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储扩容时的数组，用以迁移新旧数据</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br></pre></td></tr></table></figure><h2 id="2、size方法"><a href="#2、size方法" class="headerlink" title="2、size方法"></a>2、size方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> n = sumCount();</span><br><span class="line">    <span class="keyword">return</span> ((n &lt; <span class="number">0L</span>) ? <span class="number">0</span> :</span><br><span class="line">            (n &gt; (<span class="keyword">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">            (<span class="keyword">int</span>)n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//baseCount + CounterCell[] 的数据，累加起来就是总的Size</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">sumCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line">    <span class="keyword">long</span> sum = baseCount;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在插入数据后，需要对数组长度+1，此时，并不是只通过一个字段（baseCount）来记录元素的个数，而是一个CounterCell数组（如图），首先他会向baseCount进行一次+1请求，请求成功则结束，如果请求失败，则通过产生一个随机数去&amp;上这个CounterCell数组的length-1来计算出这次的+1操作应该放入哪个对象，然后通过cas自旋来对+1，这样子就可以保证在多线程的情况下可以快速完成元素+1的操作。所以在获取ConcurrentHashMap的元素个数时，其实是获取CounterCell数组中每一个CounterCell元素的值的总和加上baseCount。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1617720237968.png" alt="1617720237968"></p><h2 id="3、put方法"><a href="#3、put方法" class="headerlink" title="3、put方法"></a>3、put方法</h2><p>&emsp;&emsp;首先，ConcurrentHashMap中，红黑树是保存一个<font color='red'><code>TreeBin</code></font>对象，<font color='red'><code>TreeBin</code></font>用于承载红黑树的整个结构，其中有一个<code>root</code>属性用于存储红黑树的根节点。这样做的目的是为了后面对红黑树根节点加锁时，直接对<font color='red'><code>TreeBin</code></font>对象加锁，可以不用考虑在加锁的过程中，红黑树的根节点发生旋转而变化的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把整个红黑树结构封在TreeBin对象中</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeBin</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//红黑树的根节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; root;</span><br><span class="line">    <span class="keyword">volatile</span> TreeNode&lt;K,V&gt; first;</span><br><span class="line">    <span class="keyword">volatile</span> Thread waiter;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> lockState;</span><br><span class="line">    <span class="comment">// values for lockState</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WRITER = <span class="number">1</span>; <span class="comment">// set while holding write lock</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WAITER = <span class="number">2</span>; <span class="comment">// set when waiting for write lock</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> READER = <span class="number">4</span>; <span class="comment">// increment value for setting read lock</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// key和value不能为NULL</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// key所对应的hashcode</span></span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过自旋的方式来插入数据</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">// 如果数组为空，则初始化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">// 算出数组下标，然后获取数组上对应下标的元素，如果为null，则通过cas来赋值</span></span><br><span class="line">        <span class="comment">// 如果赋值成功，则退出自旋，否则是因为数组上当前位置已经被其他线程赋值了，</span></span><br><span class="line">        <span class="comment">// 所以失败，所以进入下一次循环后就不会再符合这个判断了</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果数组当前位置的元素的hash值等于MOVED，表示正在进行扩容，当前线程也帮助进行扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 对数组当前位置的元素进行加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">// 加锁后检查一下tab[i]上的元素是否发生了变化，如果发生了变化则直接进入下一次循环</span></span><br><span class="line">                <span class="comment">// 如果没有发生变化，则开始插入新key,value</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">// 如果tab[i]的hashcode是大于等于0的，那么就将元素插入到链表尾部</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>; <span class="comment">// binCount表示当前链表上节点的个数，不包括新节点</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">// 遍历链表的过程中比较key是否存在一样的</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="comment">// 插入到尾节点</span></span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果tab[i]是TreeBin类型，表示tab[i]位置是一颗红黑树</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 在新插入元素的时候，如果不算这个新元素链表上的个数大于等于8了，那么就要进行树化</span></span><br><span class="line">                <span class="comment">// 比如binCount为8，那么此时tab[i]上的链表长度为9，因为包括了新元素</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="comment">// 存在key相同的元素</span></span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化数组</span></span><br><span class="line"><span class="comment">// 一个线程在put时如果发现tab是空的，则需要进行初始化</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// sizeCtl默认等于0，如果为-1表示有其他线程正在进行初始化，本线程不竞争CPU</span></span><br><span class="line">        <span class="comment">// yield表示放弃CPU，线程重新进入就绪状态，重新竞争CPU，如果竞争不到就等，如果竞争到了又继续循环</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="comment">// 通过cas将sizeCtl改为-1，如果改成功了则进行后续操作</span></span><br><span class="line">        <span class="comment">// 如果没有成功，则表示有其他线程在进行初始化或已经把数组初始化好了</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 当前线程将sizeCtl改为-1后，再一次判断数组是否为空</span></span><br><span class="line">                <span class="comment">// 会不会存在一个线程进入到此处之后，数组不为空了？</span></span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果在构造ConcurrentHashMap时指定了数组初始容量，那么sizeCtl就为初始化容量</span></span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">// 如果n为16，那么就是16-4=12</span></span><br><span class="line">                    <span class="comment">// sc = 3*n/4 = 0.75n, 初始化完成后sizeCtl的数字表示扩容的阈值</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 此时sc为阈值</span></span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由链表树化成红黑树的操作</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; b; <span class="keyword">int</span> n, sc;</span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            tryPresize(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((b = tabAt(tab, index)) != <span class="keyword">null</span> &amp;&amp; b.hash &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//树化前加锁链表头结点</span></span><br><span class="line">            <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, index) == b) &#123;</span><br><span class="line">                    TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">//改成双向链表</span></span><br><span class="line">                    <span class="keyword">for</span> (Node&lt;K,V&gt; e = b; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; p =</span><br><span class="line">                            <span class="keyword">new</span> TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class="line">                                              <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> ((p.prev = tl) == <span class="keyword">null</span>)</span><br><span class="line">                            <span class="comment">//链表头结点</span></span><br><span class="line">                            hd = p;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            tl.next = p;</span><br><span class="line">                        tl = p;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//通过TreeBin的构造方法创建红黑树并赋值到数组上</span></span><br><span class="line">                    setTabAt(tab, index, <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hd));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先通过CAS更新baseCount（+1）</span></span><br><span class="line">    <span class="comment">// 如果更新失败则通过CAS更新CELLVALUE</span></span><br><span class="line">    <span class="comment">// 如果仍然失败则调用fullAddCount</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// as是一个CounterCell数组，一个CounterCell对象表示一个计数器，</span></span><br><span class="line">    <span class="comment">// 多个线程在添加元素时，手写都会尝试去更新baseCount，那么只有一个线程能更新成功，另外的线程将更新失败</span></span><br><span class="line">    <span class="comment">// 那么其他的线程就利用一个CounterCell对象来记一下数</span></span><br><span class="line">    CounterCell[] as; <span class="keyword">long</span> b, s;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</span><br><span class="line">        !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        <span class="comment">// 某个线程更新baseCount失败了</span></span><br><span class="line">        CounterCell a; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 如果CounterCell[]是null</span></span><br><span class="line">        <span class="comment">// 或者CounterCell[]不为null的情况下CounterCell[]的长度小于1也就是等于0，</span></span><br><span class="line">        <span class="comment">// 或者CounterCell[]长度不为0的情况下随机计算一个CounterCell[]的下标，并判断此下标位置是否为空</span></span><br><span class="line">        <span class="comment">// 或者CounterCell[]中的某下标位置不为null的情况下通过cas修改CounterCell中的值失败了</span></span><br><span class="line">        <span class="comment">// 才调用fullAddCount方法，然后返回</span></span><br><span class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">            !(uncontended =</span><br><span class="line">              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果修改CELLVALUE成功了，这里的check就是binCount，这里为什么要判断小于等于1</span></span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果修改CELLVALUE成功了，则统计ConcurrentHashMap的元素个数</span></span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果元素个数大于等于了阈值或-1就自旋扩容</span></span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">// resizeStamp这个方法太难理解，反正就是返回一个数字，比如n=16,rs则=32795</span></span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">            <span class="comment">// 如果sc小于0,表示已经有其他线程在进行扩容了，sc+1</span></span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果全部元素已经转移完了，或者已经达到了最大并发扩容数限制则breack</span></span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 如果没有，则sizeCtl加1，然后进行转移元素</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果sc是大于0的并且如果修改sizeCtl为一个特定的值，比如n=16, rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2= -2145714174</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                <span class="comment">// 转移元素，转移完了之后继续进入循环中</span></span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//扩容的方法，这里的扩容方式是从右边向左边扩容，每个线程依次去扩容步长长度的数据进行扩容</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// stride表示步长，步长最小为16，如果CPU只有一核，那么步长为n</span></span><br><span class="line">    <span class="comment">// 既如果只有一个cpu,那么只有一个线程来进行扩容</span></span><br><span class="line">    <span class="comment">// 步长代表一个线程负责转移的桶的个数</span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 新数组初始化，长度为两倍</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        <span class="comment">// 因为是两倍扩容，相当于两个老数组结合成了一个新数组，transferIndex表示第二个小数组的第一个元素的下标</span></span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新数组的长度</span></span><br><span class="line">    <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// advance为true时，当前桶是否已经迁移完成，如果迁移完成则开始处理下一个桶</span></span><br><span class="line">    <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 是否完成</span></span><br><span class="line">    <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开始转移一个步长内的元素，i表示</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="comment">// i先减1,如果减完之后小于bound，那么继续转移</span></span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// transferIndex</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 通过cas来修改TRANSFERINDEX，如果修改成功则对bound和i进行赋值</span></span><br><span class="line">            <span class="comment">// 第一循环将进入到这里，来赋值bound和i</span></span><br><span class="line">            <span class="comment">// nextIndex就是transferIndex，假设为16，假如步长为4，那么就分为4个组，每组4个桶</span></span><br><span class="line">            <span class="comment">// 0-3,4-7,8-11,12-15</span></span><br><span class="line">            <span class="comment">// nextBound = 16-4=12</span></span><br><span class="line">            <span class="comment">// i=16-1=15</span></span><br><span class="line">            <span class="comment">// 所以bound表示一个步长里的最小的下标，i表示一个步长里的最大下标</span></span><br><span class="line">            <span class="comment">// TRANSFERINDEX是比较重要的，每个线程在进行元素的转移之前需要确定当前线程从哪个位置开始（从后往前）</span></span><br><span class="line">            <span class="comment">// TRANSFERINDEX每次减掉一个步长，所以当下一个线程准备转移元素时就可以从最新的TRANSFERINDEX开始了</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果没有修改成功则继续循环</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                     (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// i表示一个步长里的最大下标, 如果i小于或者大于等于老数组长度，或者下标+老数组长度大于等等新数组长度</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="keyword">int</span> sc;</span><br><span class="line">            <span class="comment">// 转移完成</span></span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                nextTable = <span class="keyword">null</span>;</span><br><span class="line">                table = nextTab;</span><br><span class="line">                <span class="comment">// sizeCtl = 1.5n  = 2n*0.75</span></span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 每个线程负责的转移任务结束后利用cas来对sizeCtl减1</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">// 当前线程负责的任务做完了，同时还有其他线程还在做任务，则回到上层重新申请任务来做</span></span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                <span class="comment">// 当前线程负责的任务做完了，也没有其他线程在做任务了，那么则表示扩容结束了</span></span><br><span class="line">                finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从i位置开始转移元素</span></span><br><span class="line">        <span class="comment">// 如果老数组的i位置元素为null,则表示该位置上的元素已经被转移完成了，</span></span><br><span class="line">        <span class="comment">// 则通过cas设置为ForwardingNode，表示无需转移</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">            advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">        <span class="comment">// 如果i位置已经是ForwardingNode，则跳过该位置（就是桶）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 加锁，开始转移</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">// 加锁完了之后再次检查一遍tab[i]是否发生了变化</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    <span class="comment">// fh大于等于0表示是链表</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// n是老数组的长度</span></span><br><span class="line">                        <span class="comment">// 因为n是2的幂次方数，所以runbit只有两种结果:0和n</span></span><br><span class="line">                        <span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 遍历链表，lastRun为当前链表上runbit连续相同的一小段的最后一段</span></span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 如果最后一段的runBit为0，则则该段应该保持在当前位置</span></span><br><span class="line">                        <span class="comment">// 否则应该设置到i+n位置</span></span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//从头节点开始，遍历链表到lastRun结束</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                            <span class="comment">// 如果ph &amp; n，则将遍历到的节点插入到ln的前面</span></span><br><span class="line">                            <span class="comment">// 否则将遍历到的节点插入到hn的前面</span></span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 将ln链表赋值在新tab的i位置</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        <span class="comment">// 将hn链表赋值在新tab的i+n位置</span></span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        <span class="comment">// 这是老tab的i位置ForwardingNode节点，表示转移完成</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                            (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                            (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记录当前数组的元素个数的方法，采用的是baseCount+CounterCell[]数组的计算方式</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">fullAddCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">boolean</span> wasUncontended)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">if</span> ((h = ThreadLocalRandom.getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">        ThreadLocalRandom.localInit();      <span class="comment">// force initialization</span></span><br><span class="line">        h = ThreadLocalRandom.getProbe();</span><br><span class="line">        wasUncontended = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">boolean</span> collide = <span class="keyword">false</span>;                <span class="comment">// True if last slot nonempty</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        CounterCell[] as; CounterCell a; <span class="keyword">int</span> n; <span class="keyword">long</span> v;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果counterCells不等于空</span></span><br><span class="line">        <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// h可以理解为当前线程的hashcode，如果对应的counterCells数组下标位置元素当前是空的</span></span><br><span class="line">            <span class="comment">// 那么则应该在该位置去生成一个CounterCell对象</span></span><br><span class="line">            <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// counterCells如果空闲</span></span><br><span class="line">                <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;            <span class="comment">// Try to attach new Cell</span></span><br><span class="line">                    <span class="comment">// 生成CounterCell对象</span></span><br><span class="line">                    CounterCell r = <span class="keyword">new</span> CounterCell(x); <span class="comment">// Optimistic create</span></span><br><span class="line">                    <span class="comment">// 再次判断counterCells如果空闲，并且cas成功修改cellsBusy为1</span></span><br><span class="line">                    <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                        <span class="keyword">boolean</span> created = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">try</span> &#123;               <span class="comment">// Recheck under lock</span></span><br><span class="line">                            CounterCell[] rs; <span class="keyword">int</span> m, j;</span><br><span class="line">                            <span class="comment">// 如果counterCells对象没有发生变化，那么就将刚刚创建的CounterCell赋值到数组中</span></span><br><span class="line">                            <span class="keyword">if</span> ((rs = counterCells) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                                (m = rs.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                rs[j] = r;</span><br><span class="line">                                <span class="comment">// 便是CounterCell创建成功</span></span><br><span class="line">                                created = <span class="keyword">true</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            cellsBusy = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 如果CounterCell创建成功，则退出循环，方法执行结束</span></span><br><span class="line">                        <span class="keyword">if</span> (created)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 如果没有创建成功，则继续循环</span></span><br><span class="line">                        <span class="keyword">continue</span>;           <span class="comment">// Slot is now non-empty</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 应该当前位置为空，所以肯定没有发生碰撞</span></span><br><span class="line">                collide = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果当前位置不为空，则进入以下分支判断</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果调用当前方法之前cas失败了，那么先将wasUncontended设置为true，</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)       <span class="comment">// CAS already known to fail</span></span><br><span class="line">                wasUncontended = <span class="keyword">true</span>;      <span class="comment">// Continue after rehash</span></span><br><span class="line">            <span class="comment">// 通过cas修改CELLVALUE的值，修改成功则退出循环，修改失败则继续进行分支判断</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// counterCells发生了改变，或者当前counterCells数组的大小大于等于CPU核心数，设置collide为false，</span></span><br><span class="line">            <span class="comment">// 如果到了这个极限，counterCells不会再进行扩容了</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (counterCells != as || n &gt;= NCPU)</span><br><span class="line">                collide = <span class="keyword">false</span>;            <span class="comment">// At max size or stale</span></span><br><span class="line">            <span class="comment">// 一旦走到这个分支了，那么就是发生了碰撞了，一个当前这个位置不为空</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">                collide = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 当collide为true进入这个分支，表示发生了碰撞会进行扩容</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 对counterCells进行扩容</span></span><br><span class="line">                    <span class="keyword">if</span> (counterCells == as) &#123;<span class="comment">// Expand table unless stale</span></span><br><span class="line">                        CounterCell[] rs = <span class="keyword">new</span> CounterCell[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                            rs[i] = as[i];</span><br><span class="line">                        counterCells = rs;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    cellsBusy = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">continue</span>;                   <span class="comment">// Retry with expanded table</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 重新进行hash</span></span><br><span class="line">            h = ThreadLocalRandom.advanceProbe(h);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果counterCells等于空的情况下会走下面两个分支</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// cellsBusy == 0表示counterCells没有线程在用</span></span><br><span class="line">        <span class="comment">// 如果counterCells空闲，并且当前线程所获得counterCells对象没有发生变化</span></span><br><span class="line">        <span class="comment">// 先通过CAS将cellsBusy标记改为1，如果修改成功则证明可以操作counterCells了，</span></span><br><span class="line">        <span class="comment">// 其他线程暂时不能使用counterCells</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; counterCells == as &amp;&amp;</span><br><span class="line">                 U.compareAndSwapInt(<span class="keyword">this</span>, CELLSBUSY, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> init = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;                           <span class="comment">// Initialize table</span></span><br><span class="line">                <span class="comment">// cellsBusy标记改成后就初始化CounterCell[]</span></span><br><span class="line">                <span class="keyword">if</span> (counterCells == as) &#123;</span><br><span class="line">                    CounterCell[] rs = <span class="keyword">new</span> CounterCell[<span class="number">2</span>];</span><br><span class="line">                    <span class="comment">// 并且把x赋值到CounterCell中完成计数</span></span><br><span class="line">                    rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> CounterCell(x);</span><br><span class="line">                    counterCells = rs;</span><br><span class="line">                    init = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                cellsBusy = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没有初始化成功，则证明counterCells发生了变化，当前线程修改cellsBusy的过程中，</span></span><br><span class="line">            <span class="comment">// 可能其他线程已经把counterCells对象替换掉了</span></span><br><span class="line">            <span class="comment">// 如果初始化成功，则退出循环，方法执行结束</span></span><br><span class="line">            <span class="keyword">if</span> (init)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, v = baseCount, v + x))</span><br><span class="line">            <span class="keyword">break</span>;                          <span class="comment">// Fall back on using base</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashMap </tag>
            
            <tag> ConCurrentHashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud Gateway介绍及使用</title>
      <link href="/blog/2021/03/31/SpringCloud%20Gateway/"/>
      <url>/blog/2021/03/31/SpringCloud%20Gateway/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringCloud-Gateway介绍及使用"><a href="#SpringCloud-Gateway介绍及使用" class="headerlink" title="SpringCloud Gateway介绍及使用"></a>SpringCloud Gateway介绍及使用</h1><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>&emsp;&emsp;SpringCloud Gateway 是 Spring Cloud 的一个全新项目，该项目是基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式。</p><p>&emsp;&emsp;在之前，SpringCloud本身就有集成zuul网关，为什么还需要开发新的SpringCloudGateway？我们可以从SpringCloud中发现，虽然现在zuul网关已经出到2.x的版本，但SpringCloud目前还是只支持到zuul 1.x的版本，这是因为之前Zuul 2.x 的不断跳票，SpringCloud 才釜底抽薪推出了自己的服务网关。</p><h1 id="API网关"><a href="#API网关" class="headerlink" title="API网关"></a>API网关</h1><p>&emsp;&emsp;API网关是一个服务器，是系统的唯一入口。从面向对象设计的角度看，它与外观模式类似。API网关封装了系统内部架构，为每个客户端提供一个定制的API。它可能还具有其它职责，如身份验证、监控、负载均衡、缓存、请求分片与管理、静态响应处理。API网关方式的核心要点是，所有的客户端和消费端都通过统一的网关接入微服务，在网关层处理所有的非业务功能。通常，网关也是提供REST/HTTP的访问API。<br>网关需要具备的功能：</p><p>&emsp;性能：API高可用，负载均衡，容错机制。</p><p>&emsp;安全：权限身份认证、脱敏，流量清洗，后端签名（保证全链路可信调用）,黑名单（非法调用的限制）。</p><p>&emsp;日志：日志记录（spainid,traceid）一旦涉及分布式，全链路跟踪必不可少。</p><p>&emsp;缓存：数据缓存。</p><p>&emsp;监控：记录请求响应数据，api耗时分析，性能监控。</p><p>&emsp;限流：流量控制，错峰流控，可以定义多种限流规则。</p><p>&emsp;灰度：线上灰度部署，可以减小风险。</p><p>&emsp;路由：动态路由规则。</p><h1 id="SpringCloudGateway"><a href="#SpringCloudGateway" class="headerlink" title="SpringCloudGateway"></a>SpringCloudGateway</h1><p>SpringCloud官方对SpringCloud Gateway 特征介绍如下：</p><p>&emsp;a、基于 Spring Framework 5，Project Reactor 和 Spring Boot 2.0</p><p>&emsp;b、集成 Hystrix 断路器</p><p>&emsp;c、集成 Spring Cloud DiscoveryClient</p><p>&emsp;d、Predicates 和 Filters 作用于特定路由，易于编写的 Predicates 和 Filters</p><p>&emsp;e、具备一些网关的高级功能：动态路由、限流、路径重写</p><p>简单说明一下上文中的三个术语：</p><p>&emsp;a、Filter（过滤器）：和Zuul的过滤器在概念上类似，可以使用它拦截和修改请求，并且对上游的响应，进行二次处理。过滤器为org.springframework.cloud.gateway.filter.GatewayFilter类的实例。</p><p>&emsp;b、Route（路由）：网关配置的基本组成模块，和Zuul的路由配置模块类似。一个Route模块由一个 ID，一个目标 URI，一组断言和一组过滤器定义。如果断言为真，则路由匹配，目标URI会被访问。</p><p>&emsp;c、Predicate（断言）：这是一个 Java 8 的 Predicate，可以使用它来匹配来自 HTTP 请求的任何内容，例如 headers 或参数。断言的输入类型是一个 ServerWebExchange。</p><p>&emsp;&emsp;从以上的特征来说，和SpringCloud Zuul的特征差别不大。但其实SpringCloud Gateway和SpringCloud Zuul最主要的区别，还是在底层的通信框架上。</p><h2 id="SpringCloud-Gateway和SpringCloud-Zuul（Zuul-1-x）的区别"><a href="#SpringCloud-Gateway和SpringCloud-Zuul（Zuul-1-x）的区别" class="headerlink" title="SpringCloud Gateway和SpringCloud Zuul（Zuul 1.x）的区别"></a>SpringCloud Gateway和SpringCloud Zuul（Zuul 1.x）的区别</h2><h3 id="SpringCloud-Zuul-与Servlet-IO"><a href="#SpringCloud-Zuul-与Servlet-IO" class="headerlink" title="SpringCloud Zuul 与Servlet IO"></a>SpringCloud Zuul 与Servlet IO</h3><p>&emsp;&emsp;Springcloud Zuul，采用的是Tomcat容器，使用的是传统的Servlet IO处理模型。</p><p>&emsp;&emsp;而servlet由servlet容器进行生命周期管理。在容器启动时构造servlet对象并调用servlet init()进行初始化；当容器关闭时调用servlet destory()销毁servlet；容器运行时接受请求，并为每个请求分配一个线程（一般从线程池中获取空闲线程）然后调用service()。</p><p>&emsp;&emsp;弊端：servlet是一个简单的网络IO模型，当请求进入servlet容器时，servlet 容器就会为其绑定一个线程，这在并发不高的场景下这种模型是适用的，但是一旦并发上升，线程数量就会上涨，而线程资源代价是昂贵的（上下文切换，内存消耗大）严重影响请求的处理时间。在一些简单的业务场景下，不希望为每个request分配一个线程，只需要1个或几个线程就能应对极大并发的请求，所以这种业务场景下servlet模型没有优势。</p><p>&emsp;&emsp;总而言之，Springcloud Zuul 是基于servlet之上的一个阻塞式处理模型，即spring实现了处理所有request请求的一个servlet（DispatcherServlet），并由该servlet阻塞式处理处理。所以Springcloud Zuul无法摆脱servlet模型的弊端。</p><p>&emsp;&emsp;当然Zuul官方也发现了这个问题，所以从Zuul 2.0开始，使用了Netty，但是由于之前的一些问题，所以现在SpringCloud官方也没有集成Zuul 2.x的计划了。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/19816137-bb466f6b0135bb71.jpg" alt="19816137-bb466f6b0135bb71"></p><h3 id="SpringCloud-Gateway与Webflux"><a href="#SpringCloud-Gateway与Webflux" class="headerlink" title="SpringCloud Gateway与Webflux"></a>SpringCloud Gateway与Webflux</h3><p>&emsp;&emsp;Spring在2017年下半年迎来了Webflux，Webflux模式替换了旧的Servlet线程模型。用少量的线程处理request和response io操作，这些线程称为Loop线程，而业务交给响应式编程框架处理，响应式编程是非常灵活的，用户可以将业务中阻塞的操作提交到响应式框架的work线程中执行，而不阻塞的操作依然可以在Loop线程中进行处理，大大提高了Loop线程的利用率。所以SpringCloud Gateway 使用的Webflux中的reactor-netty响应式编程组件，解决了SpringCloud Zuul在高并发下的问题。</p><p>&emsp;&emsp;Webflux虽然可以兼容多个底层的通信框架，但是一般情况下，底层使用的还是Netty，毕竟，Netty是目前业界认可的最高性能的通信框架。而Webflux的Loop线程，正好就是著名的Reactor 模式IO处理模型的Reactor线程，如果使用的是高性能的通信框架Netty，这就是Netty的EventLoop线程。</p><h1 id="SpringCloud-GateWay集成Nacos注册中心使用"><a href="#SpringCloud-GateWay集成Nacos注册中心使用" class="headerlink" title="SpringCloud GateWay集成Nacos注册中心使用"></a>SpringCloud GateWay集成Nacos注册中心使用</h1><h2 id="准备一个业务的服务，用于网关进行转发；"><a href="#准备一个业务的服务，用于网关进行转发；" class="headerlink" title="准备一个业务的服务，用于网关进行转发；"></a>准备一个业务的服务，用于网关进行转发；</h2><p>注意要将该服务加入nacos服务注册中那个心。</p><h2 id="新建一个网关微服务"><a href="#新建一个网关微服务" class="headerlink" title="新建一个网关微服务"></a>新建一个网关微服务</h2><h2 id="pom文件配置"><a href="#pom文件配置" class="headerlink" title="pom文件配置"></a>pom文件配置</h2><h3 id="总pom-xml"><a href="#总pom-xml" class="headerlink" title="总pom.xml"></a>总pom.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.g4b.cheng<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>api-system<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>api-gateway<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>Hoxton.SR1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 插件依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="网关pom-xml"><a href="#网关pom-xml" class="headerlink" title="网关pom.xml"></a>网关pom.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.g4b.cheng<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>api-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>网关模块<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<font color='red'>注意：这里要求网关服务不允许出现spring-boot-starter-tomcat和spring-boot-starter-web这两个包，注意去除相关包含这两个包的依赖，同时也不要引入这两个依赖，因为gateway使用的是webflux,默认使用netty。</font></p><h2 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8882</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">api-gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">api-system</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://api-system</span>   <span class="comment">#如果添加了注册中心，可以匹配注册中心后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/api-system/**</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">cn.g4b.cheng:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure><p>这里了解一下几个基本的路由参数：</p><p>&emsp;a、id：是路由的标识，在网关中需要保证唯一，最好和转发的服务名称一致；</p><p>&emsp;b、uri：请求转发后的地址，当将服务和网关都注册到注册中心时，可以使用lb://服务名称 来进行转发，服务名称详见注册中心；</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210318143143177.png" alt="image-20210318143143177"></p><p>&emsp;c、predicates：断言，也叫转发条件；</p><p>&emsp;d、filters：过滤器，对请求进行过滤。</p><h2 id="GatewayApplication-java"><a href="#GatewayApplication-java" class="headerlink" title="GatewayApplication.java"></a>GatewayApplication.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.g4b.cheng;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GatewayApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(GatewayApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="测试原访问路径"><a href="#测试原访问路径" class="headerlink" title="测试原访问路径"></a>测试原访问路径</h3><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210318142520393.png" alt="image-20210318142520393"></p><h3 id="测试网关访问路径"><a href="#测试网关访问路径" class="headerlink" title="测试网关访问路径"></a>测试网关访问路径</h3><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210318142613537.png" alt="image-20210318142613537"></p><p>这样子，简单的进行网关转发即完成了。</p><h1 id="SpringCloud-Gateway网关的断言规则Predicate"><a href="#SpringCloud-Gateway网关的断言规则Predicate" class="headerlink" title="SpringCloud Gateway网关的断言规则Predicate"></a>SpringCloud Gateway网关的断言规则Predicate</h1><p><img src="http://cheng_qiwei.gitee.io/blog/img/4461954-1b814fb4ee7229a2.webp"></p><p>&emsp;&emsp;SpringCloud Gateway提供了相当多的断言的方法，我们可以认为，每一个断言相当于一个条件，当满足这种条件后才会被转发，如果是多个，那就是都满足的情况下被转发（且的关系）。接下来，我们介绍几个比较常用的Predicate</p><h3 id="Path：根据地址进行转发"><a href="#Path：根据地址进行转发" class="headerlink" title="Path：根据地址进行转发"></a>Path：根据地址进行转发</h3><p>&emsp;&emsp;这个匹配是最基本的一个断言规则，只要我的路径匹配了，就进行转发。这里唯一要注意的一个点是：<code>/**</code>   和    <code>/*  </code>并不是一样的。<code>/**</code>匹配的是所有级别的路径，可以是 /A/B/C  也可以是 /A …但是<code>/*</code>只能代表 /A 一级而已.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">Path=/api-system/**</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Path=/api-system/*</span></span><br></pre></td></tr></table></figure><h3 id="Before、After、Between：在什么时间之前、之后、之间进行转发"><a href="#Before、After、Between：在什么时间之前、之后、之间进行转发" class="headerlink" title="Before、After、Between：在什么时间之前、之后、之间进行转发"></a>Before、After、Between：在什么时间之前、之后、之间进行转发</h3><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210318154943534.png" alt="image-20210318154943534"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210318155035308.png" alt="image-20210318155035308"></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">After=2021-03-18T15:50:00+08:00[Asia/Shanghai]</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Before=2021-03-18T15:50:00+08:00[Asia/Shanghai]</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Between=2021-03-18T15:50:00+08:00[Asia/Shanghai],</span> <span class="number">2021-03-18T15:59:00+08:00</span>[<span class="string">Asia/Shanghai</span>]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;我们这里测试After，我们设定在2021-03-18的15:50分钟后，该转发路径才允许访问，所以在此之前，我们访问改接口是无法转发的，当过了50分后，就可以正常转发访问了。</p><h3 id="Cookie：Cookie匹配转发"><a href="#Cookie：Cookie匹配转发" class="headerlink" title="Cookie：Cookie匹配转发"></a>Cookie：Cookie匹配转发</h3><p>&emsp;&emsp;如果请求中所携带的Cookie值与配置的Predicate匹配，那么就可以被允许转发到指定地址，如图，我们设定我们的Cookie的key为winking，值为10086，只有携带该Cookie才能访问我们的子服务。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">Cookie=winking,10086</span></span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210318160846133.png" alt="image-20210318160846133"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210318161017150.png" alt="image-20210318161017150"></p><h3 id="Header：请求头匹配转发"><a href="#Header：请求头匹配转发" class="headerlink" title="Header：请求头匹配转发"></a>Header：请求头匹配转发</h3><p>&emsp;&emsp;如果请求中所携带的Header值与配置的Predicate匹配，那么就可以被允许转发到指定地址，如图，我们设定我们的Header包含X-Request-Id的参数，其值为\d+【这个是正则表达式，指的是必须为数字】，只有携带该Header且值为数字才能访问我们的子服务。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">Header=X-Request-Id,</span> <span class="string">\d+</span></span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210318163234224.png" alt="image-20210318163234224"></p><h3 id="Host：根据Host主机名匹配转发"><a href="#Host：根据Host主机名匹配转发" class="headerlink" title="Host：根据Host主机名匹配转发"></a>Host：根据Host主机名匹配转发</h3><p>&emsp;&emsp;如果请求中所携带的Host主机名与配置的Predicate匹配，那么就可以被允许转发到指定地址，如图，我们设定我们的Host主机名符合**.aliyun.com的规则，只有符合该规则的主机名才能访问我们的子服务。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">Host=**.aliyun.com</span></span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210318164555702.png" alt="image-20210318164555702"></p><h3 id="Method：根据方法类型进行转发"><a href="#Method：根据方法类型进行转发" class="headerlink" title="Method：根据方法类型进行转发"></a>Method：根据方法类型进行转发</h3><p>&emsp;&emsp;Restful请求风格的接口内往往会存在多种请求方式的接口，如果我们的接口只允许某个类型的接口可以访问，可以使用Method来进行断言处理。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">Method=POST</span></span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210318170120998.png" alt="image-20210318170120998"></p><h3 id="Query：根据请求参数进行转发"><a href="#Query：根据请求参数进行转发" class="headerlink" title="Query：根据请求参数进行转发"></a>Query：根据请求参数进行转发</h3><p>&emsp;&emsp;如果请求中所携带的参数与配置的Predicate匹配，那么就可以被允许转发到指定地址，如图，我们设定我们的参数包含user这个参数，只有符合该规则的主机名才能访问我们的子服务。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">Query=user</span>              <span class="comment">#包含user这个参数即可</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Query=user,winking</span>      <span class="comment">#包含user这个参数且值为winking即可</span></span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210318170751465.png" alt="image-20210318170751465"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210318170953057.png" alt="image-20210318170953057"></p><h3 id="RemoteAddr：根据IP地址进行转发"><a href="#RemoteAddr：根据IP地址进行转发" class="headerlink" title="RemoteAddr：根据IP地址进行转发"></a>RemoteAddr：根据IP地址进行转发</h3><p>&emsp;&emsp;我们可以限制允许访问接口的客户端IP地址，配置后只对指定IP地址的客户端进行请求转发。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">RemoteAddr=192.168.2.107</span></span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210318171907454.png" alt="image-20210318171907454"></p><h1 id="SpringCloud-Gateway网关的过滤器Filter"><a href="#SpringCloud-Gateway网关的过滤器Filter" class="headerlink" title="SpringCloud Gateway网关的过滤器Filter"></a>SpringCloud Gateway网关的过滤器Filter</h1><p>&emsp;&emsp;在上一节我们介绍了Gateway的断言Predict，Predict决定了请求由哪一个路由处理，在路由处理前后，我们需要经过各种过滤器filter的处理。在路由处理之前，需要经过“pre”类型的过滤器处理，处理返回响应之后，可以由“post”类型的过滤器处理。“pre”类型的过滤器可以做参数校验、权限校验、流量监控、日志输出、协议转换等功能，而“post”类型的过滤器中可以做响应内容、响应头的修改，日志的输出，流量监控等。</p><p>&emsp;&emsp;filter除了分为“pre”和“post”两种方式的filter外，从作用范围上：一种是针对于单个路由的gateway filter，它在配置文件中的写法同predict类似；另外一种是针对于所有路由的global gateway filer【全局过滤器】。</p><h2 id="gateway-filter"><a href="#gateway-filter" class="headerlink" title="gateway filter"></a>gateway filter</h2><p>&emsp;&emsp;过滤器允许以某种方式修改传入的HTTP请求或传出的HTTP响应。过滤器可以限定作用在某些特定请求路径上。 SpringCloud Gateway包含许多内置的GatewayFilter工厂。</p><p>&emsp;&emsp;GatewayFilter工厂同上Predicate工厂类似，都是在配置文件application.yml中配置，遵循了约定大于配置的思想，只需要在配置文件配置GatewayFilter Factory的名称，而不需要写全部的类名，比如AddRequestHeaderGatewayFilterFactory只需要在配置文件中写AddRequestHeader，而不是全部类名。在配置文件中配置的GatewayFilter Factory最终都会相应的过滤器工厂类处理。</p><p>下图为SpringCloud Gateway内置的过滤器工厂：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/20190601011143809.png"></p><h3 id="AddRequestHeader-GatewayFilter-Factory：添加请求头过滤器工厂"><a href="#AddRequestHeader-GatewayFilter-Factory：添加请求头过滤器工厂" class="headerlink" title="AddRequestHeader GatewayFilter Factory：添加请求头过滤器工厂"></a>AddRequestHeader GatewayFilter Factory：添加请求头过滤器工厂</h3><p>添加相应的请求头参数及值进行转发</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">filters:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">AddRequestHeader=Time,</span> <span class="string">abcd1234</span></span><br></pre></td></tr></table></figure><p>添加测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.g4b.cheng.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.g4b.cheng.entity.ResultVo;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/sysTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SysTestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/getHeaderMessage&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResultVo <span class="title">getHeaderMessage</span> <span class="params">(HttpServletRequest request,HttpServletResponse response)</span></span>&#123;</span><br><span class="line">        String time = request.getHeader(<span class="string">&quot;Time&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(time != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ResultVo.responseSuccess(time);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ResultVo.responseFail(<span class="string">&quot;获取请求头 Time 失败！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210322093749957.png" alt="image-20210322093749957"></p><p>类似方法：AddResponseHeader（在返回时添加响应头）</p><h3 id="RewritePath-GatewayFilter-Factory：修改路径过滤器"><a href="#RewritePath-GatewayFilter-Factory：修改路径过滤器" class="headerlink" title="RewritePath GatewayFilter Factory：修改路径过滤器"></a>RewritePath GatewayFilter Factory：修改路径过滤器</h3><p>在Nginx服务启中有一个非常强大的功能就是重写路径，Spring Cloud Gateway默认也提供了这样的功能，这个功能是Zuul没有的。配置方法如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">filters:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">RewritePath=/nacos/(?&lt;segment&gt;.*),</span> <span class="string">/$\&#123;segment&#125;</span></span><br></pre></td></tr></table></figure><p>这个配置的意思是：将 /nacos/(<code>**</code>) 的路径转换成  /(<code>**</code>) ,去掉前面/nacos的部分。</p><p>测试：现在访问:/api-system/nacos/sysUser/queryUser?userId=2 和 </p>:/api-system/sysUser/queryUser?userId=2 返回相同的结果。<p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210322095454497.png" alt="image-20210322095454497"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210322095547213.png" alt="image-20210322095547213"></p><h3 id="PrefixPath-GatewayFilter-Factory：添加前缀过滤器"><a href="#PrefixPath-GatewayFilter-Factory：添加前缀过滤器" class="headerlink" title="PrefixPath  GatewayFilter Factory：添加前缀过滤器"></a>PrefixPath  GatewayFilter Factory：添加前缀过滤器</h3><p>有些时候，我们的转发路径都携带项目名称作为前缀，有时候我们可以添加在网关中，让网关帮我们填充。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">filters:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">PrefixPath=/api-system</span></span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210322100953788.png" alt="image-20210322100953788"></p><p>测试：我们之前是需要访问:/api-system/sysUser/queryUser?userId=2，现在就只需要访问</p>:/sysUser/queryUser?userId=2即可。<p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210322101032349.png" alt="image-20210322101032349"></p><h2 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h2><p>&emsp;&emsp;SpringCloud Gateway 内置了19种过滤器，能够在各种业务场景中使用，但有时候，有一些场景还是需要去灵活使用过滤器，此时我们可以考虑自定义过滤器。</p><p>目标：自定义一个时间统计过滤器，用来统计每次请求的时长。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.g4b.cheng.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GatewayFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.factory.AbstractGatewayFilterFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.Order;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 统计每个请求的时长</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(2)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DurationGatewayFilterFactory</span> <span class="keyword">extends</span> <span class="title">AbstractGatewayFilterFactory</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> GatewayFilter <span class="title">apply</span><span class="params">(Object config)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (exchange, chain) -&gt; &#123;</span><br><span class="line">            Long startTime = System.currentTimeMillis();</span><br><span class="line">            log.debug(<span class="string">&quot;------进入了Duration过滤器：DurationFilter-----&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange).then(Mono.fromRunnable(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span>(startTime != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    log.info(<span class="string">&quot;请求请求路径为：&#123;&#125;的接口，耗时为：&#123;&#125; ms&quot;</span>,exchange.getRequest().getPath(),System.currentTimeMillis() - startTime);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<font color='red'>这里需要注意，我们所有自定义过滤器的命名最好和官方的过滤器命名一致【XXXGatewayFilterFactory】，否则在用yml调用的时候会出现找不到过滤器的情况。</font></p><p>yml配置：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210322110613300.png" alt="image-20210322110613300"></p><p>测试：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210322110707664.png" alt="image-20210322110707664"></p><h2 id="自定义全局过滤器"><a href="#自定义全局过滤器" class="headerlink" title="自定义全局过滤器"></a>自定义全局过滤器</h2><p>有时候，一些过滤器需要在每一个路由中都使用，那么此时就不需要每个都进行配置，直接写一个全局过滤器即可。</p><p>目标：自定义一个时间参数过滤器，用来打印请求参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.g4b.cheng.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GatewayFilterChain;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GlobalFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.Ordered;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.server.ServerWebExchange;</span><br><span class="line"><span class="keyword">import</span> reactor.core.publisher.Mono;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueryGlobalFilter</span> <span class="keyword">implements</span> <span class="title">GlobalFilter</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;请求请求路径为：&#123;&#125;的接口，请求参数为：&#123;&#125;&quot;</span>,exchange.getRequest().getPath(),exchange.getRequest().getQueryParams().toString());</span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210322113606404.png" alt="image-20210322113606404"></p><h1 id="SpringCloud-Gateway-原理解析"><a href="#SpringCloud-Gateway-原理解析" class="headerlink" title="SpringCloud Gateway 原理解析"></a>SpringCloud Gateway 原理解析</h1><p><img src="http://cheng_qiwei.gitee.io/blog/img/20190703211815129.png"></p><p>&emsp;&emsp;Spring Cloud Gateway 的核心处理流程如下图，Gateway的客户端回向Spring Cloud Gateway发起请求，请求首先会被HttpWebHandlerAdapter进行提取组装成网关的上下文，然后网关的上下文会传递到DispatcherHandler。DispatcherHandler是所有请求的分发处理器，DispatcherHandler主要负责分发请求对应的处理器，比如将请求分发到对应RoutePredicateHandlerMapping(路由断言处理器映射器）。路由断言处理映射器主要用于路由的查找，以及找到路由后返回对应的FilteringWebHandler。FilteringWebHandler主要负责组装Filter链表并调用Filter执行一系列Filter处理，然后把请求转到后端对应的代理服务处理，处理完毕后，将Response返回到Gateway客户端。</p><p>&emsp;&emsp;在Filter链中，通过虚线分割Filter的原因是，过滤器可以在转发请求之前处理或者接收到被代理服务的返回结果之后处理。所有的Pre类型的Filter执行完毕之后，才会转发请求到被代理的服务处理。被代理的服务把所有请求完毕之后，才会执行Post类型的过滤器。</p>]]></content>
      
      
      <categories>
          
          <category> SpringCloud组件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
            <tag> 网关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sentinel的介绍与使用（二）</title>
      <link href="/blog/2021/03/20/Sentinel%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/blog/2021/03/20/Sentinel%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Sentinel的介绍与使用（二）"><a href="#Sentinel的介绍与使用（二）" class="headerlink" title="Sentinel的介绍与使用（二）"></a>Sentinel的介绍与使用（二）</h1><h1 id="热点参数限流"><a href="#热点参数限流" class="headerlink" title="热点参数限流"></a>热点参数限流</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>热点即经常访问的数据。很多时候我们希望统计某个热点数据中访问频次最高的 Top K 数据，并对其访问进行限制。热点参数限流会统计传入参数中的热点参数，并根据配置的限流阈值与模式，对包含热点参数的资源调用进行限流。热点参数限流可以看做是<font color="red">一种特殊的流量控制</font>，仅对包含热点参数的资源调用生效。</p><h2 id="编写测试代码"><a href="#编写测试代码" class="headerlink" title="编写测试代码"></a>编写测试代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/testHotKey&quot;)</span></span><br><span class="line"><span class="meta">@SentinelResource(value = &quot;testHotKey&quot;,blockHandler = &quot;del_testHotKey&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testHotKey</span><span class="params">(<span class="meta">@RequestParam(value = &quot;p1&quot;,required = false)</span>String p1,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="meta">@RequestParam(value = &quot;p2&quot;,required = false)</span>String p2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;---/testHotKey&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">del_testHotKey</span><span class="params">(String p1,String p2, BlockException blockException)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;---/del_testHotKey,o(╥﹏╥)o&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们写了一个兜底的方法 del_testHotKey ，如果进入限流，我们将会走兜底的方法，如果没有配置兜底的方法，则会报BlockException的错误，对用户不友好，所以我们一般情况下使用热点参数限流的时候都会配置一个兜底的方法，兜底的方法比限流的方法多了BlockException这个参数，注意不要遗忘，且存在另一个异常，叫BlockedException，需要留意。</p><p>在配置@SentinelResource的时候，要注意value的配置，就是下面配置页的资源名，不要多一”/“，如果没有配value这一项，Sentinel才会默认去找路径名称</p><h2 id="热点配置（定义热点规则）"><a href="#热点配置（定义热点规则）" class="headerlink" title="热点配置（定义热点规则）"></a>热点配置（定义热点规则）</h2><p><img src="http://cheng_qiwei.gitee.io/blog/img/1609053117528-1612065261160.png" alt="1609053117528"></p><p>参数索引：指的是方法上的参数的顺序，从第一个参数开始为0，第二个为1……</p><p>单机阈值：最大请求数是多少</p><p>统计窗口时长：这段时间发生熔断，阻止请求进来</p><p>当前的规则是：当请求 /testHotKey 时，如果添加了请求参数p1，则2s内的最大请求数为1，超过时，则限制这些请求，如果未添加请求参数p1，则不进行限制。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>a、首先测试只有p1参数，测试结果：</p><p>当快速点击时，发现被热点限流了</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1609053693855.png" alt="1609053693855"></p><p>b、测试只有p2参数，测试结果：</p><p>当快速点击时，还是可以正常访问</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1609053756408.png" alt="1609053756408"></p><p>c、测试同时有p1和p2参数，测试结果：</p><p>当快速点击时，发现被热点限流了</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1609053797962.png" alt="1609053797962"></p><p>结论：当参数中包含限流参数时，当请求超过阈值时，就会被限流。</p><h2 id="热点参数限流例外项"><a href="#热点参数限流例外项" class="headerlink" title="热点参数限流例外项"></a>热点参数限流例外项</h2><p>当我们在限制热点参数时，如果我们对该参数如果是某些值时不想对其做限制时，我们可以配置热点参数限流例外项。</p><p>点击  编辑  ——&gt;  高级选项</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1609054319610.png" alt="1609054319610"></p><p>当前规则是：当请求 /testHotKey 时，如果添加了请求参数p1，则2s内的最大请求数为1，超过时，则限制这些请求，如果未添加请求参数p1，则不进行限制。但如果p1的值为2，则限流的阈值变为100。</p><h2 id="参数限流例外项测试"><a href="#参数限流例外项测试" class="headerlink" title="参数限流例外项测试"></a>参数限流例外项测试</h2><p>a、首先测试只有p1参数，且p1的值不为2，测试结果：</p><p>当快速点击时，发现被热点限流了</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1609053693855.png" alt="1609053693855"></p><p>b、然后测试只有p1参数，且p1的值为2，测试结果：</p><p>当快速点击时，发现没有被热点限流</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1609054395990.png" alt="1609054395990"></p><h1 id="系统自适应限流"><a href="#系统自适应限流" class="headerlink" title="系统自适应限流"></a>系统自适应限流</h1><p>Sentinel 系统自适应限流从整体维度对应用入口流量进行控制，结合应用的 Load、CPU 使用率、总体平均 RT、入口 QPS 和并发线程数等几个维度的监控指标，通过自适应的流控策略，让系统的入口流量和系统的负载达到一个平衡，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。</p><h2 id="系统自适应限流模式"><a href="#系统自适应限流模式" class="headerlink" title="系统自适应限流模式"></a>系统自适应限流模式</h2><p><strong>Load 自适应</strong>（仅对 Linux/Unix-like 机器生效）：系统的 load1 作为启发指标，进行自适应系统保护。当系统 load1 超过设定的启发值，且系统当前的并发线程数超过估算的系统容量时才会触发系统保护（BBR 阶段）。系统容量由系统的 maxQps * minRt估算得出。设定参考值一般是 CPU cores * 2.5。</p><p><strong>CPU usage</strong>（1.5.0+ 版本）：当系统 CPU 使用率超过阈值即触发系统保护（取值范围 0.0-1.0），比较灵敏。</p><p><strong>平均 RT</strong>：当单台机器上所有入口流量的平均 RT 达到阈值即触发系统保护，单位是毫秒。</p><p><strong>并发线程数</strong>：当单台机器上所有入口流量的并发线程数达到阈值即触发系统保护。</p><p><strong>入口 QPS</strong>：当单台机器上所有入口流量的 QPS 达到阈值即触发系统保护。</p><p>本次仅测试两个，一个是CPU usage，一个是入口QPS</p><h2 id="系统自适应限流——入口QPS"><a href="#系统自适应限流——入口QPS" class="headerlink" title="系统自适应限流——入口QPS"></a>系统自适应限流——入口QPS</h2><h3 id="测试使用之前的代码-testA-和-testB"><a href="#测试使用之前的代码-testA-和-testB" class="headerlink" title="测试使用之前的代码  /testA  和  /testB"></a>测试使用之前的代码  /testA  和  /testB</h3><h3 id="添加配置"><a href="#添加配置" class="headerlink" title="添加配置"></a>添加配置</h3><p>点击  系统规则 –&gt;  新增系统规则</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1609054495122.png" alt="1609054495122"></p><h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><p>/testA  和  /testB 没有配置限流规则</p><p>a、快速点击请求  /testA ,使QPS大于1，测试结果：被限流了</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1609054891286.png" alt="1609054891286"></p><p>b、快速点击请求  /testHotKey ,使QPS大于1，测试结果：被限流了</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1609054776749.png" alt="1609054776749"></p><p>c、使用jmeter高并发请求 /testA 接口，然后点击 /testB 接口测试，测试结果：被限流了</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1609054776749.png" alt="1609054776749"></p><h2 id="系统自适应限流——CPU-usage"><a href="#系统自适应限流——CPU-usage" class="headerlink" title="系统自适应限流——CPU usage"></a>系统自适应限流——CPU usage</h2><h3 id="测试使用之前的代码-testA"><a href="#测试使用之前的代码-testA" class="headerlink" title="测试使用之前的代码  /testA"></a>测试使用之前的代码  /testA</h3><h3 id="添加配置-1"><a href="#添加配置-1" class="headerlink" title="添加配置"></a>添加配置</h3><p>点击  系统规则 –&gt;  新增系统规则</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1609054967586.png" alt="1609054967586"></p><h3 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h3><p>/testA 没有配置限流规则</p><p>当前系统的cpu为85%</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1609054979409.png" alt="1609054979409"></p><p>点击请求  /testA ，测试结果：被限流了</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1609055022913.png" alt="1609055022913"></p><h1 id="SentinelResource注解"><a href="#SentinelResource注解" class="headerlink" title="@SentinelResource注解"></a>@SentinelResource注解</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>@SentinelResource 用于定义资源，并提供可选的异常处理和 fallback 配置项。 @SentinelResource 注解包含以下属性：</p><p><strong>value</strong>：资源名称，必需项（不能为空）；<br><strong>entryType</strong>：entry 类型，可选项（默认为 EntryType.OUT）；<br><strong>blockHandler / blockHandlerClass</strong>: blockHandler 对应处理 BlockException 的函数名称，可选项。blockHandler 函数访问范围需要是 public，返回类型需要与原方法相匹配，参数类型需要和原方法相匹配并且最后加一个额外的参数，类型为 BlockException。blockHandler 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 blockHandlerClass 为对应的类的 Class 对象，注意对应的函数必需为 static 函数，否则无法解析；<br><strong>fallback / fallbackClass</strong>：fallback 函数名称，可选项，用于在抛出异常的时候提供 fallback 处理逻辑。fallback 函数可以针对所有类型的异常（除了 exceptionsToIgnore 里面排除掉的异常类型）进行处理。fallback 函数签名和位置要求：<br>​                返回值类型必须与原函数返回值类型一致；<br>​                方法参数列表需要和原函数一致，或者可以额外多一个 Throwable 类型的参数用于接收对应的异常。<br>​                fallback 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 fallbackClass 为对应的类的 Class 对象，注意对应的函数必需为 static 函数，否则无法解析。<br><strong>defaultFallback</strong>：默认的 fallback 函数名称，可选项，通常用于通用的 fallback 逻辑（即可以用于很多服务或方法）。默认 fallback 函数可以针对所有类型的异常（除了 exceptionsToIgnore 里面排除掉的异常类型）进行处理。若同时配置了 fallback 和 defaultFallback，则只有 fallback 会生效。defaultFallback 函数签名要求：<br>​                返回值类型必须与原函数返回值类型一致；<br>​                方法参数列表需要为空，或者可以额外多一个 Throwable 类型的参数用于接收对应的异常。<br>​                defaultFallback 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 fallbackClass 为对应的类的 Class 对象，注意对应的函数必需为 static 函数，否则无法解析。<br><strong>exceptionsToIgnore</strong>：用于指定哪些异常被排除掉，不会计入异常统计中，也不会进入 fallback 逻辑中，而是会原样抛出。</p><h2 id="代码的优化问题"><a href="#代码的优化问题" class="headerlink" title="代码的优化问题"></a>代码的优化问题</h2><p>我们回看热点参数限流中的第2点的测试代码，出现了几个问题</p><p>a、降级方法与业务方法耦合；</p><p>b、每一个方法都需要一个对应的降级方法；</p><p>c、如果服务出现异常而不是限流了，该怎么处理；</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>使用自定义限流处理类来解决问题。</p><h3 id="创建自定义限流处理类-异常处理类"><a href="#创建自定义限流处理类-异常处理类" class="headerlink" title="创建自定义限流处理类/异常处理类"></a>创建自定义限流处理类/异常处理类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cheng.cloud.alibaba.handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.slots.block.BlockException;</span><br><span class="line"><span class="keyword">import</span> com.cheng.cloud.entity.ResoultVo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerBlockHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ResoultVo&lt;Integer&gt; <span class="title">handlerException1</span><span class="params">(BlockException blockException)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResoultVo&lt;&gt;(<span class="number">444</span>,<span class="string">&quot;自定义，global handlerException------1&quot;</span>,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ResoultVo&lt;Integer&gt; <span class="title">handlerException2</span><span class="params">(BlockException blockException)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResoultVo&lt;&gt;(<span class="number">444</span>,<span class="string">&quot;自定义，global handlerException------2&quot;</span>,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ResoultVo&lt;Object&gt; <span class="title">exception1</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResoultVo&lt;&gt;(<span class="number">555</span>,<span class="string">&quot;自定义，global Exception------1&quot;</span>,e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<font color='red'>限流处理类的参数需要在原有参数的基础上添加BlockException blockException</font></p><p>​           <font color='red'>异常处理类的参数需要在原有参数的基础上添加Throwable e</font></p><h3 id="配置资源类"><a href="#配置资源类" class="headerlink" title="配置资源类"></a>配置资源类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(value = &quot;/payment/sentinel/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="meta">@SentinelResource(value = &quot;payMentSentinel&quot;,                  </span></span><br><span class="line"><span class="meta">  blockHandlerClass = CustomerBlockHandler.class,                  </span></span><br><span class="line"><span class="meta">  blockHandler = &quot;handlerException1&quot;,                  </span></span><br><span class="line"><span class="meta">  fallbackClass = CustomerBlockHandler.class,                  </span></span><br><span class="line"><span class="meta">  fallback = &quot;exception1&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResoultVo&lt;Integer&gt; <span class="title">getSentinelPayment</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">        ResoultVo&lt;Integer&gt; resoultVo = <span class="keyword">new</span> ResoultVo&lt;&gt;();    </span><br><span class="line">        resoultVo.setCode(<span class="number">200</span>);    </span><br><span class="line">        resoultVo.setMessage(<span class="string">&quot;使用端口为：&quot;</span>+serverPort);    </span><br><span class="line">        resoultVo.setData(id);    </span><br><span class="line">        <span class="keyword">return</span> resoultVo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动项目，配置流控规则"><a href="#启动项目，配置流控规则" class="headerlink" title="启动项目，配置流控规则"></a>启动项目，配置流控规则</h3><p><img src="http://cheng_qiwei.gitee.io/blog/img/1609055744414.png" alt="1609055744414"></p><h3 id="测试-3"><a href="#测试-3" class="headerlink" title="测试"></a>测试</h3><h4 id="测试流控统一处理"><a href="#测试流控统一处理" class="headerlink" title="测试流控统一处理"></a>测试流控统一处理</h4><p><img src="http://cheng_qiwei.gitee.io/blog/img/1609056097464.png" alt="1609056097464"></p><p>这里会去找blockHandlerClass流控处理类，然后再去找对应的blockHandler流控处理方法进行处理</p><h4 id="测试异常统一处理"><a href="#测试异常统一处理" class="headerlink" title="测试异常统一处理"></a>测试异常统一处理</h4><p>在代码添加异常int age = 10/0；运行请求</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1609056283800.png" alt="1609056283800"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1609056247912.png" alt="1609056247912"></p><p>这里会去找fallbackClass异常处理类，然后再去找对应的fallback异常处理方法进行处理，defaultFallback和fallback功能一致，如果设置了fallback，则会默认使用fallback的方法，而不是defaultFallback。</p><h3 id="exceptionsToIgnore配置"><a href="#exceptionsToIgnore配置" class="headerlink" title="exceptionsToIgnore配置"></a>exceptionsToIgnore配置</h3><p>有时候有一些异常我们不希望被fallback处理，我们希望他能抛出，这时候可以配置exceptionsToIgnore来除外相应的异常</p><p>测试：</p><p>代码添加exceptionsToIgnore配置，除外分母为0的异常</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1609056338479.png" alt="1608393539417"></p><p>测试发现异常不会被fallback处理，而是被抛出</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1609056517689.png" alt="1609056517689"></p><h1 id="sentinel整合openFeign-fallback"><a href="#sentinel整合openFeign-fallback" class="headerlink" title="sentinel整合openFeign+fallback"></a>sentinel整合openFeign+fallback</h1><h2 id="配置服务提供者"><a href="#配置服务提供者" class="headerlink" title="配置服务提供者"></a>配置服务提供者</h2><h3 id="配置pom文件"><a href="#配置pom文件" class="headerlink" title="配置pom文件"></a>配置pom文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud20200704<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.cheng.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloudalibaba-sentinel-openfeign-provider9004<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--nacos相关配置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--引入实体--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.cheng.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--spring boot相关配置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--热部署--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置yml文件"><a href="#配置yml文件" class="headerlink" title="配置yml文件"></a>配置yml文件</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9004</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-sentinel-provider</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.197</span><span class="number">.132</span><span class="string">:80,192.168.197.132:81</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;*&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="配置主启动类"><a href="#配置主启动类" class="headerlink" title="配置主启动类"></a>配置主启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cheng.sentinel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pr1Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Pr1Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写测试服务"><a href="#编写测试服务" class="headerlink" title="编写测试服务"></a>编写测试服务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cheng.sentinel.rest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.cheng.cloud.entity.PayMent;</span><br><span class="line"><span class="keyword">import</span> com.cheng.cloud.entity.ResoultVo;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;Long, PayMent&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        hashMap.put(<span class="number">1L</span>, <span class="keyword">new</span> PayMent(<span class="number">1L</span>, <span class="string">&quot;28a8c1e3bc2742d8848569891fb42181&quot;</span>));</span><br><span class="line">        hashMap.put(<span class="number">2L</span>, <span class="keyword">new</span> PayMent(<span class="number">2L</span>, <span class="string">&quot;bba8c1e3bc2742d8848569891ac32182&quot;</span>));</span><br><span class="line">        hashMap.put(<span class="number">3L</span>, <span class="keyword">new</span> PayMent(<span class="number">3L</span>, <span class="string">&quot;6ua8c1e3bc2742d8848569891xt92183&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/paymentSQL/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResoultVo&lt;PayMent&gt; <span class="title">paymentSQL</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> </span>&#123;</span><br><span class="line">        PayMent payment = hashMap.get(id);</span><br><span class="line">        ResoultVo&lt;PayMent&gt; result = <span class="keyword">new</span> ResoultVo(<span class="number">200</span>, <span class="string">&quot;from mysql,serverPort:  &quot;</span> + serverPort, payment);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动测试"><a href="#启动测试" class="headerlink" title="启动测试"></a>启动测试</h3><p><img src="http://cheng_qiwei.gitee.io/blog/img/1609057420018.png" alt="1609057420018"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1609057482444.png" alt="1609057482444"></p><h2 id="配置服务消费者"><a href="#配置服务消费者" class="headerlink" title="配置服务消费者"></a>配置服务消费者</h2><h3 id="配置pom文件-1"><a href="#配置pom文件-1" class="headerlink" title="配置pom文件"></a>配置pom文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud20200704<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.cheng.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloudalibaba-sentinel-openfeign-provider9004<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--nacos相关配置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--sentinel相关配置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--openfeign相关配置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--引入实体--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.cheng.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--spring boot相关配置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--热部署--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置yml文件-1"><a href="#配置yml文件-1" class="headerlink" title="配置yml文件"></a>配置yml文件</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">82</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-sentinel-consumer</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.197</span><span class="number">.132</span><span class="string">:80,192.168.197.132:81</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="number">192.168</span><span class="number">.197</span><span class="number">.132</span><span class="string">:8080</span></span><br><span class="line">        </span><br><span class="line"><span class="attr">service-url:</span></span><br><span class="line">  <span class="attr">nacos-user-service:</span> <span class="string">http://nacos-payment-provider</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Sentinel对Feign的支持</span></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">sentinel:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>最重要的配置</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1609057890710.png" alt="1609057890710"></p><h3 id="配置主启动类-1"><a href="#配置主启动类-1" class="headerlink" title="配置主启动类"></a>配置主启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cheng.sentinel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.EnableFeignClients;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(CoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置测试服务"><a href="#配置测试服务" class="headerlink" title="配置测试服务"></a>配置测试服务</h3><h4 id="PaymentService"><a href="#PaymentService" class="headerlink" title="PaymentService"></a>PaymentService</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cheng.sentinel.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.cheng.cloud.entity.PayMent;</span><br><span class="line"><span class="keyword">import</span> com.cheng.cloud.entity.ResoultVo;</span><br><span class="line"><span class="keyword">import</span> com.cheng.sentinel.service.impl.PaymentFallbackServiceImpl;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;nacos-payment-provider&quot;,fallback = PaymentFallbackServiceImpl.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PaymentService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/paymentSQL/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function">ResoultVo&lt;PayMent&gt; <span class="title">paymentSQL</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="PaymentFallbackServiceImpl-降级回调类"><a href="#PaymentFallbackServiceImpl-降级回调类" class="headerlink" title="PaymentFallbackServiceImpl(降级回调类)"></a>PaymentFallbackServiceImpl(降级回调类)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cheng.sentinel.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.cheng.cloud.entity.PayMent;</span><br><span class="line"><span class="keyword">import</span> com.cheng.cloud.entity.ResoultVo;</span><br><span class="line"><span class="keyword">import</span> com.cheng.sentinel.service.PaymentService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentFallbackServiceImpl</span> <span class="keyword">implements</span> <span class="title">PaymentService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResoultVo&lt;PayMent&gt; <span class="title">paymentSQL</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResoultVo&lt;PayMent&gt;(<span class="number">44444</span>,<span class="string">&quot;服务降级返回,---PaymentFallbackService&quot;</span>,<span class="keyword">new</span> PayMent(id,<span class="string">&quot;errorSerial&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="PayMentController"><a href="#PayMentController" class="headerlink" title="PayMentController"></a>PayMentController</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cheng.sentinel.rest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.cheng.cloud.entity.PayMent;</span><br><span class="line"><span class="keyword">import</span> com.cheng.cloud.entity.ResoultVo;</span><br><span class="line"><span class="keyword">import</span> com.cheng.sentinel.service.PaymentService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PayMentController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/consumer/paymentSQL/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResoultVo&lt;PayMent&gt; <span class="title">paymentSQL</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> paymentService.paymentSQL(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动测试-1"><a href="#启动测试-1" class="headerlink" title="启动测试"></a>启动测试</h3><p><img src="http://cheng_qiwei.gitee.io/blog/img/1609057960746.png" alt="1609057960746"></p><p>配置限流规则后，快速点击</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1609058011243.png" alt="1609058011243"></p><p>支持轮询的请求操作，此时关闭9004和9005，再次请求：跳入熔断返回方法，测试成功！</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1609058067136.png" alt="1609058067136"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1609058093924.png" alt="1609058093924"></p><h1 id="sentinel持久化配置"><a href="#sentinel持久化配置" class="headerlink" title="sentinel持久化配置"></a>sentinel持久化配置</h1><p>我们发现，我们每一次重启项目，我们都需要重新配置Sentinel上面的规则，这在生产环境是很不合理的，所以我们需要对其进行持久化配置，Sentinel推荐<strong>通过控制台设置规则后将规则推送到统一的规则中心，客户端实现<font color='red'>ReadableDataSource</font>  接口端监听规则中心实时获取变更</strong>，拓展的常见方式有两种：</p><ul><li><p><strong>拉模式</strong>：客户端主动向某个规则管理中心定期轮询拉取规则，这个规则中心可以是 RDBMS、文件，甚至是 VCS 等。这样做的方式是简单，缺点是无法及时获取变更；</p></li><li><p><strong>推模式</strong>：规则中心统一推送，客户端通过注册监听器的方式时刻监听变化，比如使用 <a href="http://github.com/alibaba/nacos">Nacos</a>、Zookeeper 等配置中心。这种方式有更好的实时性和一致性保证。</p><p>下文，我们会以nacos为例来使用推模式持久化我们的规则</p></li></ul><h2 id="Sentinel-Dashboard服务（控制台）改造"><a href="#Sentinel-Dashboard服务（控制台）改造" class="headerlink" title="Sentinel-Dashboard服务（控制台）改造"></a>Sentinel-Dashboard服务（控制台）改造</h2><p>我们需要改造Sentinel控制台，使我们的规则能够保存到nacos配置中心上。</p><p>这里如果嫌麻烦或者修改后出现异常，可以下载以下地址的jar包，里面是修改好所有规则的jar包</p><p><a href="http://cheng_qiwei.gitee.io/blog/file/sentinel-dashboard.jar">http://cheng_qiwei.gitee.io/blog/file/sentinel-dashboard.jar</a></p><h3 id="修改pom文件"><a href="#修改pom文件" class="headerlink" title="修改pom文件"></a>修改pom文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;scope&gt;test&lt;/scope&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="拷贝文件"><a href="#拷贝文件" class="headerlink" title="拷贝文件"></a>拷贝文件</h3><p>将 <strong>sentinel-dashboard/src/test/java/com/alibaba/csp/sentinel/dashboard/rule/nacos</strong>  下的所有文件拷贝到  <strong>sentinel-dashboard/src/main/java/com/alibaba/csp/sentinel/dashboard/rule/nacos</strong> </p><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>打开  <strong>sentinel-dashboard\src\main\resources\application.properties</strong>  添加配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">nacos 配置</span></span><br><span class="line">nacos.address=127.0.0.1:80</span><br><span class="line">nacos.namespace=</span><br></pre></td></tr></table></figure><h3 id="修改NacosConfig工具类"><a href="#修改NacosConfig工具类" class="headerlink" title="修改NacosConfig工具类"></a>修改NacosConfig工具类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright 1999-2018 Alibaba Group Holding Ltd.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment"> * you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"> * You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"> * See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"> * limitations under the License.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.alibaba.csp.sentinel.dashboard.rule.nacos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.dashboard.datasource.entity.gateway.ApiDefinitionEntity;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.dashboard.datasource.entity.gateway.GatewayFlowRuleEntity;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.dashboard.datasource.entity.rule.*;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.datasource.Converter;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.nacos.api.PropertyKeyConst;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.nacos.api.config.ConfigFactory;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.nacos.api.config.ConfigService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Eric Zhao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.4.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NacosConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;nacos.address&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;nacos.namespace&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String namespace;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 流控规则</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Converter&lt;List&lt;FlowRuleEntity&gt;, String&gt; flowRuleEntityEncoder() &#123;</span><br><span class="line">        <span class="keyword">return</span> JSON::toJSONString;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Converter&lt;String, List&lt;FlowRuleEntity&gt;&gt; flowRuleEntityDecoder() &#123;</span><br><span class="line">        <span class="keyword">return</span> s -&gt; JSON.parseArray(s, FlowRuleEntity.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 授权规则</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Converter&lt;List&lt;AuthorityRuleEntity&gt;, String&gt; authorRuleEntityEncoder() &#123;</span><br><span class="line">        <span class="keyword">return</span> JSON::toJSONString;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Converter&lt;String, List&lt;AuthorityRuleEntity&gt;&gt; authorRuleEntityDecoder() &#123;</span><br><span class="line">        <span class="keyword">return</span> s -&gt; JSON.parseArray(s, AuthorityRuleEntity.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 降级规则</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Converter&lt;List&lt;DegradeRuleEntity&gt;, String&gt; degradeRuleEntityEncoder() &#123;</span><br><span class="line">        <span class="keyword">return</span> JSON::toJSONString;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Converter&lt;String, List&lt;DegradeRuleEntity&gt;&gt; degradeRuleEntityDecoder() &#123;</span><br><span class="line">        <span class="keyword">return</span> s -&gt; JSON.parseArray(s, DegradeRuleEntity.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 热点参数 规则</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Converter&lt;List&lt;ParamFlowRuleEntity&gt;, String&gt; paramRuleEntityEncoder() &#123;</span><br><span class="line">        <span class="keyword">return</span> JSON::toJSONString;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Converter&lt;String, List&lt;ParamFlowRuleEntity&gt;&gt; paramRuleEntityDecoder() &#123;</span><br><span class="line">        <span class="keyword">return</span> s -&gt; JSON.parseArray(s, ParamFlowRuleEntity.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 系统规则</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Converter&lt;List&lt;SystemRuleEntity&gt;, String&gt; systemRuleEntityEncoder() &#123;</span><br><span class="line">        <span class="keyword">return</span> JSON::toJSONString;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Converter&lt;String, List&lt;SystemRuleEntity&gt;&gt; systemRuleEntityDecoder() &#123;</span><br><span class="line">        <span class="keyword">return</span> s -&gt; JSON.parseArray(s, SystemRuleEntity.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConfigService <span class="title">nacosConfigService</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">//nacos集群地址</span></span><br><span class="line">        properties.put(PropertyKeyConst.SERVER_ADDR,address);</span><br><span class="line">        <span class="comment">//namespace为空即为public</span></span><br><span class="line">        properties.put(PropertyKeyConst.NAMESPACE,namespace);</span><br><span class="line">        <span class="keyword">return</span> ConfigFactory.createConfigService(properties);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加一个JSONUtils在-com-alibaba-csp-sentinel-dashboard-util上"><a href="#添加一个JSONUtils在-com-alibaba-csp-sentinel-dashboard-util上" class="headerlink" title="添加一个JSONUtils在  com.alibaba.csp.sentinel.dashboard.util上"></a>添加一个<strong>JSONUtils</strong>在  <strong>com.alibaba.csp.sentinel.dashboard.util</strong>上</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.csp.sentinel.dashboard.util;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.JavaType;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * json根工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JSONUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">String <span class="title">toJSONString</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ObjectMapper().writeValueAsString(object);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JavaType <span class="title">getCollectionType</span><span class="params">(Class&lt;?&gt; collectionClass, Class&lt;?&gt;... elementClasses)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ObjectMapper()</span><br><span class="line">                .getTypeFactory()</span><br><span class="line">                .constructParametricType(collectionClass, elementClasses);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">parseObject</span><span class="params">(Class&lt;T&gt; clazz, String string)</span> </span>&#123;</span><br><span class="line">        JavaType javaType = getCollectionType(ArrayList.class, clazz);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (List&lt;T&gt;) <span class="keyword">new</span> ObjectMapper().readValue(string, javaType);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改-NacosConfigUtil-文件"><a href="#修改-NacosConfigUtil-文件" class="headerlink" title="修改 NacosConfigUtil 文件"></a>修改 <strong>NacosConfigUtil</strong> 文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright 1999-2018 Alibaba Group Holding Ltd.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment"> * you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"> * You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"> * See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"> * limitations under the License.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.alibaba.csp.sentinel.dashboard.rule.nacos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.dashboard.datasource.entity.rule.RuleEntity;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.dashboard.util.JSONUtils;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.slots.block.Rule;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.util.AssertUtil;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.util.StringUtil;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.nacos.api.config.ConfigService;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.nacos.api.exception.NacosException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Eric Zhao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.4.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NacosConfigUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String GROUP_ID = <span class="string">&quot;SENTINEL_GROUP&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FLOW_DATA_ID_POSTFIX = <span class="string">&quot;-flow-rules&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PARAM_FLOW_DATA_ID_POSTFIX = <span class="string">&quot;-param-rules&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CLUSTER_MAP_DATA_ID_POSTFIX = <span class="string">&quot;-cluster-map&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEGRADE_DATA_ID_POSTFIX = <span class="string">&quot;-degrade-rules&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SYSTEM_DATA_ID_POSTFIX = <span class="string">&quot;-system-rules&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String AUTHORITY_DATA_ID_POSTFIX = <span class="string">&quot;-authority-rules&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DASHBOARD_POSTFIX = <span class="string">&quot;-dashboard&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * cc for `cluster-client`</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String CLIENT_CONFIG_DATA_ID_POSTFIX = <span class="string">&quot;-cc-config&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * cs for `cluster-server`</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVER_TRANSPORT_CONFIG_DATA_ID_POSTFIX = <span class="string">&quot;-cs-transport-config&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVER_FLOW_CONFIG_DATA_ID_POSTFIX = <span class="string">&quot;-cs-flow-config&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVER_NAMESPACE_SET_DATA_ID_POSTFIX = <span class="string">&quot;-cs-namespace-set&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">NacosConfigUtil</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将规则序列化成JSON文本，存储到Nacos server中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> configService nacos config service</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> app           应用名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> postfix       规则后缀 eg.NacosConfigUtil.FLOW_DATA_ID_POSTFIX</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rules         规则对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NacosException 异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">setRuleStringToNacos</span><span class="params">(ConfigService configService, String app, String postfix, List&lt;T&gt; rules)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">        AssertUtil.notEmpty(app, <span class="string">&quot;app name cannot be empty&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (rules == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Rule&gt; ruleForApp = rules.stream()</span><br><span class="line">                .map(rule -&gt; &#123;</span><br><span class="line">                    RuleEntity rule1 = (RuleEntity) rule;</span><br><span class="line">                    System.out.println(rule1.getClass());</span><br><span class="line">                    Rule rule2 = rule1.toRule();</span><br><span class="line">                    System.out.println(rule2.getClass());</span><br><span class="line">                    <span class="keyword">return</span> rule2;</span><br><span class="line">                &#125;)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储，给微服务使用</span></span><br><span class="line">        String dataId = genDataId(app, postfix);</span><br><span class="line">        configService.publishConfig(</span><br><span class="line">                dataId,</span><br><span class="line">                NacosConfigUtil.GROUP_ID,</span><br><span class="line">                JSONUtils.toJSONString(ruleForApp)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储，给控制台使用</span></span><br><span class="line">        configService.publishConfig(</span><br><span class="line">                dataId + DASHBOARD_POSTFIX,</span><br><span class="line">                NacosConfigUtil.GROUP_ID,</span><br><span class="line">                JSONUtils.toJSONString(rules)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从Nacos server中查询响应规则，并将其反序列化成对应Rule实体</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> configService nacos config service</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> appName       应用名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> postfix       规则后缀 eg.NacosConfigUtil.FLOW_DATA_ID_POSTFIX</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz         类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;           泛型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 规则对象列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NacosException 异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">getRuleEntitiesFromNacos</span><span class="params">(ConfigService configService, String appName, String postfix, Class&lt;T&gt; clazz)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">        String rules = configService.getConfig(</span><br><span class="line">                genDataId(appName, postfix) + DASHBOARD_POSTFIX,</span><br><span class="line">                NacosConfigUtil.GROUP_ID,</span><br><span class="line">                <span class="number">3000</span></span><br><span class="line">        );</span><br><span class="line">        System.out.println(<span class="string">&quot;回收数据：&quot;</span>+rules);</span><br><span class="line">        <span class="keyword">if</span> (StringUtil.isEmpty(rules)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;回收数据2：&quot;</span>+JSONUtils.parseObject(clazz, rules));</span><br><span class="line">        <span class="keyword">return</span> JSONUtils.parseObject(clazz, rules);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">genDataId</span><span class="params">(String appName, String postfix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> appName + postfix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改-FlowRuleNacosProvider"><a href="#修改-FlowRuleNacosProvider" class="headerlink" title="修改 FlowRuleNacosProvider"></a>修改 FlowRuleNacosProvider</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright 1999-2018 Alibaba Group Holding Ltd.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment"> * you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"> * You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"> * See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"> * limitations under the License.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.alibaba.csp.sentinel.dashboard.rule.nacos.flow;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.dashboard.datasource.entity.rule.FlowRuleEntity;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.dashboard.rule.DynamicRuleProvider;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.dashboard.rule.nacos.NacosConfigUtil;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.datasource.Converter;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.util.StringUtil;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.nacos.api.config.ConfigService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Eric Zhao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.4.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component(&quot;flowRuleNacosProvider&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowRuleNacosProvider</span> <span class="keyword">implements</span> <span class="title">DynamicRuleProvider</span>&lt;<span class="title">List</span>&lt;<span class="title">FlowRuleEntity</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ConfigService configService;</span><br><span class="line"><span class="comment">//    @Autowired</span></span><br><span class="line"><span class="comment">//    private Converter&lt;String, List&lt;FlowRuleEntity&gt;&gt; converter;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;FlowRuleEntity&gt; <span class="title">getRules</span><span class="params">(String appName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//        String rules = configService.getConfig(appName + NacosConfigUtil.FLOW_DATA_ID_POSTFIX,</span></span><br><span class="line"><span class="comment">//            NacosConfigUtil.GROUP_ID, 3000);</span></span><br><span class="line"><span class="comment">//        if (StringUtil.isEmpty(rules)) &#123;</span></span><br><span class="line"><span class="comment">//            return new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        return converter.convert(rules);</span></span><br><span class="line">        <span class="keyword">return</span> NacosConfigUtil.getRuleEntitiesFromNacos(</span><br><span class="line">                <span class="keyword">this</span>.configService,</span><br><span class="line">                appName,</span><br><span class="line">                NacosConfigUtil.FLOW_DATA_ID_POSTFIX,</span><br><span class="line">                FlowRuleEntity.class</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改-FlowRuleNacosPublisher"><a href="#修改-FlowRuleNacosPublisher" class="headerlink" title="修改 FlowRuleNacosPublisher"></a>修改 FlowRuleNacosPublisher</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright 1999-2018 Alibaba Group Holding Ltd.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment"> * you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"> * You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"> * See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"> * limitations under the License.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.alibaba.csp.sentinel.dashboard.rule.nacos.flow;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.dashboard.datasource.entity.rule.FlowRuleEntity;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.dashboard.rule.DynamicRulePublisher;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.dashboard.rule.nacos.NacosConfigUtil;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.datasource.Converter;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.util.AssertUtil;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.nacos.api.config.ConfigService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Eric Zhao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.4.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component(&quot;flowRuleNacosPublisher&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowRuleNacosPublisher</span> <span class="keyword">implements</span> <span class="title">DynamicRulePublisher</span>&lt;<span class="title">List</span>&lt;<span class="title">FlowRuleEntity</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ConfigService configService;</span><br><span class="line"><span class="comment">//    @Autowired</span></span><br><span class="line"><span class="comment">//    private Converter&lt;List&lt;FlowRuleEntity&gt;, String&gt; converter;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publish</span><span class="params">(String app, List&lt;FlowRuleEntity&gt; rules)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//        AssertUtil.notEmpty(app, &quot;app name cannot be empty&quot;);</span></span><br><span class="line"><span class="comment">//        if (rules == null) &#123;</span></span><br><span class="line"><span class="comment">//            return;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        configService.publishConfig(app + NacosConfigUtil.FLOW_DATA_ID_POSTFIX,</span></span><br><span class="line"><span class="comment">//            NacosConfigUtil.GROUP_ID, converter.convert(rules));</span></span><br><span class="line">        NacosConfigUtil.setRuleStringToNacos(</span><br><span class="line">                <span class="keyword">this</span>.configService,</span><br><span class="line">                app,</span><br><span class="line">                NacosConfigUtil.FLOW_DATA_ID_POSTFIX,</span><br><span class="line">                rules</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改FlowControllerV2"><a href="#修改FlowControllerV2" class="headerlink" title="修改FlowControllerV2"></a>修改FlowControllerV2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">    <span class="comment">//@Qualifier(&quot;flowRuleDefaultProvider&quot;)</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;flowRuleNacosProvider&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> DynamicRuleProvider&lt;List&lt;FlowRuleEntity&gt;&gt; ruleProvider;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="comment">//@Qualifier(&quot;flowRuleDefaultPublisher&quot;)</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;flowRuleNacosPublisher&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> DynamicRulePublisher&lt;List&lt;FlowRuleEntity&gt;&gt; rulePublisher;</span><br></pre></td></tr></table></figure><h3 id="修改sidebar-html"><a href="#修改sidebar-html" class="headerlink" title="修改sidebar.html"></a>修改sidebar.html</h3><p><strong>sentinel-dashboard/src/main/webapp/resources/app/scripts/directives/sidebar/sidebar.html</strong></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1609060601031.png" alt="1609060601031"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;li ui-sref-active&#x3D;&quot;active&quot; ng-if&#x3D;&quot;!entry.isGateway&quot;&gt;</span><br><span class="line">            &lt;a ui-sref&#x3D;&quot;dashboard.flow(&#123;app: entry.app&#125;)&quot;&gt;</span><br><span class="line">              &lt;i class&#x3D;&quot;glyphicon glyphicon-filter&quot;&gt;&lt;&#x2F;i&gt;&amp;nbsp;&amp;nbsp;流控规则&lt;&#x2F;a&gt;</span><br><span class="line">          &lt;&#x2F;li&gt;</span><br></pre></td></tr></table></figure><h3 id="修改FlowControllerV1"><a href="#修改FlowControllerV1" class="headerlink" title="修改FlowControllerV1"></a>修改FlowControllerV1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright 1999-2018 Alibaba Group Holding Ltd.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment"> * you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"> * You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"> * See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"> * limitations under the License.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.alibaba.csp.sentinel.dashboard.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.dashboard.auth.AuthAction;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.dashboard.auth.AuthService.PrivilegeType;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.dashboard.rule.DynamicRuleProvider;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.dashboard.rule.DynamicRulePublisher;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.util.StringUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.dashboard.client.SentinelApiClient;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.dashboard.datasource.entity.rule.FlowRuleEntity;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.dashboard.discovery.MachineInfo;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.dashboard.domain.Result;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.dashboard.repository.rule.InMemoryRuleRepositoryAdapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.DeleteMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PutMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestBody;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Flow rule controller.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> leyou</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Eric Zhao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/v1/flow&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlowControllerV1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(FlowControllerV1.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> InMemoryRuleRepositoryAdapter&lt;FlowRuleEntity&gt; repository;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    @Autowired</span></span><br><span class="line"><span class="comment">//    private SentinelApiClient sentinelApiClient;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;flowRuleNacosProvider&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> DynamicRuleProvider&lt;List&lt;FlowRuleEntity&gt;&gt; ruleProvider;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;flowRuleNacosPublisher&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> DynamicRulePublisher&lt;List&lt;FlowRuleEntity&gt;&gt; rulePublisher;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/rules&quot;)</span></span><br><span class="line">    <span class="meta">@AuthAction(PrivilegeType.READ_RULE)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;List&lt;FlowRuleEntity&gt;&gt; apiQueryMachineRules(<span class="meta">@RequestParam</span> String app,</span><br><span class="line">                                                             <span class="meta">@RequestParam</span> String ip,</span><br><span class="line">                                                             <span class="meta">@RequestParam</span> Integer port) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (StringUtil.isEmpty(app)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.ofFail(-<span class="number">1</span>, <span class="string">&quot;app can&#x27;t be null or empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (StringUtil.isEmpty(ip)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.ofFail(-<span class="number">1</span>, <span class="string">&quot;ip can&#x27;t be null or empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (port == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.ofFail(-<span class="number">1</span>, <span class="string">&quot;port can&#x27;t be null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//List&lt;FlowRuleEntity&gt; rules = sentinelApiClient.fetchFlowRuleOfMachine(app, ip, port);</span></span><br><span class="line">            List&lt;FlowRuleEntity&gt; rules = ruleProvider.getRules(app);</span><br><span class="line">            rules = repository.saveAll(rules);</span><br><span class="line">            <span class="keyword">return</span> Result.ofSuccess(rules);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;Error when querying flow rules&quot;</span>, throwable);</span><br><span class="line">            <span class="keyword">return</span> Result.ofThrowable(-<span class="number">1</span>, throwable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> &lt;R&gt; <span class="function">Result&lt;R&gt; <span class="title">checkEntityInternal</span><span class="params">(FlowRuleEntity entity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtil.isBlank(entity.getApp())) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.ofFail(-<span class="number">1</span>, <span class="string">&quot;app can&#x27;t be null or empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (StringUtil.isBlank(entity.getIp())) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.ofFail(-<span class="number">1</span>, <span class="string">&quot;ip can&#x27;t be null or empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (entity.getPort() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.ofFail(-<span class="number">1</span>, <span class="string">&quot;port can&#x27;t be null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (StringUtil.isBlank(entity.getLimitApp())) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.ofFail(-<span class="number">1</span>, <span class="string">&quot;limitApp can&#x27;t be null or empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (StringUtil.isBlank(entity.getResource())) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.ofFail(-<span class="number">1</span>, <span class="string">&quot;resource can&#x27;t be null or empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (entity.getGrade() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.ofFail(-<span class="number">1</span>, <span class="string">&quot;grade can&#x27;t be null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (entity.getGrade() != <span class="number">0</span> &amp;&amp; entity.getGrade() != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.ofFail(-<span class="number">1</span>, <span class="string">&quot;grade must be 0 or 1, but &quot;</span> + entity.getGrade() + <span class="string">&quot; got&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (entity.getCount() == <span class="keyword">null</span> || entity.getCount() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.ofFail(-<span class="number">1</span>, <span class="string">&quot;count should be at lease zero&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (entity.getStrategy() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.ofFail(-<span class="number">1</span>, <span class="string">&quot;strategy can&#x27;t be null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (entity.getStrategy() != <span class="number">0</span> &amp;&amp; StringUtil.isBlank(entity.getRefResource())) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.ofFail(-<span class="number">1</span>, <span class="string">&quot;refResource can&#x27;t be null or empty when strategy!=0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (entity.getControlBehavior() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.ofFail(-<span class="number">1</span>, <span class="string">&quot;controlBehavior can&#x27;t be null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> controlBehavior = entity.getControlBehavior();</span><br><span class="line">        <span class="keyword">if</span> (controlBehavior == <span class="number">1</span> &amp;&amp; entity.getWarmUpPeriodSec() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.ofFail(-<span class="number">1</span>, <span class="string">&quot;warmUpPeriodSec can&#x27;t be null when controlBehavior==1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (controlBehavior == <span class="number">2</span> &amp;&amp; entity.getMaxQueueingTimeMs() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.ofFail(-<span class="number">1</span>, <span class="string">&quot;maxQueueingTimeMs can&#x27;t be null when controlBehavior==2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (entity.isClusterMode() &amp;&amp; entity.getClusterConfig() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.ofFail(-<span class="number">1</span>, <span class="string">&quot;cluster config should be valid&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/rule&quot;)</span></span><br><span class="line">    <span class="meta">@AuthAction(PrivilegeType.WRITE_RULE)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result&lt;FlowRuleEntity&gt; <span class="title">apiAddFlowRule</span><span class="params">(<span class="meta">@RequestBody</span> FlowRuleEntity entity)</span> </span>&#123;</span><br><span class="line">        Result&lt;FlowRuleEntity&gt; checkResult = checkEntityInternal(entity);</span><br><span class="line">        <span class="keyword">if</span> (checkResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> checkResult;</span><br><span class="line">        &#125;</span><br><span class="line">        entity.setId(<span class="keyword">null</span>);</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        entity.setGmtCreate(date);</span><br><span class="line">        entity.setGmtModified(date);</span><br><span class="line">        entity.setLimitApp(entity.getLimitApp().trim());</span><br><span class="line">        entity.setResource(entity.getResource().trim());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            entity = repository.save(entity);</span><br><span class="line">            publishRules(entity.getApp());</span><br><span class="line">            <span class="comment">//publishRules(entity.getApp(), entity.getIp(), entity.getPort()).get(5000, TimeUnit.MILLISECONDS);</span></span><br><span class="line">            <span class="keyword">return</span> Result.ofSuccess(entity);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            Throwable e = t <span class="keyword">instanceof</span> ExecutionException ? t.getCause() : t;</span><br><span class="line">            logger.error(<span class="string">&quot;Failed to add new flow rule, app=&#123;&#125;, ip=&#123;&#125;&quot;</span>, entity.getApp(), entity.getIp(), e);</span><br><span class="line">            <span class="keyword">return</span> Result.ofFail(-<span class="number">1</span>, e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/save.json&quot;)</span></span><br><span class="line">    <span class="meta">@AuthAction(PrivilegeType.WRITE_RULE)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result&lt;FlowRuleEntity&gt; <span class="title">apiUpdateFlowRule</span><span class="params">(Long id, String app,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  String limitApp, String resource, Integer grade,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  Double count, Integer strategy, String refResource,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  Integer controlBehavior, Integer warmUpPeriodSec,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  Integer maxQueueingTimeMs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (id == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.ofFail(-<span class="number">1</span>, <span class="string">&quot;id can&#x27;t be null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        FlowRuleEntity entity = repository.findById(id);</span><br><span class="line">        <span class="keyword">if</span> (entity == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.ofFail(-<span class="number">1</span>, <span class="string">&quot;id &quot;</span> + id + <span class="string">&quot; dose not exist&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (StringUtil.isNotBlank(app)) &#123;</span><br><span class="line">            entity.setApp(app.trim());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (StringUtil.isNotBlank(limitApp)) &#123;</span><br><span class="line">            entity.setLimitApp(limitApp.trim());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (StringUtil.isNotBlank(resource)) &#123;</span><br><span class="line">            entity.setResource(resource.trim());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (grade != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grade != <span class="number">0</span> &amp;&amp; grade != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> Result.ofFail(-<span class="number">1</span>, <span class="string">&quot;grade must be 0 or 1, but &quot;</span> + grade + <span class="string">&quot; got&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            entity.setGrade(grade);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count != <span class="keyword">null</span>) &#123;</span><br><span class="line">            entity.setCount(count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (strategy != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (strategy != <span class="number">0</span> &amp;&amp; strategy != <span class="number">1</span> &amp;&amp; strategy != <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> Result.ofFail(-<span class="number">1</span>, <span class="string">&quot;strategy must be in [0, 1, 2], but &quot;</span> + strategy + <span class="string">&quot; got&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            entity.setStrategy(strategy);</span><br><span class="line">            <span class="keyword">if</span> (strategy != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (StringUtil.isBlank(refResource)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Result.ofFail(-<span class="number">1</span>, <span class="string">&quot;refResource can&#x27;t be null or empty when strategy!=0&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                entity.setRefResource(refResource.trim());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (controlBehavior != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (controlBehavior != <span class="number">0</span> &amp;&amp; controlBehavior != <span class="number">1</span> &amp;&amp; controlBehavior != <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> Result.ofFail(-<span class="number">1</span>, <span class="string">&quot;controlBehavior must be in [0, 1, 2], but &quot;</span> + controlBehavior + <span class="string">&quot; got&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (controlBehavior == <span class="number">1</span> &amp;&amp; warmUpPeriodSec == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> Result.ofFail(-<span class="number">1</span>, <span class="string">&quot;warmUpPeriodSec can&#x27;t be null when controlBehavior==1&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (controlBehavior == <span class="number">2</span> &amp;&amp; maxQueueingTimeMs == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> Result.ofFail(-<span class="number">1</span>, <span class="string">&quot;maxQueueingTimeMs can&#x27;t be null when controlBehavior==2&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            entity.setControlBehavior(controlBehavior);</span><br><span class="line">            <span class="keyword">if</span> (warmUpPeriodSec != <span class="keyword">null</span>) &#123;</span><br><span class="line">                entity.setWarmUpPeriodSec(warmUpPeriodSec);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (maxQueueingTimeMs != <span class="keyword">null</span>) &#123;</span><br><span class="line">                entity.setMaxQueueingTimeMs(maxQueueingTimeMs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        entity.setGmtModified(date);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            entity = repository.save(entity);</span><br><span class="line">            <span class="keyword">if</span> (entity == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> Result.ofFail(-<span class="number">1</span>, <span class="string">&quot;save entity fail: null&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            publishRules(entity.getApp());</span><br><span class="line">            <span class="comment">//publishRules(entity.getApp(), entity.getIp(), entity.getPort()).get(5000, TimeUnit.MILLISECONDS);</span></span><br><span class="line">            <span class="keyword">return</span> Result.ofSuccess(entity);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            Throwable e = t <span class="keyword">instanceof</span> ExecutionException ? t.getCause() : t;</span><br><span class="line">            logger.error(<span class="string">&quot;Error when updating flow rules, app=&#123;&#125;, ip=&#123;&#125;, ruleId=&#123;&#125;&quot;</span>, entity.getApp(),</span><br><span class="line">                entity.getIp(), id, e);</span><br><span class="line">            <span class="keyword">return</span> Result.ofFail(-<span class="number">1</span>, e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/delete.json&quot;)</span></span><br><span class="line">    <span class="meta">@AuthAction(PrivilegeType.WRITE_RULE)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result&lt;Long&gt; <span class="title">apiDeleteFlowRule</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (id == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.ofFail(-<span class="number">1</span>, <span class="string">&quot;id can&#x27;t be null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        FlowRuleEntity oldEntity = repository.findById(id);</span><br><span class="line">        <span class="keyword">if</span> (oldEntity == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.ofSuccess(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            repository.delete(id);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.ofFail(-<span class="number">1</span>, e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            publishRules(oldEntity.getApp());</span><br><span class="line">            <span class="comment">//publishRules(oldEntity.getApp(), oldEntity.getIp(), oldEntity.getPort()).get(5000, TimeUnit.MILLISECONDS);</span></span><br><span class="line">            <span class="keyword">return</span> Result.ofSuccess(id);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            Throwable e = t <span class="keyword">instanceof</span> ExecutionException ? t.getCause() : t;</span><br><span class="line">            logger.error(<span class="string">&quot;Error when deleting flow rules, app=&#123;&#125;, ip=&#123;&#125;, id=&#123;&#125;&quot;</span>, oldEntity.getApp(),</span><br><span class="line">                oldEntity.getIp(), id, e);</span><br><span class="line">            <span class="keyword">return</span> Result.ofFail(-<span class="number">1</span>, e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    private CompletableFuture&lt;Void&gt; publishRules(String app, String ip, Integer port) &#123;</span></span><br><span class="line"><span class="comment">//        List&lt;FlowRuleEntity&gt; rules = repository.findAllByMachine(MachineInfo.of(app, ip, port));</span></span><br><span class="line"><span class="comment">//        return sentinelApiClient.setFlowRuleOfMachineAsync(app, ip, port, rules);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">publishRules</span><span class="params">(<span class="comment">/*@NonNull*/</span> String app)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        List&lt;FlowRuleEntity&gt; rules = repository.findAllByApp(app);</span><br><span class="line">        rulePublisher.publish(app, rules);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，**<font color='red'>Sentinel控制台流控规则</font>**的改造结束！其他规则的修改可以参照此来进行修改：</p><p>具体代码请参考：<a href="http://gitee.com/cheng_qiwei/blog/raw/master/file/sentinel-dashboard.rar">http://gitee.com/cheng_qiwei/blog/raw/master/file/sentinel-dashboard.rar</a></p><h2 id="Sentinel服务配置"><a href="#Sentinel服务配置" class="headerlink" title="Sentinel服务配置"></a>Sentinel服务配置</h2><h3 id="修改pom文件-1"><a href="#修改pom文件-1" class="headerlink" title="修改pom文件"></a>修改pom文件</h3><p>添加四个依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  sentinel核心库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  sentinel AspectJ 的扩展用于自动定义资源 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-annotation-aspectj<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- sentinel客户端与dashboard通信依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-transport-simple-http<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="修改yml文件"><a href="#修改yml文件" class="headerlink" title="修改yml文件"></a>修改yml文件</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9003</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloudalibaba-sentinel-service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.197</span><span class="number">.132</span><span class="string">:80,192.168.197.132:81</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">filter:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="number">192.168</span><span class="number">.197</span><span class="number">.132</span><span class="string">:8080</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8719</span></span><br><span class="line">        <span class="attr">client-ip:</span> <span class="number">192.168</span><span class="number">.136</span><span class="number">.4</span></span><br><span class="line">      <span class="attr">datasource:</span></span><br><span class="line">        <span class="attr">flow:</span></span><br><span class="line">          <span class="attr">nacos:</span></span><br><span class="line">            <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.197</span><span class="number">.132</span><span class="string">:80</span></span><br><span class="line">            <span class="attr">dataId:</span> <span class="string">$&#123;spring.application.name&#125;-flow-rules</span></span><br><span class="line">            <span class="attr">groupId:</span> <span class="string">SENTINEL_GROUP</span></span><br><span class="line">            <span class="attr">data-type:</span> <span class="string">json</span></span><br><span class="line">            <span class="attr">rule-type:</span> <span class="string">flow</span></span><br><span class="line">        <span class="attr">param:</span></span><br><span class="line">          <span class="attr">nacos:</span></span><br><span class="line">            <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.197</span><span class="number">.132</span><span class="string">:80</span></span><br><span class="line">            <span class="attr">dataId:</span> <span class="string">$&#123;spring.application.name&#125;-param-rules</span></span><br><span class="line">            <span class="attr">groupId:</span> <span class="string">SENTINEL_GROUP</span></span><br><span class="line">            <span class="attr">data-type:</span> <span class="string">json</span></span><br><span class="line">            <span class="attr">rule-type:</span> <span class="string">param</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&#x27;*&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/1609061203202.png" alt="1609061203202"></p><p>主要添加上图内容，如果还有其他规则，则需要添加对应的上图内容即可。</p><h3 id="配置NacosSentinelConfig"><a href="#配置NacosSentinelConfig" class="headerlink" title="配置NacosSentinelConfig"></a>配置NacosSentinelConfig</h3><p><font color='red'>配置该文件的功能是将Sentinel默认通过内存获取规则修改为从nacos上面获取对应规则</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cheng.cloud.alibaba.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.datasource.AbstractDataSource;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.datasource.ReadableDataSource;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.datasource.nacos.NacosDataSource;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.init.InitFunc;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.slots.block.flow.FlowRule;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.slots.block.flow.FlowRuleManager;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.slots.block.flow.param.ParamFlowRule;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.slots.block.flow.param.ParamFlowRuleManager;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.slots.system.SystemRule;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.slots.system.SystemRuleManager;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.TypeReference;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NacosSentinelConfig</span></span>&#123;</span><br><span class="line">    <span class="comment">/**配置流控规则从nacos获取*/</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initFlowDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String serverAddr = <span class="string">&quot;192.168.197.132:80&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> String groupId = <span class="string">&quot;SENTINEL_GROUP&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> String dataId = <span class="string">&quot;cloudalibaba-sentinel-service-flow-rules&quot;</span>;</span><br><span class="line"></span><br><span class="line">        ReadableDataSource&lt;String, List&lt;FlowRule&gt;&gt; readableFlowDataSource = <span class="keyword">new</span> NacosDataSource&lt;&gt;(</span><br><span class="line">                serverAddr,</span><br><span class="line">                groupId,</span><br><span class="line">                dataId,</span><br><span class="line">                source -&gt; JSONObject.parseObject(source,<span class="keyword">new</span> TypeReference&lt;List&lt;FlowRule&gt;&gt;()&#123;&#125;)</span><br><span class="line">        );</span><br><span class="line">        FlowRuleManager.register2Property(readableFlowDataSource.getProperty());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**配置热点参数规则从nacos获取*/</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initParamDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String serverAddr = <span class="string">&quot;192.168.197.132:80&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> String groupId = <span class="string">&quot;SENTINEL_GROUP&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> String dataId = <span class="string">&quot;cloudalibaba-sentinel-service-param-rules&quot;</span>;</span><br><span class="line"></span><br><span class="line">        ReadableDataSource&lt;String, List&lt;ParamFlowRule&gt;&gt; readableFlowDataSource = <span class="keyword">new</span> NacosDataSource&lt;&gt;(</span><br><span class="line">                serverAddr,</span><br><span class="line">                groupId,</span><br><span class="line">                dataId,</span><br><span class="line">                source -&gt; JSONObject.parseObject(source,<span class="keyword">new</span> TypeReference&lt;List&lt;ParamFlowRule&gt;&gt;()&#123;&#125;)</span><br><span class="line">        );</span><br><span class="line">        ParamFlowRuleManager.register2Property(readableFlowDataSource.getProperty());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**配置系统参数规则从nacos获取*/</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initSystemDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String serverAddr = <span class="string">&quot;192.168.197.132:80&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> String groupId = <span class="string">&quot;SENTINEL_GROUP&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> String dataId = <span class="string">&quot;cloudalibaba-sentinel-service-system-rules&quot;</span>;</span><br><span class="line"></span><br><span class="line">        ReadableDataSource&lt;String, List&lt;SystemRule&gt;&gt; readableFlowDataSource = <span class="keyword">new</span> NacosDataSource&lt;&gt;(</span><br><span class="line">                serverAddr,</span><br><span class="line">                groupId,</span><br><span class="line">                dataId,</span><br><span class="line">                source -&gt; JSONObject.parseObject(source,<span class="keyword">new</span> TypeReference&lt;List&lt;SystemRule&gt;&gt;()&#123;&#125;)</span><br><span class="line">        );</span><br><span class="line">        SystemRuleManager.register2Property(readableFlowDataSource.getProperty());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，Sentinel服务就修改结束。</p><h2 id="测试-4"><a href="#测试-4" class="headerlink" title="测试"></a>测试</h2><p>服务启动后，新增流控规则；</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1609061599958.png" alt="1609061599958"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1609061646460.png" alt="1609061646460"></p><p>我们可以从nacos看见配置文件，里面已经把我们的Sentinel配置写进来了；</p><p>我们再测试 /testA 接口，流控规则生效，配置成功，至此，我们的流控规则持久化已经成功了。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1609061754780.png" alt="1609061754780"></p>]]></content>
      
      
      <categories>
          
          <category> SpringCloudAlibaba </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sentinel </tag>
            
            <tag> SpringCloudAlibaba </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sentinel的介绍与使用（一）</title>
      <link href="/blog/2021/03/18/Sentinel%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/blog/2021/03/18/Sentinel%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Sentinel的介绍与使用（一）"><a href="#Sentinel的介绍与使用（一）" class="headerlink" title="Sentinel的介绍与使用（一）"></a>Sentinel的介绍与使用（一）</h1><h1 id="Sentinel的介绍"><a href="#Sentinel的介绍" class="headerlink" title="Sentinel的介绍"></a>Sentinel的介绍</h1><h2 id="什么是Sentinel？"><a href="#什么是Sentinel？" class="headerlink" title="什么是Sentinel？"></a>什么是Sentinel？</h2><p>​        Sentinel是阿里开源的项目，主要以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度来帮助用户提升服务的稳定性。</p><p>中文官网路径：<a href="http://github.com/alibaba/Sentinel/wiki/%E4%BB%8B%E7%BB%8D">http://github.com/alibaba/Sentinel/wiki/%E4%BB%8B%E7%BB%8D</a></p><h2 id="Sentinel的主要特性"><a href="#Sentinel的主要特性" class="headerlink" title="Sentinel的主要特性"></a>Sentinel的主要特性</h2><p><img src="http://cheng_qiwei.gitee.io/blog/img/clipboard-1607525217544-1607609884850.png" alt="img"></p><h1 id="Sentinel的安装"><a href="#Sentinel的安装" class="headerlink" title="Sentinel的安装"></a>Sentinel的安装</h1><p>文件下载路径：[ <a href="http://github.com/alibaba/Sentinel/releases">http://github.com/alibaba/Sentinel/releases</a> ]</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/clipboard-1607525280457-1607609890089.png" alt="img"></p><p>Sentinel本身是一个java项目，所以要求安装Java环境，使用命令启动即可。</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java -jar sentinel-dashboard-1.8.0.jar  &gt; log.file  2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><p>注意：Sentinel的默认端口号是：8080，所以需要开放端口访问限制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//开放指定端口 </span><br><span class="line">firewall-cmd --zone=public --add-port=8080/tcp --permanent </span><br><span class="line">//重新加载防火墙 </span><br><span class="line">firewall-cmd --reload </span><br></pre></td></tr></table></figure><p>成功的话，访问：<a href="http://ip:8080/">http://IP:8080</a> 即可显示以下页面</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/clipboard-1607609875746.png" alt="img"></p><h1 id="Sentinel的流量控制"><a href="#Sentinel的流量控制" class="headerlink" title="Sentinel的流量控制"></a>Sentinel的流量控制</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>流量控制</strong>（flow control），其原理是监控应用流量的 QPS 或并发线程数等指标，当达到指定的阈值时对流量进行控制，以避免被瞬时的流量高峰冲垮，从而保障应用的高可用性。</p><p>​        一条限流规则主要由下面几个因素组成，我们可以组合这些元素来实现不同的限流效果：</p><p>a、resource：资源名，即限流规则的作用对象；</p><p>b、count: 限流阈值；</p><p>c、grade: 限流阈值类型（QPS 或并发线程数）；</p><p>​        QPS：每秒请求数，当前调用该api的QPS到达阈值的时候进行限流；</p><p>​        线程数：当调用该api的线程数到达阈值的时候，进行限流；</p><p>d、limitApp: 流控针对的调用来源，若为 default 则不区分调用来源；</p><p>e、strategy: 调用关系限流策略；</p><p>​        直接：当api大达到限流条件时，直接限流；</p><p>​        关联：当关联的资源到达阈值，就限流自己；</p><p>​        链路：只记录指定路上的流量，指定资源从入口资源进来的流量，如果达到阈值，就进行限流，api级别的限流；</p><p>f、controlBehavior: 流量控制效果（直接拒绝、Warm Up、匀速排队）；</p><p>​        直接拒绝：超过设置的阈值，将直接返回默认错误；</p><p>​        Warm Up：预热模式，当流量突然增大时（例如双十一等大型活动），我们希望系统从空闲状态慢慢切换到繁忙状态，经过预定的时间后，到达处理这个请求数的最大值；</p><p>​        匀速排队：严格控制请求通过的间隔时间，使请求匀速通过，这种方式主要用于处理间隔性突发的流量（如：消息队列），在某一秒会出现大量请求，而在接下来一段时间会出现空闲，所以我们可以在接下来的时间处理这些请求，而不是直接拒绝多余的请求。</p><p><font color='red'> 注意事项：</font></p><p>​        <font color='red'>a、使用匀速排队时限流阈值类型必须选择QPS；</font></p><p>​        <font color='red'>b、使用匀速排队时不支持 QPS &gt; 1000 的场景。</font></p><h2 id="流量控制体验"><a href="#流量控制体验" class="headerlink" title="流量控制体验"></a>流量控制体验</h2><h3 id="编写测试工程"><a href="#编写测试工程" class="headerlink" title="编写测试工程"></a>编写测试工程</h3><h4 id="pom文件"><a href="#pom文件" class="headerlink" title="pom文件"></a>pom文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud20200704<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.cheng.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloudalibaba-sentinel-test9003<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--监控--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--热部署--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="yml文件"><a href="#yml文件" class="headerlink" title="yml文件"></a>yml文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 9003</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: cloudalibaba-sentinel-service</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      discovery:</span><br><span class="line">        server-addr: 192.168.197.132:80,192.168.197.132:81</span><br><span class="line">    sentinel:</span><br><span class="line">      transport:</span><br><span class="line">        dashboard: 192.168.197.132:8080</span><br><span class="line">#    port: 8719 #默认8719，假如被占用了会自动从8719开始依次+1扫描。直至找到未被占用的端口</span><br><span class="line"></span><br><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: &#x27;*&#x27;</span><br></pre></td></tr></table></figure><h4 id="启动类文件"><a href="#启动类文件" class="headerlink" title="启动类文件"></a>启动类文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.cheng.cloud.alibaba;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">public class SentinelApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(SentinelApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="业务类文件"><a href="#业务类文件" class="headerlink" title="业务类文件"></a>业务类文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.cheng.cloud.alibaba.rest;</span><br><span class="line"></span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class FlowLimitController &#123;</span><br><span class="line">    @GetMapping(&quot;/testA&quot;)</span><br><span class="line">    public String testA() &#123;</span><br><span class="line">        return &quot;------testA&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/testB&quot;)</span><br><span class="line">    public String testB() &#123;</span><br><span class="line">        return &quot;------testB&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写完成后，启动项目</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1607529807085-1607609863773.png" alt="1607529807085"></p><p>​        但是，我们发现，无论如何刷新，Sentinel的页面并没有显示我们的项目</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1607529867022-1607609859326.png" alt="1607529867022"></p><p>​        这是因为Sentinel采用了懒加载，所以需要我们进行激活，激活的方式是调用任意接口一次即可。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1607530275224-1607609856121.png" alt="1607530275224"></p><h3 id="流控模式——QPS直接快速失败"><a href="#流控模式——QPS直接快速失败" class="headerlink" title="流控模式——QPS直接快速失败"></a>流控模式——QPS直接快速失败</h3><p><img src="http://cheng_qiwei.gitee.io/blog/img/1607609798330.png" alt="1607609798330"></p><p>新增成功后的展示内容如下：</p><p>​        当前的规则是每秒只允许 /testA 接口被调用一次。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1607609964963.png" alt="1607609964963"></p><p>测试：</p><p>​        每秒仅调用一次 /testA 接口就正常，当频繁快速点击调用 /testA 接口则失败</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1607610198022.png" alt="1607610198022"></p><h3 id="流控模式——线程直接快速失败"><a href="#流控模式——线程直接快速失败" class="headerlink" title="流控模式——线程直接快速失败"></a>流控模式——线程直接快速失败</h3><p><img src="http://cheng_qiwei.gitee.io/blog/img/1607610945394.png" alt="1607610945394"></p><p>新增成功后的展示内容如下：</p><p>​        当前的规则是只允许 /testB 接口被最多一个线程调用。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1607610979813.png" alt="1607610979813"></p><p>​        线程数的限制：比如a请求过来,处理很慢,在一直处理,此时b请求又过来了，此时因为a占用一个线程,此时要处理b请求就只有额外开启一个线程，那么就会报错。</p><p>测试：</p><p>​        我们修改一下 /testB 接口 ，模拟接口调用很慢的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/testB&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;------testB&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​        接下来，我们同时打开两个窗口，注意需要两个浏览器，同一个浏览器有时候会没有效果，调用接口，先调用的接口会响应结果，后面的直接报错。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1607612220131.png" alt="1607612220131"></p><h3 id="流控模式——QPS关联快速失败"><a href="#流控模式——QPS关联快速失败" class="headerlink" title="流控模式——QPS关联快速失败"></a>流控模式——QPS关联快速失败</h3><p>​        关联：当关联的资源到达阈值，就限流自己；例如：当与A关联的B达到阈值之后，就限流A自己</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1607613235033-1607756847329.png" alt="1607613235033"></p><p>​        当前的规则是当 /testA 接口的请求qps大于1时，就让 /testB 之后的请求直接失败。</p><p>测试：</p><p>​        我们使用postman或JMenter模拟频繁调用 /testA 接口的情况导致 /testA 接口的qps达到阈值，此时，我们调用 /testB 接口，此时，/testB 接口访问失败。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1607757756939.png" alt="1607757756939"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1607757797854.png" alt="1607757797854"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1607757824972.png" alt="1607757824972"></p><h3 id="流控模式——QPS链路快速失败"><a href="#流控模式——QPS链路快速失败" class="headerlink" title="流控模式——QPS链路快速失败"></a>流控模式——QPS链路快速失败</h3><p>​    链路流控模式指的是，当从某个接口过来的资源达到限流条件时，开启限流；它的功能有点类似于针对来源配置项，区别在于：针对来源是针对上级微服务，而链路流控是针对上级接口，也就是说它的粒度更细；</p><h4 id="编写测试代码"><a href="#编写测试代码" class="headerlink" title="编写测试代码"></a>编写测试代码</h4><h5 id="新增Service接口及其实现"><a href="#新增Service接口及其实现" class="headerlink" title="新增Service接口及其实现"></a>新增Service接口及其实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getOrder</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.annotation.SentinelResource;</span><br><span class="line"><span class="keyword">import</span> com.cheng.cloud.alibaba.service.OrderService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title">OrderService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SentinelResource(value = &quot;getOrder&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(<span class="keyword">new</span> Random().nextInt());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="controller新增一个接口，调用上面service的方法"><a href="#controller新增一个接口，调用上面service的方法" class="headerlink" title="controller新增一个接口，调用上面service的方法"></a>controller新增一个接口，调用上面service的方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@GetMapping(&quot;/test1&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">test1</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(id == <span class="number">1</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> orderService.getOrder();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;---/test1  id != 1&quot;</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/1607764678542.png" alt="1607764678542"></p><p>​        当前的规则是当 service中的getOrder 接口的请求qps大于1时，就让 /test1 之后的请求直接失败。</p><p>测试：</p><p>​        我们使用postman或JMenter模拟频繁调用 /test1 接口的情况导致 /test1 接口的qps达到阈值，此时，我们调用 /test1 接口，此时，/test1 接口访问失败。</p><p>​        but，测试时我们发现并没有效果   o(╥﹏╥)o</p><p>​        这是因为在在spring-cloud-alibaba v2.1.1.RELEASE及前，Sentinel1.7.0及后，关闭了URL PATH聚合，所以需要我们开启才能生效。【当前使用的是spring-cloud-alibaba v2.1.1.RELEASE和Sentinel1.8.0】</p><h4 id="开启方式："><a href="#开启方式：" class="headerlink" title="开启方式："></a>开启方式：</h4><h5 id="配置文件中关闭sentinel的CommonFilter实例化【默认是true，修改为false】"><a href="#配置文件中关闭sentinel的CommonFilter实例化【默认是true，修改为false】" class="headerlink" title="配置文件中关闭sentinel的CommonFilter实例化【默认是true，修改为false】"></a>配置文件中关闭sentinel的CommonFilter实例化【默认是true，修改为false】</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.cloud.sentinel.filter.enabled</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure><h5 id="添加一个配置类，自己构建CommonFilter实例"><a href="#添加一个配置类，自己构建CommonFilter实例" class="headerlink" title="添加一个配置类，自己构建CommonFilter实例"></a>添加一个配置类，自己构建CommonFilter实例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.adapter.servlet.CommonFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.FilterRegistrationBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SentinelContextConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@NOTE</span> 在spring-cloud-alibaba v2.1.1.RELEASE及前，sentinel1.7.0及后，关闭URL PATH聚合需要通过该方式，spring-cloud-alibaba v2.1.1.RELEASE后，可以通过配置关闭：spring.cloud.sentinel.web-context-unify=false</span></span><br><span class="line"><span class="comment">     * 手动注入Sentinel的过滤器，关闭Sentinel注入CommonFilter实例，修改配置文件中的 spring.cloud.sentinel.filter.enabled=false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">sentinelFilterRegistration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FilterRegistrationBean registration = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line">        registration.setFilter(<span class="keyword">new</span> CommonFilter());</span><br><span class="line">        registration.addUrlPatterns(<span class="string">&quot;/*&quot;</span>);</span><br><span class="line">        <span class="comment">// 入口资源关闭聚合</span></span><br><span class="line">        registration.addInitParameter(CommonFilter.WEB_CONTEXT_UNIFY, <span class="string">&quot;false&quot;</span>);</span><br><span class="line">        registration.setName(<span class="string">&quot;sentinelFilter&quot;</span>);</span><br><span class="line">        registration.setOrder(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> registration;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color='red'>        注意：这里spring-cloud-alibaba v2.1.0.RELEASE并没有CommonFilter.WEB_CONTEXT_UNIFY这个选项，所以请修改为2.1.1版本，如果你使用更新的spring-cloud-alibaba版本，在配置文件下就可以直接进行配置spring.cloud.sentinel.web-context-unify的属性为false，并引入sentinel-web-servlet的包【1.7.0版本】即可。</font></p><p>重新测试</p><p>​        当我们频繁调用/test1?id=1时，达到阈值后会产生异常</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1607766159350.png" alt="1607766159350"></p><p>​        而当我们使用其他id时，由于不走getOrder的方法，所以不会产生限流的效果</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1607766252450.png" alt="1607766252450"></p><h3 id="流控模式——QPS直接Warm-up"><a href="#流控模式——QPS直接Warm-up" class="headerlink" title="流控模式——QPS直接Warm up"></a>流控模式——QPS直接Warm up</h3><p>​        Warm up：预热、冷加载，经过预热时长后才会达到阈值，当系统长时间处于低请求的情况下，当流量突然瞬间增加时，直接把系统拉升到高水位可能使系统直接崩溃，通过冷加载的方式启动，使流量慢慢增加，到达一定时间后达到阈值，对系统比较友好。起始阈值计算公式：阈值/冷加载因子coldFactor(默认值为3)。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1607767547432.png" alt="1607767547432"></p><p>​        当前的规则是当 /testA 接口刚开始的请求qps大于2时，就让 /test1 之后的请求直接失败，经过5秒后，最大qps请求数为6。</p><p>测试：</p><p>​        我们该开始快速请求  /testA 接口时，由于冷加载的原因，最大的阈值是2，所以请求偶尔会出现失败的情况，当随着请求时间的增加，慢慢的请求失败次数降低，到了5s的时候，由于阈值达到了最大值6，所以几乎不会出现失败的情况</p><h3 id="流控模式——QPS直接排队等待"><a href="#流控模式——QPS直接排队等待" class="headerlink" title="流控模式——QPS直接排队等待"></a>流控模式——QPS直接排队等待</h3><p>​        排队等待：让请求以均匀的速度通过，每秒最多请求阈值数量的请求，其他请求进入等待状态，超过最大等待时间之后则返回失败（底层使用漏桶算法）。这种方式主要应用于处理间隔性突发的流量，例如消息队列，假设在某一秒有大量的请求进来，而接下来会有一段时间处于空闲期，我们希望系统能够在接下来的时间逐渐处理这些请求而不是在第一秒就直接拒绝这些请求。</p><p><font color='red'>注意：排队等待仅支持QPS，并不支持线程数。</font></p><p>​        新增测试方法 /test2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/test2&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       logger.info(Thread.currentThread().getName()+<span class="string">&quot;  ...test2!&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;---/test2&quot;</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/1607847380859.png" alt="1607847380859"></p><p>​        当前的规则是当 /test2 接口有大量请求进来时，我们每秒仅处理一个请求，其它请求进入等待中，当等待时间超过20s之后，返回失败。</p><p>测试：</p><p>​        快速请求 /test2 接口，查看控制台，我们发现，每秒仅处理一个请求</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1607847610188.png" alt="1607847610188"></p><h1 id="Sentinel的熔断降级"><a href="#Sentinel的熔断降级" class="headerlink" title="Sentinel的熔断降级"></a>Sentinel的熔断降级</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>​        除了流量控制以外，对调用链路中不稳定的资源进行熔断降级也是保障高可用的重要措施之一。一个服务常常会调用别的模块，可能是另外的一个远程服务、数据库，或者第三方 API 等。例如，支付的时候，可能需要远程调用银联提供的 API；查询某个商品的价格，可能需要进行数据库查询。然而，这个被依赖服务的稳定性是不能保证的。如果依赖的服务出现了不稳定的情况，请求的响应时间变长，那么调用服务的方法的响应时间也会变长，线程会产生堆积，最终可能耗尽业务自身的线程池，服务本身也变得不可用。</p><p>​        现代微服务架构都是分布式的，由非常多的服务组成。不同服务之间相互调用，组成复杂的调用链路。以上的问题在链路调用中会产生放大的效果。复杂链路上的某一环不稳定，就可能会层层级联，最终导致整个链路都不可用。因此我们需要对不稳定的<strong>弱依赖服务调用</strong>进行熔断降级，暂时切断不稳定调用，避免局部不稳定因素导致整体的雪崩。熔断降级作为保护自身的手段，通常在客户端（调用端）进行配置。</p><p>​        <font color='red'><strong>注意</strong>：本文档针对 Sentinel 1.8.0 及以上版本。1.8.0 版本对熔断降级特性进行了全新的改进升级，请使用最新版本以更好地利用熔断降级的能力。</font></p><h2 id="Sentinel的熔断策略"><a href="#Sentinel的熔断策略" class="headerlink" title="Sentinel的熔断策略"></a>Sentinel的熔断策略</h2><h3 id="慢调用比例-SLOW-REQUEST-RATIO"><a href="#慢调用比例-SLOW-REQUEST-RATIO" class="headerlink" title="慢调用比例 (SLOW_REQUEST_RATIO)"></a><strong>慢调用比例 (SLOW_REQUEST_RATIO)</strong></h3><p>​        选择以慢调用比例作为阈值，需要设置允许的慢调用 RT（即最大的响应时间），请求的响应时间大于该值则统计为慢调用。当单位统计时长（statIntervalMs）内请求数目大于设置的最小请求数目，并且慢调用的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求响应时间小于设置的慢调用 RT 则结束熔断，若大于设置的慢调用 RT 则会再次被熔断。</p><h4 id="熔断条件"><a href="#熔断条件" class="headerlink" title="熔断条件"></a>熔断条件</h4><p>​        a、请求数目大于设置的最小请求数目；</p><p>​        b、慢调用的比例大于阈值。</p><h4 id="1-8-升级内容"><a href="#1-8-升级内容" class="headerlink" title="1.8 升级内容"></a>1.8 升级内容</h4><p>​            Sentinel在1.8.0版本对熔断降级做了大的调整，可以定义任意时长的熔断时间，引入了半开启恢复支持。熔断状态由原来只有OPEN、CLOSED两种状态修改为OPEN、HALF_OPEN、CLOSED三种状态</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1607957908820.png" alt="1607957908820"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1607957790395.png" alt="1607957790395"></p><p>​        1.7.0版本中的RT对应1.8.0版本中的最大RT，1.7.0版本中的时间窗口对应1.8.0版本中的熔断时长，1.7.0版本中的最小请求数固定是5，而对应1.8.0版本中的最小请求数可以进行自定义，1.8.0版本中新增比例阈值，具体属性定义在下表：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1607957994736.png" alt="1607957994736"></p><h4 id="执行逻辑"><a href="#执行逻辑" class="headerlink" title="执行逻辑"></a>执行逻辑</h4><p>​        <strong>a、熔断（OPEN）：请求数大于最小请求数并且慢调用的比率大于比例阈值则发生熔断</strong>，熔断时长为用户自定义设置；</p><p>​        <strong>b、探测（HALFOPEN）</strong>：当熔断过了定义的熔断时长，状态由熔断（OPEN）变为探测（HALFOPEN）；</p><p>​        c、如果接下来的一个请求小于最大RT，说明慢调用已经恢复，结束熔断，状态由探测（HALF_OPEN）变更为关闭（CLOSED）；</p><p>​        d、如果接下来的一个请求大于最大RT，说明慢调用未恢复，继续熔断，熔断时长保持一致。</p><p>​        注意：Sentinel默认统计的RT上限是4900ms，超出此阈值的都会算作4900ms，若需要变更此上限可以通过启动配置项-Dcsp.sentinel.statistic.max.rt=xxx来配置。</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>​        a、添加测试代码   /testC</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/testC&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        logger.info(<span class="string">&quot;...testC!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;---/testC&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​        b、添加降级配置</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1607960194780.png" alt="1607960194780"></p><p>​        当前配置的规则是：允许每个请求消耗的最长时间为200毫秒，当超过时认定为慢调用，当每秒最小请求数大于5，且慢调用比例大于80%时，接下来1秒钟熔断，由于我们在测试方法中设置了等待1秒钟，所以所有请求都是慢调用，所以我们再进行请求时会触发熔断。</p><p>​        我们使用Jmeter来模拟调用【每秒请求10次】</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1607960486159.png" alt="1607960486159"></p><p>​        我们可以看到当Jmeter开始启动时，由于每次请求都是超时（超过80%）且每秒请求数为10，符合慢调用熔断的规则，所以我们的接口就被熔断了，当关闭Jmeter测试后，我们再访问接口，请求成功。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1607960562938.png" alt="1607960562938"></p><h3 id="异常比例-ERROR-RATIO"><a href="#异常比例-ERROR-RATIO" class="headerlink" title="异常比例 (ERROR_RATIO)"></a><strong>异常比例 (ERROR_RATIO)</strong></h3><p>​        当单位统计时长（statIntervalMs）内请求数目大于设置的最小请求数目，并且异常的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。异常比率的阈值范围是 [0.0, 1.0]，代表 0% - 100%。</p><h4 id="熔断条件-1"><a href="#熔断条件-1" class="headerlink" title="熔断条件"></a>熔断条件</h4><p>​        a、请求数目大于设置的最小请求数目；</p><p>​        b、异常调用的比例大于阈值。</p><h4 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h4><p><img src="http://cheng_qiwei.gitee.io/blog/img/1607961669359.png" alt="1607961669359"></p><h4 id="执行逻辑-1"><a href="#执行逻辑-1" class="headerlink" title="执行逻辑"></a>执行逻辑</h4><p>​        <strong>a、熔断（OPEN）：当请求数大于最小请求并且异常比例大于设置的阈值时触发熔断</strong>，熔断时长由用户设置；</p><p>​        <strong>b、探测（HALFOPEN）</strong>：当超过熔断时长时，由熔断（OPEN）转为探测（HALFOPEN）；</p><p>​        c、如果接下来的一个请求未发生错误，说明应用恢复，结束熔断，状态由探测（HALF_OPEN）变更为关闭（CLOSED）；</p><p>​        d、如果接下来的一个请求继续发生错误，说明应用未恢复，继续熔断，熔断时长保持一致。</p><h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><p>​        a、添加测试代码   /testD</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/testD&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testD</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> age = <span class="number">10</span>/<span class="number">0</span>; </span><br><span class="line">        logger.info(<span class="string">&quot;  ...testD!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;---/testD&quot;</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​        b、添加降级配置</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1607962634855.png" alt="1607962634855"></p><p>​        当前的规则是：允许所有请求的异常比例为30%，当超过时认定为异常接口，当每秒最小请求数大于5，且异常比例大于30%时，接下来5秒钟熔断，由于我们在测试方法中设置了by zero的异常，所以所有请求都是异常请求，所以我们再进行请求时会触发熔断。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1607963035797.png" alt="1607963035797"></p><p>​        我们依然使用Jmeter进行测试，测试方法同上。</p><p>​        我们可以看到当Jmeter开始启动时，由于每次请求都是异常（超过30%）且每秒请求数为10，符合异常比例熔断的规则，所以我们的接口就被熔断了，当关闭Jmeter测试后，我们再访问接口，请求成功。且这里测试过，我们的熔断时间为5s，当我们停止Jmeter之后立刻测试接口，接口会返回by zero的异常，这是因为两个条件之中的每秒最小请求数大于5的条件失效了，所以熔断效果不起作用了。</p><h3 id="异常数-ERROR-COUNT"><a href="#异常数-ERROR-COUNT" class="headerlink" title="异常数 (ERROR_COUNT)"></a><strong>异常数 (ERROR_COUNT)</strong></h3><p>​        当单位统计时长内的异常数目超过阈值之后会自动进行熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。</p><h4 id="熔断条件-2"><a href="#熔断条件-2" class="headerlink" title="熔断条件"></a>熔断条件</h4><p>​        a、请求数目大于设置的最小请求数目；</p><p>​        b、异常调用的数目大于阈值。</p><h4 id="配置参数-1"><a href="#配置参数-1" class="headerlink" title="配置参数"></a>配置参数</h4><p><img src="http://cheng_qiwei.gitee.io/blog/img/1608047548622.png" alt="1608047548622"></p><h4 id="执行逻辑-2"><a href="#执行逻辑-2" class="headerlink" title="执行逻辑"></a>执行逻辑</h4><p>​        <strong>a、熔断（OPEN）：当请求数大于最小请求并且异常数量大于设置的阈值时触发熔断</strong>，熔断时长由用户设置；</p><p>​        <strong>b、探测（HALFOPEN）</strong>：当超过熔断时长时，由熔断（OPEN）转为探测（HALFOPEN）；</p><p>​        c、如果接下来的一个请求未发生错误，说明应用恢复，结束熔断，状态由探测（HALF_OPEN）变更为关闭（CLOSED）；</p><p>​        d、如果接下来的一个请求继续发生错误，说明应用未恢复，继续熔断，熔断时长保持一致。</p><h4 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h4><p>​        a、测试代码依然使用  /testD</p><p>​        b、添加降级配置</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1608047915674.png" alt="1608047915674"></p><p>​        当前的规则是：在60s内，当达到最小请求数5，且发生异常的请求数大于6个时，发生熔断，由于我们在测试方法中设置了by zero的异常，所以所有请求都是异常请求，所以当我们请求6次后，会触发熔断。</p><p>1-6次返回</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1608048137053.png" alt="1608048137053"></p><p>第7次及之后一分钟内的请求</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1608048142861.png" alt="1608048142861"></p>]]></content>
      
      
      <categories>
          
          <category> SpringCloudAlibaba </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sentinel </tag>
            
            <tag> SpringCloudAlibaba </tag>
            
            <tag> 熔断降级 </tag>
            
            <tag> 流量控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux安装软件</title>
      <link href="/blog/2021/03/15/Linux%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6/"/>
      <url>/blog/2021/03/15/Linux%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux安装软件"><a href="#Linux安装软件" class="headerlink" title="Linux安装软件"></a>Linux安装软件</h1><h1 id="Linux安装JDK"><a href="#Linux安装JDK" class="headerlink" title="Linux安装JDK"></a>Linux安装JDK</h1><h2 id="一、安装包下载"><a href="#一、安装包下载" class="headerlink" title="一、安装包下载"></a>一、安装包下载</h2><p>&emsp;&emsp;可以通过修改指定版本的JDK来进行下载。下载完成后，将安装包推送到Linux服务器上。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.oracle.com/cn/java/technologies/javase/javase8-archive-downloads.html</span><br></pre></td></tr></table></figure><h2 id="二、解压安装包"><a href="#二、解压安装包" class="headerlink" title="二、解压安装包"></a>二、解压安装包</h2><p>&emsp;&emsp;将安装包指定解压到<code>/usr/local</code>目录下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxf jdk-8u141-linux-x64.tar.gz -C /usr/local</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210531101047748.png" alt="image-20210531101047748"></p><h2 id="三、编辑配置文件"><a href="#三、编辑配置文件" class="headerlink" title="三、编辑配置文件"></a>三、编辑配置文件</h2><p>&emsp;&emsp;编辑<code>/etc/profile</code>文件，编辑内容如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/local/jdk1.8.0_141 </span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH </span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210531101559203.png" alt="image-20210531101559203"></p><p>&emsp;&emsp;编辑完成后，保存，然后使用<code>source /etc/profile</code>刷新配置。</p><h2 id="四、验证安装结果"><a href="#四、验证安装结果" class="headerlink" title="四、验证安装结果"></a>四、验证安装结果</h2><p>&emsp;&emsp;使用<code>java -version</code>验证安装情况，如下则为成功。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210531101841276.png" alt="image-20210531101841276"></p><h1 id="Linux安装MySQL"><a href="#Linux安装MySQL" class="headerlink" title="Linux安装MySQL"></a>Linux安装MySQL</h1><h2 id="一、下载安装包"><a href="#一、下载安装包" class="headerlink" title="一、下载安装包"></a>一、下载安装包</h2><p>下载地址：<a href="https://downloads.mysql.com/archives/community/">https://downloads.mysql.com/archives/community/</a></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210203094022147.png" alt="image-20210203094022147"></p><p>下载完成后，放入Linux环境</p><h2 id="二、环境配置"><a href="#二、环境配置" class="headerlink" title="二、环境配置"></a>二、环境配置</h2><h3 id="1、检测环境是否自带MySQL，有的话强制卸载"><a href="#1、检测环境是否自带MySQL，有的话强制卸载" class="headerlink" title="1、检测环境是否自带MySQL，有的话强制卸载"></a>1、检测环境是否自带MySQL，有的话强制卸载</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa|grep mysql</span><br><span class="line"></span><br><span class="line">rpm -e --nodeps mysql-libs-5.1.52-1.el6_0.1.x86_64(对应包名)</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210203094806691.png" alt="image-20210203094806691"></p><h3 id="2、检测环境是否自带mariadb，有的话强制卸载"><a href="#2、检测环境是否自带mariadb，有的话强制卸载" class="headerlink" title="2、检测环境是否自带mariadb，有的话强制卸载"></a>2、检测环境是否自带mariadb，有的话强制卸载</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa|grep mariadb</span><br><span class="line"></span><br><span class="line">rpm -e --nodeps mariadb-libs-5.5.60-1.el7_5.x86_64(对应包名)</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210203094932667.png" alt="image-20210203094932667"></p><h2 id="三、安装"><a href="#三、安装" class="headerlink" title="三、安装"></a>三、安装</h2><h3 id="1、解压安装包到指定目录"><a href="#1、解压安装包到指定目录" class="headerlink" title="1、解压安装包到指定目录"></a>1、解压安装包到指定目录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxf mysql-5.7.28-linux-glibc2.12-x86_64.tar.gz -C /usr/local</span><br></pre></td></tr></table></figure><h3 id="2、将MySQL的文件名进行修改"><a href="#2、将MySQL的文件名进行修改" class="headerlink" title="2、将MySQL的文件名进行修改"></a>2、将MySQL的文件名进行修改</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv mysql-5.7.28-linux-glibc2.12-x86_64 mysql-5.7.28</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210203095720658.png" alt="image-20210203095720658"></p><h3 id="3、检查MySQL组和用户是否存在，如果没有则创建"><a href="#3、检查MySQL组和用户是否存在，如果没有则创建" class="headerlink" title="3、检查MySQL组和用户是否存在，如果没有则创建"></a>3、检查MySQL组和用户是否存在，如果没有则创建</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/group|grep mysql</span><br><span class="line"></span><br><span class="line">groupadd mysql</span><br><span class="line"></span><br><span class="line">useradd -r -g mysql mysql　　#useradd -r参数表示mysql用户是系统用户，不可用于登录系统</span><br></pre></td></tr></table></figure><h3 id="4、创建data目录"><a href="#4、创建data目录" class="headerlink" title="4、创建data目录"></a>4、创建data目录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd mysql-5.7.28</span><br><span class="line"></span><br><span class="line">mkdir data</span><br></pre></td></tr></table></figure><h3 id="5、将-usr-local-mysql-5-7-28的所有者及所属组改为mysql"><a href="#5、将-usr-local-mysql-5-7-28的所有者及所属组改为mysql" class="headerlink" title="5、将/usr/local/mysql-5.7.28的所有者及所属组改为mysql"></a>5、将/usr/local/mysql-5.7.28的所有者及所属组改为mysql</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R mysql.mysql /usr/local/mysql-5.7.28</span><br></pre></td></tr></table></figure><h3 id="6、在-usr-local-mysql-5-7-28-support-files目录下创建my-default-cnf"><a href="#6、在-usr-local-mysql-5-7-28-support-files目录下创建my-default-cnf" class="headerlink" title="6、在/usr/local/mysql-5.7.28/support-files目录下创建my_default.cnf"></a>6、在/usr/local/mysql-5.7.28/support-files目录下创建my_default.cnf</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">vim support-files/my_default.cnf</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">设置mysql的安装目录</span></span><br><span class="line">basedir =/usr/local/mysql-5.7.28</span><br><span class="line"><span class="meta">#</span><span class="bash">设置mysql数据库的数据存放目录</span></span><br><span class="line">datadir = /usr/local/mysql-5.7.28/data</span><br><span class="line"><span class="meta">#</span><span class="bash">设置端口</span></span><br><span class="line">port = 3306</span><br><span class="line"></span><br><span class="line">socket = /tmp/mysql.sock</span><br><span class="line"><span class="meta">#</span><span class="bash">设置字符集</span></span><br><span class="line">character-set-server=utf8</span><br><span class="line"><span class="meta">#</span><span class="bash">日志存放目录</span></span><br><span class="line">log-error = /usr/local/mysql-5.7.28/data/mysqld.log</span><br><span class="line">pid-file = /usr/local/mysql-5.7.28/data/mysqld.pid</span><br><span class="line"><span class="meta">#</span><span class="bash">允许时间类型的数据为零(去掉NO_ZERO_IN_DATE,NO_ZERO_DATE)</span></span><br><span class="line">sql_mode=ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION</span><br><span class="line"><span class="meta">#</span><span class="bash">ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION</span></span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210203104420394.png" alt="image-20210203104420394"></p><p>拷贝到/etc/my.cnf</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp support-files/my_default.cnf /etc/my.cnf</span><br></pre></td></tr></table></figure><h3 id="7、初始化MySQL"><a href="#7、初始化MySQL" class="headerlink" title="7、初始化MySQL"></a>7、初始化MySQL</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./bin/mysqld --initialize --user=mysql --basedir=/usr/local/mysql-5.7.28/ --datadir=/usr/local/mysql-5.7.28/data/</span><br><span class="line">初始化完成后，查看日志，如图，红框处为密码</span><br><span class="line">cat /usr/local/mysql-5.7.28/data/mysqld.log</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210203105340009.png" alt="image-20210203105340009"></p><h3 id="8、把启动脚本放到开机初始化目录"><a href="#8、把启动脚本放到开机初始化目录" class="headerlink" title="8、把启动脚本放到开机初始化目录"></a>8、把启动脚本放到开机初始化目录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp support-files/mysql.server /etc/init.d/mysql</span><br></pre></td></tr></table></figure><h3 id="9、启动MySQL"><a href="#9、启动MySQL" class="headerlink" title="9、启动MySQL"></a>9、启动MySQL</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysql start</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210203105834846.png" alt="image-20210203105834846"></p><h3 id="10、进入MySQL并更改密码，初始密码为1-3-7红框处"><a href="#10、进入MySQL并更改密码，初始密码为1-3-7红框处" class="headerlink" title="10、进入MySQL并更改密码，初始密码为1.3.7红框处"></a>10、进入MySQL并更改密码，初始密码为1.3.7红框处</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">./bin/mysql -u root -p</span><br><span class="line"></span><br><span class="line">-- 修改密码</span><br><span class="line"></span><br><span class="line">set password=password(&#x27;123456&#x27;);</span><br><span class="line"></span><br><span class="line">grant all privileges on *.* to root@&#x27;%&#x27; identified by &#x27;123456&#x27;;</span><br><span class="line"></span><br><span class="line">flush privileges;</span><br><span class="line"></span><br><span class="line">-- 添加远程访问权限（这一步正常不需要）</span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> use mysql;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> update user <span class="built_in">set</span> host=<span class="string">&#x27;%&#x27;</span> <span class="built_in">where</span> user = <span class="string">&#x27;root&#x27;</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> flush privileges;</span></span><br><span class="line"></span><br><span class="line">如果更改时报错：ERROR 1062 (23000): Duplicate entry &#x27;%-root&#x27; for key &#x27;PRIMARY&#x27;，就先查询一下是否已更改，最后执行刷新。</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210203110726831.png" alt="image-20210203110726831"></p><h3 id="11、修改完成后，退出重启MySQL"><a href="#11、修改完成后，退出重启MySQL" class="headerlink" title="11、修改完成后，退出重启MySQL"></a>11、修改完成后，退出重启MySQL</h3><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210203110801140.png" alt="image-20210203110801140"></p><h3 id="12、测试安装情况"><a href="#12、测试安装情况" class="headerlink" title="12、测试安装情况"></a>12、测试安装情况</h3><h4 id="a、开放端口"><a href="#a、开放端口" class="headerlink" title="a、开放端口"></a>a、开放端口</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=3306/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210203111019106.png" alt="image-20210203111019106"></p><h4 id="b、使用连接工具连接"><a href="#b、使用连接工具连接" class="headerlink" title="b、使用连接工具连接"></a>b、使用连接工具连接</h4><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210203113223908.png" alt="image-20210203113223908"></p><h2 id="四、设置开机自启动"><a href="#四、设置开机自启动" class="headerlink" title="四、设置开机自启动"></a>四、设置开机自启动</h2><h3 id="1、复制mysql-server"><a href="#1、复制mysql-server" class="headerlink" title="1、复制mysql.server"></a>1、复制mysql.server</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/local/mysql-5.7.28/support-files/mysql.server /etc/rc.d/init.d/mysqld                           </span><br></pre></td></tr></table></figure><h3 id="2、赋予可执行权限"><a href="#2、赋予可执行权限" class="headerlink" title="2、赋予可执行权限"></a>2、赋予可执行权限</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /etc/init.d/mysqld</span><br></pre></td></tr></table></figure><h3 id="3、添加为服务"><a href="#3、添加为服务" class="headerlink" title="3、添加为服务"></a>3、添加为服务</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --add mysqld</span><br></pre></td></tr></table></figure><h3 id="4、查看服务列表"><a href="#4、查看服务列表" class="headerlink" title="4、查看服务列表"></a>4、查看服务列表</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --list</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210203113758438.png" alt="image-20210203113758438"></p><p>如果看到3、4、5状态为开或者为 on 则表示成功。如果是 关或者 off 则执行一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig --level 345 mysqld on</span><br></pre></td></tr></table></figure><h3 id="5、MySQL启动添加全局配置"><a href="#5、MySQL启动添加全局配置" class="headerlink" title="5、MySQL启动添加全局配置"></a>5、MySQL启动添加全局配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/local/mysql-5.7.28/bin/mysql /usr/sbin</span><br></pre></td></tr></table></figure><p>至此、Linux安装MySQL结束</p><h1 id="Linux安装zookeeper"><a href="#Linux安装zookeeper" class="headerlink" title="Linux安装zookeeper"></a>Linux安装zookeeper</h1><blockquote><p>由于镜像网站似乎有问题无法下载，zookeeper的下载目录更新为：</p><p><a href="https://archive.apache.org/dist/zookeeper/">https://archive.apache.org/dist/zookeeper/</a></p></blockquote><h2 id="一、下载安装包-3-6-2为当前稳定版"><a href="#一、下载安装包-3-6-2为当前稳定版" class="headerlink" title="一、下载安装包(3.6.2为当前稳定版)"></a>一、下载安装包(3.6.2为当前稳定版)</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://mirror.bit.edu.cn/apache/zookeeper/zookeeper-3.6.2/apache-zookeeper-3.6.2-bin.tar.gz</span><br></pre></td></tr></table></figure><h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h2><h3 id="1、解压安装包到指定目录-并修改文件命名"><a href="#1、解压安装包到指定目录-并修改文件命名" class="headerlink" title="1、解压安装包到指定目录,并修改文件命名"></a>1、解压安装包到指定目录,并修改文件命名</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar zxf apache-zookeeper-3.6.2-bin.tar.gz -C /usr/local</span><br><span class="line"></span><br><span class="line">mv cd /usr/local &amp;&amp; apache-zookeeper-3.6.2-bin/ zookeeper-3.6.2</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210203115332142.png" alt="image-20210203115332142"></p><h3 id="2、复制zoo-sample-cfg为zoo-cfg"><a href="#2、复制zoo-sample-cfg为zoo-cfg" class="headerlink" title="2、复制zoo_sample.cfg为zoo.cfg"></a>2、复制zoo_sample.cfg为zoo.cfg</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/zookeeper-3.6.2/conf &amp;&amp; cp zoo_sample.cfg  zoo.cfg</span><br></pre></td></tr></table></figure><h3 id="3、修改zoo-cfg配置文件"><a href="#3、修改zoo-cfg配置文件" class="headerlink" title="3、修改zoo.cfg配置文件"></a>3、修改zoo.cfg配置文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dataDir=/usr/local/zookeeper-3.6.2/data</span><br><span class="line">dataLogDir=/usr/local/zookeeper-3.6.2/log</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210203134920805.png" alt="image-20210203134920805"></p><p><font color='red' size='4.5px'><strong>修改配置后需要在zookeeper-3.6.2目录下创建data和log两个文件夹来保存数据和日志</strong></font></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210203135701077.png" alt="image-20210203135701077"></p><h3 id="4、设置环境变量"><a href="#4、设置环境变量" class="headerlink" title="4、设置环境变量"></a>4、设置环境变量</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line">export ZOOKEEPER_INSTALL=/usr/local/zookeeper-3.6.2/</span><br><span class="line"></span><br><span class="line">export PATH=$PATH:$ZOOKEEPER_INSTALL/bin</span><br><span class="line"></span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210203141417540.png" alt="image-20210203141417540"></p><h3 id="5、启动zookeeper"><a href="#5、启动zookeeper" class="headerlink" title="5、启动zookeeper"></a>5、启动zookeeper</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh zkServer.sh start</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210203141629244.png" alt="image-20210203141629244"></p><h3 id="6、查看zookeeper状态"><a href="#6、查看zookeeper状态" class="headerlink" title="6、查看zookeeper状态"></a>6、查看zookeeper状态</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh zkServer.sh status</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210203141731035.png" alt="image-20210203141731035"></p><h3 id="7、查看zookeeper进程"><a href="#7、查看zookeeper进程" class="headerlink" title="7、查看zookeeper进程"></a>7、查看zookeeper进程</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux|grep &#x27;zookeeper&#x27;</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210203141819414.png" alt="image-20210203141819414"></p><h3 id="8、关闭zookeeper"><a href="#8、关闭zookeeper" class="headerlink" title="8、关闭zookeeper"></a>8、关闭zookeeper</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh zkServer.sh stop</span><br></pre></td></tr></table></figure><p>至此、Linux安装zookeeper结束</p>]]></content>
      
      
      <categories>
          
          <category> 软件安装 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 安装 </tag>
            
            <tag> MySQL </tag>
            
            <tag> zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务和Alibaba Seata的介绍和使用</title>
      <link href="/blog/2021/03/15/Seata%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
      <url>/blog/2021/03/15/Seata%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式事务和Alibaba-Seata的介绍和使用"><a href="#分布式事务和Alibaba-Seata的介绍和使用" class="headerlink" title="分布式事务和Alibaba  Seata的介绍和使用"></a>分布式事务和Alibaba  Seata的介绍和使用</h1><h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><h2 id="什么是分布式事务？"><a href="#什么是分布式事务？" class="headerlink" title="什么是分布式事务？"></a>什么是分布式事务？</h2><p>&emsp;&emsp;在一次大的操作由不同的小的操作组成的，这些小的操作分布在不同的服务器上，分布式需要保证这些小操作要么全部成功，要么全部失败。本质上讲，分布式事务就是为了保证不同数据库的数据一致性。</p><h2 id="分布式事务产生的原因？"><a href="#分布式事务产生的原因？" class="headerlink" title="分布式事务产生的原因？"></a>分布式事务产生的原因？</h2><h3 id="原因一：数据库的分库分表"><a href="#原因一：数据库的分库分表" class="headerlink" title="原因一：数据库的分库分表"></a>原因一：数据库的分库分表</h3><p>&emsp;&emsp;当数据库单表数据超过千万级别，就需要考虑分库分表的问题，那么我们的系统就会从原来的一个数据库变成多个数据库，那么此时我们在同时操作多个数据库时，就需要保证数据的一致性，所以就需要使用分布式事务。</p><h3 id="原因二：应用SOA化"><a href="#原因二：应用SOA化" class="headerlink" title="原因二：应用SOA化"></a>原因二：应用SOA化</h3><p>&emsp;&emsp;所谓SOA化，就是业务的服务化。我们一个系统在访问量上去之后，我们会考虑把不同的功能放到不同的服务上面去运行，此时如果我们需要操作一连串功能，那么我们可能需要操作不同的服务，不同的数据库，为了保证数据的一致性，我们就需要使用分布式事务。</p><p>&emsp;&emsp;总结：不管是上面的那种方式，归根结底就是需要操作不同的数据库，为了保证数据的一致性，从而产生分布式事务。</p><h1 id="分布式理论"><a href="#分布式理论" class="headerlink" title="分布式理论"></a>分布式理论</h1><h2 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h2><p>&emsp;&emsp;CAP定理是由加州大学伯克利分校Eric Brewer教授提出来的，他指出WEB服务无法同时满足一下3个属性：</p><ul><li><p>一致性(Consistency) ： 客户端知道一系列的操作都会同时发生(生效)；</p></li><li><p>可用性(Availability) ： 每个操作都必须以可预期的响应结束；</p></li><li><p>分区容错性(Partition tolerance) ： 即使出现单个组件无法可用,操作依然可以完成。</p><p><img src="https://www.wangbase.com/blogimg/asset/201807/bg2018071607.jpg" alt="img"></p></li></ul><h3 id="CAP属性解读"><a href="#CAP属性解读" class="headerlink" title="CAP属性解读"></a>CAP属性解读</h3><p>&emsp;&emsp;<strong>a、分区容错性</strong>：指的分布式系统中的某个节点或者网络分区出现了故障的时候，整个系统仍然能对外提供满足一致性和可用性的服务。也就是说部分故障不影响整体使用。</p><p>事实上我们在设计分布式系统是都会考虑到bug，硬件，网络等各种原因造成的故障，所以即使部分节点或者网络出现故障，我们要求整个系统还是要继续使用的。</p><p>(不继续使用,相当于只有一个分区,那么也就没有后续的一致性和可用性了)</p><p>&emsp;&emsp;<strong>b、可用性：</strong> 一直可以正常的做读写操作。简单而言就是客户端一直可以正常访问并得到系统的正常响应。用户角度来看就是不会出现系统操作失败或者访问超时等问题。</p><p>&emsp;&emsp;<strong>c、一致性</strong>：在分布式系统完成某写操作后任何读操作，都应该获取到该写操作写入的那个最新的值。相当于要求分布式系统中的各节点时时刻刻保持数据的一致性。</p><h3 id="一致性与可用性的矛盾"><a href="#一致性与可用性的矛盾" class="headerlink" title="一致性与可用性的矛盾"></a>一致性与可用性的矛盾</h3><p>&emsp;&emsp;一致性和可用性，为什么不可能同时成立？答案很简单，因为可能通信失败（即出现分区容错）。</p><p>&emsp;&emsp;我们举个例子，以下图为例：</p><p><img src="https://www.wangbase.com/blogimg/asset/201807/bg2018071601.png" alt="img"></p><p>&emsp;&emsp;client修改G1中V0的数据为V1，按照正常情况下，修改之后，G1通知G2，V0修改为V1了，然后G2也同步修改为V1，name此时client读取G1或G2的数据都是V1；</p><p>&emsp;&emsp;但是，如果此时G1与G2之间的网络通信出现延迟或异常，那么G1中V0的数据为V1，但是G2还不知道，所以此时G2的数据还是V0</p><p>&emsp;&emsp;如果保证 G2 的一致性，那么 G1 必须在写操作时，锁定 G2 的读操作和写操作。只有数据同步后，才能重新开放读写。锁定期间，G2 不能读写，没有可用性。</p><p>&emsp;&emsp;如果保证 G2 的可用性，那么势必不能锁定 G2，所以一致性不成立。</p><p>&emsp;&emsp;综上所述，G2 无法同时做到一致性和可用性。系统设计时只能选择一个目标。如果追求一致性，那么无法保证所有节点的可用性；如果追求所有节点的可用性，那就没法做到一致性。这也是我们一直只看到只有AP或CP的选择，没有选择CA的操作，而且放弃分区容错性，也意味着放弃系统的扩展性，系统不再是分布式的，有违设计的初衷。</p><h3 id="CAP特性的取舍策略"><a href="#CAP特性的取舍策略" class="headerlink" title="CAP特性的取舍策略"></a>CAP特性的取舍策略</h3><p>&emsp;&emsp;a、满足AP舍弃C，也就是满足可用性和容错性，舍弃一致性。这也就是意味着你的系统在并发访问的时候可能会出现数据不一致的情况。事实证明，大多数都是牺牲了一致性。像12306还有淘宝网，就好比是你买火车票，本来你看到的是还有一张票，其实在这个时刻已经被买走了，你填好了信息准备买的时候发现系统提示你没票了，这就是牺牲了一致性。</p><p>&emsp;&emsp;b、满足CP舍弃A，也就是满足一致性和容错性，舍弃可用性。如果你的系统允许有段时间的访问失效等问题，这个是可以满足的（确实来讲用户体验会很差）。</p><h2 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h2><p>&emsp;&emsp;在上面CAP的介绍中，我们说CAP三者不能同时满足，而分区容错对于分布式系统来讲，是必须的，所以出现BASE理论。BASE理论如图相当于CAP中的AP。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/9825bc315c6034a8b7e1a56f6737965008237682.jpeg" alt="9825bc315c6034a8b7e1a56f6737965008237682"></p><h3 id="什么是BASE理论"><a href="#什么是BASE理论" class="headerlink" title="什么是BASE理论"></a>什么是BASE理论</h3><p>&emsp;&emsp;BASE理论是 Basically Available(基本可用)，Soft state（软状态）和 Eventually consistent（最终一致性）三个短语的缩写，来自 ebay 的架构师提出。他的核心思想是：即使无法做到强一致性（Strong Consistency，CAP 的一致性就是强一致性），但应用可以采用适合的方式达到<strong>最终一致性</strong>（Eventual Consitency）。</p><h4 id="基本可用性（Basically-Available）"><a href="#基本可用性（Basically-Available）" class="headerlink" title="基本可用性（Basically Available）"></a>基本可用性（Basically Available）</h4><p>&emsp;&emsp;基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性<font color='red'>（但请注意，这绝不等价于系统不可用，以下两个就是“基本可用”的典型例子）</font>。</p><ul><li>响应时间上的损失：正常情况下，一个在线搜索引擎需要0.5秒内返回给用户相应的查询结果，但由于出现异常（比如系统部分机房发生断电或断网故障），查询结果的响应时间增加到了1~2秒。</li><li>功能上的损失：正常情况下，在一个电子商务网站上进行购物，消费者几乎能够顺利地完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。</li></ul><h4 id="软状态（Soft-state）"><a href="#软状态（Soft-state）" class="headerlink" title="软状态（Soft state）"></a>软状态（Soft state）</h4><p>&emsp;&emsp;软状态也称为弱状态，和硬状态相对，是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步过程存在延时。</p><h4 id="最终一致性（Eventual-Consitency）"><a href="#最终一致性（Eventual-Consitency）" class="headerlink" title="最终一致性（Eventual Consitency）"></a>最终一致性（Eventual Consitency）</h4><p>&emsp;&emsp;最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p><p>而在实际工程实践中，<strong>最终一致性分为 5 种：</strong></p><p><strong>a、因果一致性（Causal consistency）</strong></p><p>&emsp;&emsp;如果节点 A 在更新完某个数据后通知了节点 B，那么节点 B 之后对该数据的访问和修改都是基于 A 更新后的值。与此同时，和节点 A 无因果关系的节点 C 的数据访问则没有这样的限制。</p><p><strong>b、 读己之所写（Read your writes）</strong></p><p>&emsp;&emsp;这种就很简单了，节点 A 更新一个数据后，它自身总是能访问到自身更新过的最新值，而不会看到旧值。其实也算一种因果一致性。</p><p><strong>c、会话一致性（Session consistency）</strong></p><p>&emsp;&emsp;会话一致性将对系统数据的访问过程框定在了一个会话当中：系统能保证在同一个有效的会话中实现 “读己之所写” 的一致性，也就是说，执行更新操作之后，客户端能够在同一个会话中始终读取到该数据项的最新值。</p><p><strong>d、 单调读一致性（Monotonic read consistency）</strong></p><p>&emsp;&emsp;单调读一致性是指如果一个节点从系统中读取出一个数据项的某个值后，那么系统对于该节点后续的任何数据访问都不应该返回更旧的值。</p><p><strong>e、单调写一致性（Monotonic write consistency）</strong></p><p>&emsp;&emsp;指一个系统要能够保证来自同一个节点的写操作被顺序的执行。</p><p>&emsp;&emsp;然而，在实际的实践中，这 5 种系统往往会结合使用，以构建一个具有最终一致性的分布式系统。实际上，不只是分布式系统使用最终一致性，关系型数据库在某个功能上，也是使用最终一致性的，比如备份，数据库的复制过程是需要时间的，这个复制过程中，业务读取到的值就是旧的。当然，最终还是达成了数据一致性。这也算是一个最终一致性的经典案例。</p><p>&emsp;&emsp;总的来说，BASE 理论面向的是大型高可用可扩展的分布式系统，和传统事务的 ACID 是<strong>相反的</strong>，它完全不同于 ACID 的强一致性模型，而是<strong>通过牺牲强一致性</strong>来获得可用性，并允许数据在一段时间是不一致的。</p><h1 id="分布式事务的解决方案"><a href="#分布式事务的解决方案" class="headerlink" title="分布式事务的解决方案"></a>分布式事务的解决方案</h1><p><font size='5px'><strong>刚性事务</strong></font></p><h2 id="2PC（-XA-Transactions）"><a href="#2PC（-XA-Transactions）" class="headerlink" title="2PC（ XA Transactions）"></a>2PC（ XA Transactions）</h2><p>&emsp;&emsp;XA，是一个两阶段的提交协议，定义了事务管理器（Transaction Manager）和资源管理器（Resource Manager）之间的接口。通过引入协调者（Coordinator）来协调参与者的行为，并最终决定这些参与者是否要真正执行事务，该协议分为以下两个阶段：</p><p>a、第一阶段：事务协调器要求每个涉及到事务的数据库预提交（precommit）此操作，并反馈可以提交；</p><p>b、第二阶段：事务协调器要求每个数据库提交或回滚事务。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1609605610807.png" alt="1609605610807"></p><p>两阶段提交这种解决方案属于牺牲了一部分可用性来换取的一致性。</p><p><strong>优点：</strong> <font color='red'>尽量</font>保证了数据的强一致，适合对数据强一致要求很高的关键领域。（其实也不能100%保证强一致）</p><p><strong>缺点：</strong> </p><p>&emsp;&emsp;a、同步阻塞：所有事务参与者在等待其他参与者响应的时候都处于同步阻塞的状态，无法进行其他操作；</p><p>&emsp;&emsp;b、单点问题：协调者在2PC中起到非常关键的作用，如果发生故障则会造成严重的影响，特别是在第二阶段发生故障，则所有参与者都会一直等待，无法进行其他操作；</p><p>&emsp;&emsp;c、数据不一致：在第二阶段，如果协调者只发送了部分commit的消息，那么如果此时发生网络异常，那么就只有部分参与者提交了事务，使得数据不一致（<font color='red'>所有的分布式事务都不是能够完全解决数据不一致的问题，只能说是尽量做到避免数据不一致的情况出现</font>）；</p><p>&emsp;&emsp;d、容错率低：任意一个节点失败就会导致整个事务失败，没有完善的容错机制。</p><p>XA并不是Java的规范，而是一种通用的规范。而JTA则是满足XA规范的用于Java开发的规范。</p><h3 id="2PC的实现——atomikos"><a href="#2PC的实现——atomikos" class="headerlink" title="2PC的实现——atomikos"></a>2PC的实现——atomikos</h3><p>&emsp;&emsp;这里使用<a href="https://blog.csdn.net/leilei1366615/article/details/104678279%E6%96%87%E7%AB%A0%E7%9A%84%E4%BB%A3%E7%A0%81%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95%EF%BC%8C%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80%EF%BC%9Ahttps://cheng_qiwei.gitee.io/blog/resource/file/springboot-mybatis-plus-atomikos.zip%E9%80%9A%E8%BF%87%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AA%E6%95%B0%E6%8D%AE%E6%BA%90%EF%BC%8C%E6%9D%A5%E5%90%8C%E6%97%B6%E4%BF%9D%E5%AD%98user%E3%80%81role%E3%80%81userRole%E4%B8%89%E5%BC%A0%E8%A1%A8%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E6%88%91%E4%BB%AC%E9%A6%96%E5%85%88%E5%B0%86%E5%BC%82%E5%B8%B8%E6%B3%A8%E9%87%8A%EF%BC%8C%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AC%A1%E6%AD%A3%E5%B8%B8%E7%9A%84%E4%BF%9D%E5%AD%98%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%EF%BC%8C%E6%95%B0%E6%8D%AE%E9%83%BD%E8%A2%AB%E6%88%90%E5%8A%9F%E4%BF%9D%E5%AD%98%EF%BC%8C%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%B9%9F%E6%98%AF%E6%A0%B9%E6%8D%AE2PC%E7%9A%84%E8%A7%84%E5%88%99%EF%BC%8C%E5%85%88%E6%89%A7%E8%A1%8C%E9%A2%84%E6%8F%90%E4%BA%A4%EF%BC%8C%E5%86%8D%E6%89%80%E6%9C%89%E9%83%BD%E6%88%90%E5%8A%9F%E5%90%8E%E6%89%A7%E8%A1%8Ccommit%E8%BF%9B%E8%A1%8C%E4%BF%9D%E5%AD%98%E3%80%82">https://blog.csdn.net/leilei1366615/article/details/104678279文章的代码进行测试，完整代码下载地址：https://cheng_qiwei.gitee.io/blog/resource/file/springboot-mybatis-plus-atomikos.zip通过配置多个数据源，来同时保存user、role、userRole三张表的数据，我们首先将异常注释，执行一次正常的保存，我们可以看到，数据都被成功保存，控制台也是根据2PC的规则，先执行预提交，再所有都成功后执行commit进行保存。</a></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1609684240746.png" alt="1609684240746"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1609684376913.png" alt="1609684376913"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1609684452348.png" alt="1609684452348"></p><p>&emsp;&emsp;然后我们打开异常，再执行一次，我们可以发现，当出现异常后，前面的数据并没有保存到数据库，而是回滚了，我们通过控制台也可以看见，当执行到异常那一行后，前面两个预提交的事务被注销了，所以就保证了数据的一致性。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1609684731890.png" alt="1609684731890"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1609684802598.png" alt="1609684802598"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1609684923835.png" alt="1609684923835"></p><h2 id="3PC（三阶段事务提交）"><a href="#3PC（三阶段事务提交）" class="headerlink" title="3PC（三阶段事务提交）"></a>3PC（三阶段事务提交）</h2><p>&emsp;&emsp;3PC是2PC的升级版，他是在2PC的基础上，<strong>同时在协调者和参与者中都引入了超时机制</strong>。3PC分为以下几个阶段：</p><p>a、<strong>cancommit</strong>阶段：类似于2PC的准备阶段，协调者向参与者发送commit请求，参与者如果可以提交就返回Yes响应，否则返回No响应；</p><p>b、<strong>preparecommit</strong>阶段：协调者根据参与者的反馈情况来决定是否可以执行事务PreCommit操作；</p><p>c、<strong>doCommit</strong>阶段:该阶段进行真正的事务提交。该阶段进行真正的事务提交，也可以分为以下两种情况。</p><p>&emsp;&emsp;c1、执行提交，参与者首先发送提交请求协调接收到参与者发送的ACK响应，那么协调者将从预提交状态进入到提交状态。并向所有参与者发送doCommit请求。参与者接收到doCommit请求之后，执行正式的事务提交，并在完成事务提交之后释放所有事务资源。接着事务提交完之后，参与者向协调者发送Ack响应。最后协调者接收到所有参与者的ack响应之后，完成事务。</p><p>&emsp;&emsp;c2、中断事务，协调者没有接收到参与者发送的ACK响应。（可能是接受者发送的不是ACK响应，也可能响应超时）。协调者向所有参与者发送终止请求，参与者在接收到终止请求后，会利用其在二阶段记录的信息来执行事务回滚操作，并在完成事务回滚之后释放所有事务资源。回滚之后，向协调者发送Ack信息，中断事务。</p><p>&emsp;&emsp;<font color='red'>注意事项：在阶段三，会出现以下两种故障，第一是协调者出现问题，第二是协调者和参与者之间的网络出现故障。但无论是哪种情况，最终都会导致参与者无法及时接收来自协调者的提交或回滚的请求，针对这种情况，3PC的解决方案是在参与者等待超时之后，会继续对事物进行commit操作，这样的操作相对于2PC中继续等待来讲是降低了参与者的阻塞范围，但这样操作后必然出现数据不一致性。</font></p><p><font size='5px'><strong>柔性事务</strong></font></p><h2 id="TCC（Try-Confirm-Cancel）两阶段补偿性方案"><a href="#TCC（Try-Confirm-Cancel）两阶段补偿性方案" class="headerlink" title="TCC（Try-Confirm-Cancel）两阶段补偿性方案"></a>TCC（Try-Confirm-Cancel）两阶段补偿性方案</h2><p> &emsp;&emsp;TCC 也是2PC的一种变体，其实就是采用的补偿机制，其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。TCC主要分为三个阶段：</p><p>&emsp;&emsp;Try阶段：对业务系统做检测及资源预留；</p><p>&emsp;&emsp;Confirm阶段：对业务系统做确认提交，Try阶段执行成功并开始执行confirm阶段时，默认confirm阶段是不会出错的；</p><p>&emsp;&emsp;Cancel阶段：在业务执行错误时，需要回滚的时候执行的业务取消并将预留的资源释放。</p><p><strong>根据上面的描述，我们举个栗子：</strong></p><p>&emsp;&emsp;假设有一个支付订单的场景：当我们支付完一笔订单后，我们需要进行以下几个步骤的操作</p><p>&emsp;&emsp;&emsp;a、更改订单状态为已支付；</p><p>&emsp;&emsp;&emsp;b、扣减商品库存；</p><p>&emsp;&emsp;&emsp;c、会员增加积分；</p><p>&emsp;&emsp;&emsp;d、创建销售单。</p><p>&emsp;&emsp;那么，我们现在肯定希望的效果是，上述几个步骤在一次操作中同时成功或同时失败，必须是一个整体性的事务。但是，但我们上述这几个操作都在不同的服务上，且系统无进行任何分布式事务处理时，当我们已经执行了更改订单状态，扣减商品库存之后，会员积分服务突然挂了，此时后面的创建销售单操作也无法执行，但是订单状态已经更改，商品库存已经扣除，这就出现了数据不一致的问题。</p><p>&emsp;&emsp;现在，我们来使用TCC对我们的项目进行改造，首先是T（Try）阶段，这个阶段，我们不是直接一步到位就把订单状态给改了或者对商品数量接直接给减了，而是一个预备的过程。例如按照我们上面的例子来讲，我们可以首先将订单更改为支付中的一个状态，扣减商品库存也不是真的扣减，而是增加一个字段，用来先保存我们扣减的商品的数量，积分也是增加字段，用来保存增加的积分……，这一步执行的真正目的除了保留了一些需要使用的资源（例如冻结部分资源）以外，也确保了底层的数据源（数据库、redis、es）等都是正常的。</p><p>&emsp;&emsp;接着，到了C（Confirm）阶段，如果第一阶段运行顺利，所有操作都成功了，那么就可以执行Confirm阶段的操作，正式把数据修改到数据库，比如说，把订单修改为已支付，扣减商品库存，增加积分……，同时将预备的数据清除掉。</p><p>&emsp;&emsp;上面的C是指正常情况下的处理方法，那么如果出现异常呢？例如上面说的会员积分服务突然挂了，那么就需要第二个C（Cancel）阶段来处理了，该阶段，我们需要把之前半修改的数据修改回来，例如说，把订单支付中的状态修改为待支付的状态，保存商品扣减数量的字段删除对应的数量……，这样就回滚了数据，保证了数据的一致性。</p><p>&emsp;&emsp;那么，根据上述内容，如果某个服务突然发生意外，然后进行重启，TCC是如何保证之前没有执行的分布式事务继续执行呢？如果某个服务一直Confirm或cancel失败怎么办？其实，事务框架都是需要记录各个服务的状态，可以在文件或数据库进行记录，保存分布式事务运行的各个状态，可以通过日志记录进行重试，使其成功，且如果第一步try如果成功进行的话，如果不是代码有bug的话，一般不会出现Confirm或cancel失败的情况。</p><p><strong>TCC的优点及缺点</strong></p><p>&emsp;&emsp;<strong>优点：</strong> 跟2PC比起来，实现以及流程相对简单了一些，但数据的一致性比2PC也要差一些；</p><p>&emsp;&emsp;<strong>缺点：</strong> 缺点还是比较明显的，在2,3步中都有可能失败。TCC属于应用层的一种补偿方式，所以需要程序员在实现的时候多写很多补偿的代码，在一些场景中，一些业务流程可能用TCC不太好定义及处理。</p><h1 id="springCloudAlibaba——Seata"><a href="#springCloudAlibaba——Seata" class="headerlink" title="springCloudAlibaba——Seata"></a>springCloudAlibaba——Seata</h1><p>&emsp;&emsp;Seata 是一款Alibaba开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。</p><h2 id="Seata的重要概念"><a href="#Seata的重要概念" class="headerlink" title="Seata的重要概念"></a>Seata的重要概念</h2><h3 id="TC-Transaction-Coordinator-事务协调者"><a href="#TC-Transaction-Coordinator-事务协调者" class="headerlink" title="TC (Transaction Coordinator) - 事务协调者"></a>TC (Transaction Coordinator) - 事务协调者</h3><p>&emsp;&emsp;维护全局和分支事务的状态，驱动全局事务提交或回滚。</p><h3 id="TM-Transaction-Manager-事务管理器"><a href="#TM-Transaction-Manager-事务管理器" class="headerlink" title="TM (Transaction Manager) - 事务管理器"></a>TM (Transaction Manager) - 事务管理器</h3><p>&emsp;&emsp;定义全局事务的范围：开始全局事务、提交或回滚全局事务。</p><h3 id="RM-Resource-Manager-资源管理器"><a href="#RM-Resource-Manager-资源管理器" class="headerlink" title="RM (Resource Manager) - 资源管理器"></a>RM (Resource Manager) - 资源管理器</h3><p>&emsp;&emsp;管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</p><h3 id="Transaction-ID：XID"><a href="#Transaction-ID：XID" class="headerlink" title="Transaction ID：XID"></a>Transaction ID：XID</h3><p>&emsp;&emsp;全局唯一的事务ID</p><h2 id="Seata的工作流程"><a href="#Seata的工作流程" class="headerlink" title="Seata的工作流程"></a>Seata的工作流程</h2><p>1、TM向TC申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的XID；</p><p>2、XID在微服务调用链路的上下文中传播（也就是在多个TM、RM中传播）；</p><p>3、RM向TC注册分支事务，将其纳入XID对应全局事务的管辖；</p><p>4、TM向TC发起针对XID的全局提交或回滚决议；</p><p>5、TC调度XID下管辖的全部分支事务完成提交或回滚请求。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1609076518331.png" alt="1609076518331"></p><h1 id="Seata的安装"><a href="#Seata的安装" class="headerlink" title="Seata的安装"></a>Seata的安装</h1><h2 id="下载Seata安装包"><a href="#下载Seata安装包" class="headerlink" title="下载Seata安装包"></a>下载Seata安装包</h2><p><a href="https://github.com/seata/seata/releases/tag/v1.4.0">https://github.com/seata/seata/releases/tag/v1.4.0</a></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1609076589809.png" alt="1609076589809"></p><p>将下载的文件上传到linux虚拟机中</p><h2 id="解压压缩包"><a href="#解压压缩包" class="headerlink" title="解压压缩包"></a>解压压缩包</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxf seata-server-1.4.0.tar.gz </span><br></pre></td></tr></table></figure><h2 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h2><h3 id="修改file-conf"><a href="#修改file-conf" class="headerlink" title="修改file.conf"></a>修改file.conf</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim conf/file.conf</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/1609076769140.png" alt="1609076769140">d </p><h3 id="修改registry-conf"><a href="#修改registry-conf" class="headerlink" title="修改registry.conf"></a>修改registry.conf</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim conf/registry.conf</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/1609076869739.png" alt="1609076869739"></p><h3 id="配置数据库"><a href="#配置数据库" class="headerlink" title="配置数据库"></a>配置数据库</h3><p>由于1.4.0版本没有配置对应的sql文件，所以在下边附上，创建一个名为seata的数据库，然后复制下面的内容执行即可。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`global_table`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`global_table`</span> (</span><br><span class="line">  <span class="string">`xid`</span> <span class="built_in">VARCHAR</span>(<span class="number">128</span>)  <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`transaction_id`</span> <span class="built_in">BIGINT</span>,</span><br><span class="line">  <span class="string">`status`</span> <span class="built_in">TINYINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`application_id`</span> <span class="built_in">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">  <span class="string">`transaction_service_group`</span> <span class="built_in">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">  <span class="string">`transaction_name`</span> <span class="built_in">VARCHAR</span>(<span class="number">128</span>),</span><br><span class="line">  <span class="string">`timeout`</span> <span class="built_in">INT</span>,</span><br><span class="line">  <span class="string">`begin_time`</span> <span class="built_in">BIGINT</span>,</span><br><span class="line">  <span class="string">`application_data`</span> <span class="built_in">VARCHAR</span>(<span class="number">2000</span>),</span><br><span class="line">  <span class="string">`gmt_create`</span> DATETIME,</span><br><span class="line">  <span class="string">`gmt_modified`</span> DATETIME,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`xid`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_gmt_modified_status`</span> (<span class="string">`gmt_modified`</span>, <span class="string">`status`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_transaction_id`</span> (<span class="string">`transaction_id`</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- the table to store BranchSession data</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`branch_table`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`branch_table`</span> (</span><br><span class="line">  <span class="string">`branch_id`</span> <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`xid`</span> <span class="built_in">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`transaction_id`</span> <span class="built_in">BIGINT</span> ,</span><br><span class="line">  <span class="string">`resource_group_id`</span> <span class="built_in">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">  <span class="string">`resource_id`</span> <span class="built_in">VARCHAR</span>(<span class="number">256</span>) ,</span><br><span class="line">  <span class="string">`lock_key`</span> <span class="built_in">VARCHAR</span>(<span class="number">128</span>) ,</span><br><span class="line">  <span class="string">`branch_type`</span> <span class="built_in">VARCHAR</span>(<span class="number">8</span>) ,</span><br><span class="line">  <span class="string">`status`</span> <span class="built_in">TINYINT</span>,</span><br><span class="line">  <span class="string">`client_id`</span> <span class="built_in">VARCHAR</span>(<span class="number">64</span>),</span><br><span class="line">  <span class="string">`application_data`</span> <span class="built_in">VARCHAR</span>(<span class="number">2000</span>),</span><br><span class="line">  <span class="string">`gmt_create`</span> DATETIME,</span><br><span class="line">  <span class="string">`gmt_modified`</span> DATETIME,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`branch_id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_xid`</span> (<span class="string">`xid`</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- the table to store lock data</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`lock_table`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`lock_table`</span> (</span><br><span class="line">  <span class="string">`row_key`</span> <span class="built_in">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`xid`</span> <span class="built_in">VARCHAR</span>(<span class="number">96</span>),</span><br><span class="line">  <span class="string">`transaction_id`</span> <span class="keyword">LONG</span> ,</span><br><span class="line">  <span class="string">`branch_id`</span> <span class="keyword">LONG</span>,</span><br><span class="line">  <span class="string">`resource_id`</span> <span class="built_in">VARCHAR</span>(<span class="number">256</span>) ,</span><br><span class="line">  <span class="string">`table_name`</span> <span class="built_in">VARCHAR</span>(<span class="number">32</span>) ,</span><br><span class="line">  <span class="string">`pk`</span> <span class="built_in">VARCHAR</span>(<span class="number">36</span>) ,</span><br><span class="line">  <span class="string">`gmt_create`</span> DATETIME ,</span><br><span class="line">  <span class="string">`gmt_modified`</span> DATETIME,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span>(<span class="string">`row_key`</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./root/seata/bin/seata-server.sh</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/1609077056733.png" alt="1609077056733"></p><h1 id="Seata的使用"><a href="#Seata的使用" class="headerlink" title="Seata的使用"></a>Seata的使用</h1><h2 id="数据库的准备"><a href="#数据库的准备" class="headerlink" title="数据库的准备"></a>数据库的准备</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> seata_order;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_order(</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">BIGINT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line"><span class="string">`user_id`</span> <span class="built_in">BIGINT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;用户id&#x27;</span>,</span><br><span class="line"><span class="string">`product_id`</span> <span class="built_in">BIGINT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;产品id&#x27;</span>,</span><br><span class="line"><span class="string">`count`</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;数量&#x27;</span>,</span><br><span class="line"><span class="string">`money`</span> <span class="built_in">DECIMAL</span>(<span class="number">11</span>,<span class="number">0</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;金额&#x27;</span>,</span><br><span class="line"><span class="string">`status`</span> <span class="built_in">INT</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;订单状态：0：创建中; 1：已完结&#x27;</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span> AUTO_INCREMENT=<span class="number">7</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"><span class="comment">-------------------------------------------------------------------------------------- </span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> seata_storage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_storage(</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">BIGINT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line"><span class="string">`product_id`</span> <span class="built_in">BIGINT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;产品id&#x27;</span>,</span><br><span class="line"><span class="string">`total`</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;总库存&#x27;</span>,</span><br><span class="line"><span class="string">`used`</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;已用库存&#x27;</span>,</span><br><span class="line"><span class="string">`residue`</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;剩余库存&#x27;</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span> AUTO_INCREMENT=<span class="number">2</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_storage(<span class="string">`id`</span>,<span class="string">`product_id`</span>,<span class="string">`total`</span>,<span class="string">`used`</span>,<span class="string">`residue`</span>)<span class="keyword">VALUES</span>(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;100&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;100&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-------------------------------------------------------------------------------------- </span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> seata_account;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_account(</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">BIGINT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT PRIMARY <span class="keyword">KEY</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line"><span class="string">`user_id`</span> <span class="built_in">BIGINT</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;用户id&#x27;</span>,</span><br><span class="line"><span class="string">`total`</span> <span class="built_in">DECIMAL</span>(<span class="number">10</span>,<span class="number">0</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;总额度&#x27;</span>,</span><br><span class="line"><span class="string">`used`</span> <span class="built_in">DECIMAL</span>(<span class="number">10</span>,<span class="number">0</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;已用余额&#x27;</span>,</span><br><span class="line"><span class="string">`residue`</span> <span class="built_in">DECIMAL</span>(<span class="number">10</span>,<span class="number">0</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;剩余可用额度&#x27;</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span> AUTO_INCREMENT=<span class="number">2</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_account(<span class="string">`id`</span>,<span class="string">`user_id`</span>,<span class="string">`total`</span>,<span class="string">`used`</span>,<span class="string">`residue`</span>) <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1000</span>,<span class="number">0</span>,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure><h2 id="在每个数据库添加日志信息回滚表"><a href="#在每个数据库添加日志信息回滚表" class="headerlink" title="在每个数据库添加日志信息回滚表"></a>在每个数据库添加日志信息回滚表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`undo_log`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"><span class="string">`branch_id`</span> <span class="built_in">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`xid`</span> <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`context`</span> <span class="built_in">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`rollback_info`</span> LONGBLOB <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`log_status`</span> <span class="built_in">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`log_created`</span> DATETIME <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`log_modified`</span> DATETIME <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`ext`</span> <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line"><span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`ux_undo_log`</span> (<span class="string">`xid`</span>,<span class="string">`branch_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span> AUTO_INCREMENT=<span class="number">1</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure><p>最终效果展示：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1610271710787.png" alt="1610271710787"></p><h2 id="在nacos中添加各个微服务的配置"><a href="#在nacos中添加各个微服务的配置" class="headerlink" title="在nacos中添加各个微服务的配置"></a>在nacos中添加各个微服务的配置</h2><p>该步骤在以前的版本是将上面3.1和3.2的文件拷贝到每个微服务的resources目录下，到了现在的版本就可以配置到nacos上</p><h3 id="添加脚本nacos-config-sh到seata的conf"><a href="#添加脚本nacos-config-sh到seata的conf" class="headerlink" title="添加脚本nacos-config.sh到seata的conf"></a>添加脚本nacos-config.sh到seata的conf</h3><p><a href = 'https://github.com/seata/seata/blob/develop/script/config-center/nacos/nacos-config.sh'>获取地址点击此链接</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">opyright 1999-2019 Seata.io Group.</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> you may not use this file except <span class="keyword">in</span> compliance with the License.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> You may obtain a copy of the License at、</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment">#      http://www.apache.org/licenses/LICENSE-2.0</span></span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Unless required by applicable law or agreed to in writing, software</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> distributed under the License is distributed on an <span class="string">&quot;AS IS&quot;</span> BASIS,</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> See the License <span class="keyword">for</span> the specific language governing permissions and</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> limitations under the License.</span></span><br><span class="line"></span><br><span class="line">while getopts &quot;:h:p:g:t:u:w:&quot; opt</span><br><span class="line">do</span><br><span class="line">  case $opt in</span><br><span class="line">  h)</span><br><span class="line">    host=$OPTARG</span><br><span class="line">    ;;</span><br><span class="line">  p)</span><br><span class="line">    port=$OPTARG</span><br><span class="line">    ;;</span><br><span class="line">  g)</span><br><span class="line">    group=$OPTARG</span><br><span class="line">    ;;</span><br><span class="line">  t)</span><br><span class="line">    tenant=$OPTARG</span><br><span class="line">    ;;</span><br><span class="line">  u)</span><br><span class="line">    username=$OPTARG</span><br><span class="line">    ;;</span><br><span class="line">  w)</span><br><span class="line">    password=$OPTARG</span><br><span class="line">    ;;</span><br><span class="line">  ?)</span><br><span class="line">    echo &quot; USAGE OPTION: $0 [-h host] [-p port] [-g group] [-t tenant] [-u username] [-w password] &quot;</span><br><span class="line">    exit 1</span><br><span class="line">    ;;</span><br><span class="line">  esac</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">urlencode() &#123;</span><br><span class="line">  for ((i=0; i &lt; $&#123;#1&#125;; i++))</span><br><span class="line">  do</span><br><span class="line">    char=&quot;$&#123;1:$i:1&#125;&quot;</span><br><span class="line">    case $char in</span><br><span class="line">    [a-zA-Z0-9.~_-]) printf $char ;;</span><br><span class="line">    *) printf &#x27;%%%02X&#x27; &quot;&#x27;$char&quot; ;;</span><br><span class="line">    esac</span><br><span class="line">  done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if [[ -z $&#123;host&#125; ]]; then</span><br><span class="line">    host=localhost</span><br><span class="line">fi</span><br><span class="line">if [[ -z $&#123;port&#125; ]]; then</span><br><span class="line">    port=8848</span><br><span class="line">fi</span><br><span class="line">if [[ -z $&#123;group&#125; ]]; then</span><br><span class="line">    group=&quot;SEATA_GROUP&quot;</span><br><span class="line">fi</span><br><span class="line">if [[ -z $&#123;tenant&#125; ]]; then</span><br><span class="line">    tenant=&quot;&quot;</span><br><span class="line">fi</span><br><span class="line">if [[ -z $&#123;username&#125; ]]; then</span><br><span class="line">    username=&quot;&quot;</span><br><span class="line">fi</span><br><span class="line">if [[ -z $&#123;password&#125; ]]; then</span><br><span class="line">    password=&quot;&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">nacosAddr=$host:$port</span><br><span class="line">contentType=&quot;content-type:application/json;charset=UTF-8&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;set nacosAddr=$nacosAddr&quot;</span><br><span class="line">echo &quot;set group=$group&quot;</span><br><span class="line"></span><br><span class="line">failCount=0</span><br><span class="line">tempLog=$(mktemp -u)</span><br><span class="line">function addConfig() &#123;</span><br><span class="line">  curl -X POST -H &quot;$&#123;contentType&#125;&quot; &quot;http://$nacosAddr/nacos/v1/cs/configs?dataId=$(urlencode $1)&amp;group=$group&amp;content=$(urlencode $2)&amp;tenant=$tenant&amp;username=$username&amp;password=$password&quot; &gt;&quot;$&#123;tempLog&#125;&quot; 2&gt;/dev/null</span><br><span class="line">  if [[ -z $(cat &quot;$&#123;tempLog&#125;&quot;) ]]; then</span><br><span class="line">    echo &quot; Please check the cluster status. &quot;</span><br><span class="line">    exit 1</span><br><span class="line">  fi</span><br><span class="line">  if [[ $(cat &quot;$&#123;tempLog&#125;&quot;) =~ &quot;true&quot; ]]; then</span><br><span class="line">    echo &quot;Set $1=$2 successfully &quot;</span><br><span class="line">  else</span><br><span class="line">    echo &quot;Set $1=$2 failure &quot;</span><br><span class="line">    (( failCount++ ))</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">count=0</span><br><span class="line">for line in $(cat $(dirname &quot;$PWD&quot;)/conf/config.txt | sed s/[[:space:]]//g); do</span><br><span class="line">  (( count++ ))</span><br><span class="line">key=$&#123;line%%=*&#125;</span><br><span class="line">    value=$&#123;line#*=&#125;</span><br><span class="line">addConfig &quot;$&#123;key&#125;&quot; &quot;$&#123;value&#125;&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo &quot;=========================================================================&quot;</span><br><span class="line">echo &quot; Complete initialization parameters,  total-count:$count ,  failure-count:$failCount &quot;</span><br><span class="line">echo &quot;=========================================================================&quot;</span><br><span class="line"></span><br><span class="line">if [[ $&#123;failCount&#125; -eq 0 ]]; then</span><br><span class="line">echo &quot; Init nacos config finished, please start seata-server. &quot;</span><br><span class="line">else</span><br><span class="line">echo &quot; init nacos config fail. &quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h3 id="添加配置文件config-txt到seata的conf目录"><a href="#添加配置文件config-txt到seata的conf目录" class="headerlink" title="添加配置文件config.txt到seata的conf目录"></a>添加配置文件config.txt到seata的conf目录</h3><p><a href = 'https://github.com/seata/seata/blob/develop/script/config-center/config.txt'>获取地址点击此链接</a></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">transport.type=TCP</span><br><span class="line">transport.server=NIO</span><br><span class="line">transport.heartbeat=true</span><br><span class="line">transport.enableClientBatchSendRequest=false</span><br><span class="line">transport.threadFactory.bossThreadPrefix=NettyBoss</span><br><span class="line">transport.threadFactory.workerThreadPrefix=NettyServerNIOWorker</span><br><span class="line">transport.threadFactory.serverExecutorThreadPrefix=NettyServerBizHandler</span><br><span class="line">transport.threadFactory.shareBossWorker=false</span><br><span class="line">transport.threadFactory.clientSelectorThreadPrefix=NettyClientSelector</span><br><span class="line">transport.threadFactory.clientSelectorThreadSize=1</span><br><span class="line">transport.threadFactory.clientWorkerThreadPrefix=NettyClientWorkerThread</span><br><span class="line">transport.threadFactory.bossThreadSize=1</span><br><span class="line">transport.threadFactory.workerThreadSize=default</span><br><span class="line">transport.shutdown.wait=3</span><br><span class="line">service.vgroupMapping.my_test_tx_group=default</span><br><span class="line">service.default.grouplist=127.0.0.1:8091</span><br><span class="line">service.enableDegrade=false</span><br><span class="line">service.disableGlobalTransaction=false</span><br><span class="line">client.rm.asyncCommitBufferLimit=10000</span><br><span class="line">client.rm.lock.retryInterval=10</span><br><span class="line">client.rm.lock.retryTimes=30</span><br><span class="line">client.rm.lock.retryPolicyBranchRollbackOnConflict=true</span><br><span class="line">client.rm.reportRetryCount=5</span><br><span class="line">client.rm.tableMetaCheckEnable=false</span><br><span class="line">client.rm.tableMetaCheckerInterval=60000</span><br><span class="line">client.rm.sqlParserType=druid</span><br><span class="line">client.rm.reportSuccessEnable=false</span><br><span class="line">client.rm.sagaBranchRegisterEnable=false</span><br><span class="line">client.tm.commitRetryCount=5</span><br><span class="line">client.tm.rollbackRetryCount=5</span><br><span class="line">client.tm.defaultGlobalTransactionTimeout=60000</span><br><span class="line">client.tm.degradeCheck=false</span><br><span class="line">client.tm.degradeCheckAllowTimes=10</span><br><span class="line">client.tm.degradeCheckPeriod=2000</span><br><span class="line">store.mode=file</span><br><span class="line">store.publicKey=1</span><br><span class="line">store.file.dir=file_store/data</span><br><span class="line">store.file.maxBranchSessionSize=16384</span><br><span class="line">store.file.maxGlobalSessionSize=512</span><br><span class="line">store.file.fileWriteBufferCacheSize=16384</span><br><span class="line">store.file.flushDiskMode=async</span><br><span class="line">store.file.sessionReloadReadSize=100</span><br><span class="line">store.db.datasource=druid</span><br><span class="line">store.db.dbType=mysql</span><br><span class="line">store.db.driverClassName=com.mysql.jdbc.Driver</span><br><span class="line">store.db.url=jdbc:mysql://127.0.0.1:3306/seata_order?useUnicode=true&amp;rewriteBatchedStatements=true</span><br><span class="line">store.db.user=root</span><br><span class="line">store.db.password=123456</span><br><span class="line">store.db.minConn=5</span><br><span class="line">store.db.maxConn=30</span><br><span class="line">store.db.globalTable=global_table</span><br><span class="line">store.db.branchTable=branch_table</span><br><span class="line">store.db.queryLimit=100</span><br><span class="line">store.db.lockTable=lock_table</span><br><span class="line">store.db.maxWait=5000</span><br><span class="line">store.redis.mode=single</span><br><span class="line">store.redis.single.host=127.0.0.1</span><br><span class="line">store.redis.single.port=6379</span><br><span class="line">store.redis.maxConn=10</span><br><span class="line">store.redis.minConn=1</span><br><span class="line">store.redis.maxTotal=100</span><br><span class="line">store.redis.database=0</span><br><span class="line">store.redis.password=123456</span><br><span class="line">store.redis.queryLimit=100</span><br><span class="line">server.recovery.committingRetryPeriod=1000</span><br><span class="line">server.recovery.asynCommittingRetryPeriod=1000</span><br><span class="line">server.recovery.rollbackingRetryPeriod=1000</span><br><span class="line">server.recovery.timeoutRetryPeriod=1000</span><br><span class="line">server.maxCommitRetryTimeout=-1</span><br><span class="line">server.maxRollbackRetryTimeout=-1</span><br><span class="line">server.rollbackRetryTimeoutUnlockEnable=false</span><br><span class="line">client.undo.dataValidation=true</span><br><span class="line">client.undo.logSerialization=jackson</span><br><span class="line">client.undo.onlyCareUpdateColumns=true</span><br><span class="line">server.undo.logSaveDays=7</span><br><span class="line">server.undo.logDeletePeriod=86400000</span><br><span class="line">client.undo.logTable=undo_log</span><br><span class="line">client.undo.compress.enable=true</span><br><span class="line">client.undo.compress.type=zip</span><br><span class="line">client.undo.compress.threshold=64k</span><br><span class="line">log.exceptionRate=100</span><br><span class="line">transport.serialization=seata</span><br><span class="line">transport.compressor=none</span><br><span class="line">metrics.enabled=false</span><br><span class="line">metrics.registryType=compact</span><br><span class="line">metrics.exporterList=prometheus</span><br><span class="line">metrics.exporterPrometheusPort=9898</span><br></pre></td></tr></table></figure><p>最重要的配置</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1611586102169.png" alt="1611586102169"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1611586065601.png" alt="1611586065601"></p><h3 id="3-3、执行命令将配置保存到nacos中"><a href="#3-3、执行命令将配置保存到nacos中" class="headerlink" title="3.3、执行命令将配置保存到nacos中"></a>3.3、执行命令将配置保存到nacos中</h3><p>由于配置相当多，所以最好是建立一个单独的空间来保存</p><p>该命令中 -t表示需要保存的空间，如果没有限制用户名和密码，则-u和-w这两个可以去掉</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh nacos-config.sh -h 127.0.0.1 -p 8848 -g SEATA_GROUP -t a82700f8-03c7-4b00-8ff7-95b51fee96cf -u nacos -w nacos</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1611586837335.png" alt="1611586837335"></p><p>后续如果有需要修改的地方，可以在nacos直接修改，不需要重新执行脚本</p><h2 id="创建seata-order、seata-account、seata-storage三个微服务"><a href="#创建seata-order、seata-account、seata-storage三个微服务" class="headerlink" title="创建seata-order、seata-account、seata-storage三个微服务"></a>创建seata-order、seata-account、seata-storage三个微服务</h2><p>这里只说重要配置，详细可参考源码</p><h3 id="pom文件引入seata"><a href="#pom文件引入seata" class="headerlink" title="pom文件引入seata"></a>pom文件引入seata</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-seata<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">seata:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">enable-auto-data-source-proxy:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">tx-service-group:</span> <span class="string">my_test_tx_group</span></span><br><span class="line">  <span class="attr">registry:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">nacos</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">application:</span> <span class="string">seata-server</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">$&#123;linux.ip&#125;:80</span></span><br><span class="line">      <span class="attr">group:</span> <span class="string">SEATA_GROUP</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">nacos</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">namespace:</span> <span class="string">&quot;a82700f8-03c7-4b00-8ff7-95b51fee96cf&quot;</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">$&#123;linux.ip&#125;:80</span></span><br><span class="line">      <span class="attr">group:</span> <span class="string">SEATA_GROUP</span></span><br><span class="line">  <span class="attr">service:</span></span><br><span class="line">    <span class="attr">vgroup-mapping:</span></span><br><span class="line">      <span class="attr">my_test_tx_group:</span> <span class="string">default</span></span><br><span class="line">    <span class="attr">grouplist:</span></span><br><span class="line">      <span class="attr">default:</span> <span class="string">$&#123;linux.ip&#125;:8091</span></span><br><span class="line">    <span class="attr">disable-global-transaction:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">rm:</span></span><br><span class="line">      <span class="attr">report-success-enable:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/1611587920538.png" alt="1611587920538"></p><h3 id="在需要进行分布式操作的接口上添加-GlobalTransactional注解"><a href="#在需要进行分布式操作的接口上添加-GlobalTransactional注解" class="headerlink" title="在需要进行分布式操作的接口上添加@GlobalTransactional注解"></a>在需要进行分布式操作的接口上添加@GlobalTransactional注解</h3><p><img src="http://cheng_qiwei.gitee.io/blog/img/1611672434484.png" alt="1611672434484"></p><p><font color='red'><strong>注意各个服务的服务都必须配置和seata-server在相同的空间中，否则后续会出现各种奇怪的问题</strong></font></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1611588088719.png" alt="1611588088719"></p><p><font color='red'><strong>服务启动后，seata的服务端会有RM和TM连接的展示</strong></font></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1611670632746.png" alt="1611670632746"></p><p><font color='red'><strong>各个子服务也有相应连接</strong></font></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1611670859404.png" alt="1611670859404"></p><p>测试</p><p>1、测试创建订单   <a href="http://127.0.0.1:8801/order/create">http://127.0.0.1:8801/order/create</a></p><p>首先测试正常情况下，订单生成成功，库存扣减、账户扣减成功</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1611671241904.png" alt="1611671241904"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1611671236685.png" alt="1611671236685"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1611671770888.png" alt="1611671770888"></p><p>接着，测试不正常的情况，我们把数量设置为100，因为我们当前的库存已经不足100，所以此时扣减100库存的话，就会发生意外，但是，由于订单已经生成，如果seata的分布式事务有效的话，我们的订单就应该能够回滚成功。我们发现异常后，查看数据库，订单为保存，库存和余额也没有扣减，分布式事务生效。</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1611671328435.png" alt="1611671328435"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1611671426528.png" alt="1611671426528"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1611671904291.png" alt="1611671904291"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1611671990045.png" alt="1611671990045"></p>]]></content>
      
      
      <categories>
          
          <category> SpringCloudAlibaba </category>
          
          <category> Seata </category>
          
          <category> 分布式事务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式事务 </tag>
            
            <tag> Seata </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK8新特性——时间类</title>
      <link href="/blog/2021/03/05/JDK8%E6%96%B0%E7%89%B9%E6%80%A7%E2%80%94%E2%80%94%E6%97%B6%E9%97%B4%E7%B1%BB/"/>
      <url>/blog/2021/03/05/JDK8%E6%96%B0%E7%89%B9%E6%80%A7%E2%80%94%E2%80%94%E6%97%B6%E9%97%B4%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="JDK8新特性——时间类"><a href="#JDK8新特性——时间类" class="headerlink" title="JDK8新特性——时间类"></a>JDK8新特性——时间类</h1><h1 id="为什么需要使用新的时间类"><a href="#为什么需要使用新的时间类" class="headerlink" title="为什么需要使用新的时间类"></a>为什么需要使用新的时间类</h1><p>1、Date如果不格式化，打印出的日期可读性差【Tue Sep 10 09:34:04 CST 2019】；</p><p>2、使用 SimpleDateFormat 对时间进行格式化，但 SimpleDateFormat 是线程不安全的；</p><p>3、获取时间一些参数需要转换为calendar类获取……</p><h1 id="JDK8新特性提供的时间操作类"><a href="#JDK8新特性提供的时间操作类" class="headerlink" title="JDK8新特性提供的时间操作类"></a>JDK8新特性提供的时间操作类</h1><p>1、LocalDate    【日期】</p><p>2、LocalTime    【时间】</p><p>3、LocalDateTime    【日期时间】</p><h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><h2 id="获取当前日期"><a href="#获取当前日期" class="headerlink" title="获取当前日期"></a>获取当前日期</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalDate localDate = LocalDate.now();</span><br></pre></td></tr></table></figure><h2 id="构造指定的年月日"><a href="#构造指定的年月日" class="headerlink" title="构造指定的年月日"></a>构造指定的年月日</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalDate localDate1 = LocalDate.of(<span class="number">2019</span>, <span class="number">9</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><h2 id="获取当前时间"><a href="#获取当前时间" class="headerlink" title="获取当前时间"></a>获取当前时间</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalTime localTime = LocalTime.now();</span><br></pre></td></tr></table></figure><h2 id="构造指定的时分秒"><a href="#构造指定的时分秒" class="headerlink" title="构造指定的时分秒"></a>构造指定的时分秒</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalTime localTime1 = LocalTime.of(<span class="number">12</span>, <span class="number">9</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><h2 id="获取当前时日"><a href="#获取当前时日" class="headerlink" title="获取当前时日"></a>获取当前时日</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime localDateTime = LocalDateTime.now();</span><br></pre></td></tr></table></figure><h2 id="构造指定的时日"><a href="#构造指定的时日" class="headerlink" title="构造指定的时日"></a>构造指定的时日</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime localDateTime1 = LocalDateTime.of(<span class="number">2019</span>, Month.SEPTEMBER, <span class="number">10</span>, <span class="number">14</span>, <span class="number">46</span>, <span class="number">56</span>);</span><br></pre></td></tr></table></figure><h2 id="获取时间的某一个值"><a href="#获取时间的某一个值" class="headerlink" title="获取时间的某一个值"></a>获取时间的某一个值</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> year = localDateTime1.getYear();   <span class="comment">//2020  年份</span></span><br><span class="line">Month month = localDateTime1.getMonth();   <span class="comment">//JUNE  月份</span></span><br><span class="line"><span class="keyword">int</span> monthValue = localDateTime1.getMonthValue();   <span class="comment">//6  月份数值</span></span><br><span class="line"><span class="keyword">int</span> day = localDateTime1.getDayOfMonth();   <span class="comment">//28  日期</span></span><br><span class="line">DayOfWeek dayOfWeek = localDateTime1.getDayOfWeek();   <span class="comment">//SUNDAY  周</span></span><br><span class="line"><span class="keyword">int</span> dayOfYear = localDateTime1.getDayOfYear();   <span class="comment">//180  年的第几天</span></span><br><span class="line"><span class="keyword">int</span> hour = localDateTime1.getHour();   <span class="comment">//13 小时</span></span><br><span class="line"><span class="keyword">int</span> minute = localDateTime1.getMinute();   <span class="comment">//51  分钟</span></span><br><span class="line"><span class="keyword">int</span> second = localDateTime1.getSecond();   <span class="comment">//19  秒</span></span><br></pre></td></tr></table></figure><h2 id="LocalDateTime、LocalDate、LocalTime的转换"><a href="#LocalDateTime、LocalDate、LocalTime的转换" class="headerlink" title="LocalDateTime、LocalDate、LocalTime的转换"></a>LocalDateTime、LocalDate、LocalTime的转换</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime localDateTime = LocalDateTime.of(localDate, localTime);</span><br><span class="line">LocalDateTime localDateTime = localDate.atTime(localTime);</span><br><span class="line">LocalDateTime localDateTime = localTime.atDate(localDate);</span><br><span class="line">LocalDate localDate = localDateTime.toLocalDate();</span><br><span class="line">LocalTime localTime = localDateTime.toLocalTime();</span><br></pre></td></tr></table></figure><h2 id="将某个时间增加"><a href="#将某个时间增加" class="headerlink" title="将某个时间增加"></a>将某个时间增加</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">localDateTime = localDateTime.plus(<span class="number">2</span>,ChronoUnit.YEARS);  <span class="comment">//增加2年</span></span><br><span class="line">localDateTime = localDateTime.plusYears(<span class="number">2</span>);  <span class="comment">//增加2年</span></span><br></pre></td></tr></table></figure><h2 id="将某个时间减少"><a href="#将某个时间减少" class="headerlink" title="将某个时间减少"></a>将某个时间减少</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">localDateTime = localDateTime.minus(<span class="number">2</span>,ChronoUnit.YEARS);  <span class="comment">//减少2年</span></span><br><span class="line">localDateTime = localDateTime.minusYears(<span class="number">2</span>);  <span class="comment">//减少2年</span></span><br></pre></td></tr></table></figure><h2 id="将某个时间参数指定"><a href="#将某个时间参数指定" class="headerlink" title="将某个时间参数指定"></a>将某个时间参数指定</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">localDateTime1 = localDateTime1.with(ChronoField.MONTH_OF_YEAR,<span class="number">1</span>);  <span class="comment">//指定月份为1月</span></span><br><span class="line">localDateTime1 = localDateTime1.withHour(<span class="number">2</span>);  <span class="comment">//指定小时为2时</span></span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">localDateTime.with(firstDayOfYear());  <span class="comment">//获取当年的第一天</span></span><br><span class="line">localDateTime.with(firstDayOfMonth());  <span class="comment">//获取当月的第一天</span></span><br><span class="line">localDateTime.with(firstDayOfNextYear());  <span class="comment">//获取下年的第一天</span></span><br><span class="line">localDateTime.with(firstDayOfNextMonth());  <span class="comment">//获取下月的第一天</span></span><br><span class="line">localDateTime.with(firstInMonth(DayOfWeek.MONDAY));  <span class="comment">//获取当月第一个星期一的时间</span></span><br><span class="line">localDateTime.with(lastDayOfYear());  <span class="comment">//获取上年的第一天</span></span><br><span class="line">localDateTime.with(lastDayOfMonth());  <span class="comment">//获取上月的第一天</span></span><br><span class="line">localDateTime.with(lastInMonth(DayOfWeek.MONDAY));  <span class="comment">//获取当月最后一个星期一的时间</span></span><br></pre></td></tr></table></figure><h2 id="格式化时间"><a href="#格式化时间" class="headerlink" title="格式化时间"></a>格式化时间</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认提供了几种格式时间的方式【一般不用】</span></span><br><span class="line">String s1 = localDateTime.format(DateTimeFormatter.BASIC_ISO_DATE);</span><br><span class="line">String s2 = localDateTime.format(DateTimeFormatter.ISO_DATE_TIME);</span><br><span class="line"><span class="comment">//自定义格式化时间的方式</span></span><br><span class="line">DateTimeFormatter dateTimeFormatter =   DateTimeFormatter.ofPattern(<span class="string">&quot;dd/MM/yyyy/hh/mm/ss&quot;</span>);</span><br><span class="line">String s3 = localDateTime.format(dateTimeFormatter);</span><br></pre></td></tr></table></figure><h2 id="字符串解析时间"><a href="#字符串解析时间" class="headerlink" title="字符串解析时间"></a>字符串解析时间</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LocalDate localDate1 &#x3D; LocalDate.parse(&quot;20190910&quot;, DateTimeFormatter.BASIC_ISO_DATE);</span><br><span class="line">LocalDate localDate2 &#x3D; LocalDate.parse(&quot;2019-09-10&quot;, DateTimeFormatter.ISO_LOCAL_DATE);</span><br><span class="line">DateTimeFormatter dateTimeFormatter &#x3D;   DateTimeFormatter.ofPattern(&quot;dd&#x2F;MM&#x2F;yyyy&#x2F;hh&#x2F;mm&#x2F;ss&quot;);</span><br><span class="line">LocalDate localDate3 &#x3D; LocalDate.parse(&quot;28&#x2F;06&#x2F;2020&#x2F;02&#x2F;28&#x2F;46&quot;, dateTimeFormatter);</span><br></pre></td></tr></table></figure><h2 id="Timestamp与LocalDateTime的转换"><a href="#Timestamp与LocalDateTime的转换" class="headerlink" title="Timestamp与LocalDateTime的转换"></a>Timestamp与LocalDateTime的转换</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime localDateTime1 = <span class="keyword">new</span> Timestamp(System.currentTimeMillis()).toLocalDateTime();</span><br></pre></td></tr></table></figure><h2 id="LocalDateTime与Long（时间戳）的转换"><a href="#LocalDateTime与Long（时间戳）的转换" class="headerlink" title="LocalDateTime与Long（时间戳）的转换"></a>LocalDateTime与Long（时间戳）的转换</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime localDateTime = (<span class="keyword">new</span> Timestamp(System.currentTimeMillis())).toLocalDateTime();</span><br><span class="line"><span class="keyword">long</span> time = localDateTime.atZone(ZoneId.systemDefault()).toInstant().toEpochMilli();</span><br></pre></td></tr></table></figure><h2 id="时间的比较"><a href="#时间的比较" class="headerlink" title="时间的比较"></a>时间的比较</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime localDateTime = LocalDateTime.of(<span class="number">1994</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">LocalDateTime localDateTime4 = LocalDateTime.now();</span><br><span class="line">System.out.println(localDateTime.isBefore(localDateTime4));</span><br><span class="line">System.out.println(localDateTime.isAfter(localDateTime4));</span><br></pre></td></tr></table></figure><h2 id="计算时间间隔（Duration类和Period类）"><a href="#计算时间间隔（Duration类和Period类）" class="headerlink" title="计算时间间隔（Duration类和Period类）"></a>计算时间间隔（Duration类和Period类）</h2><p>使用场景【计算年龄、合同时间等。。。】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime localDateTime = LocalDateTime.of(<span class="number">1994</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">LocalDateTime localDateTime4 = LocalDateTime.now();</span><br><span class="line">Duration duration = Duration.between(localDateTime,localDateTime4);</span><br><span class="line"><span class="comment">//间隔多少天</span></span><br><span class="line"><span class="keyword">long</span> days = duration.toDays();</span><br><span class="line"><span class="comment">//间隔多少小时</span></span><br><span class="line"><span class="keyword">long</span> hours = duration.toHours();</span><br><span class="line"><span class="comment">//间隔多少分钟</span></span><br><span class="line"><span class="keyword">long</span> minutes = duration.toMinutes();</span><br><span class="line">Period period2 = Period.between(localDateTime.toLocalDate(),localDateTime4.toLocalDate());</span><br><span class="line"><span class="comment">//间隔多少年</span></span><br><span class="line"><span class="keyword">int</span> years = period2.getYears();</span><br><span class="line"><span class="comment">//间隔多少月（只计算月份，不计年）</span></span><br><span class="line"><span class="keyword">int</span> months = period2.getMonths();</span><br><span class="line"><span class="comment">//间隔多少月（计算年）</span></span><br><span class="line"><span class="keyword">long</span> toTotalMonths = period2.toTotalMonths();</span><br></pre></td></tr></table></figure><h1 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Timestamp;</span><br><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"><span class="keyword">import</span> java.time.temporal.ChronoUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateTimeUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter TIME_FORMATTER = DateTimeFormatter.ofPattern(<span class="string">&quot;HHmmss&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter YEAR_MONTH_FORMATTER = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter SHORT_DATE_FORMATTER = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyyMMdd&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter SHORT_DATETIME_FORMATTER = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyyMMddHHmmss&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter DATETIME_FORMATTER = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter LONG_DATETIME_FORMATTER = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss SSS&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter ABC_DATE_FORMATTER = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy/MM/dd&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter ABC_TIME_FORMATTER = DateTimeFormatter.ofPattern(<span class="string">&quot;HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter ABC_DATETIME_FORMATTER = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy/MM/dd HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DateTimeFormatter ABC_SHORT_DATETIME_FORMATTER = DateTimeFormatter.ofPattern(<span class="string">&quot;yyMMddHHmmss&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  将旧格式字符串日期 转换成新格式字符串日期</span></span><br><span class="line"><span class="comment">     *  格式转换</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">dateStrConvertDateStrFromLocalDateTime</span><span class="params">(String dateStr,DateTimeFormatter oldDateTimeFormatter,DateTimeFormatter newDateTimeFormatter)</span></span>&#123;</span><br><span class="line">       LocalDateTime localDateTime = LocalDateTime.parse(dateStr, oldDateTimeFormatter);</span><br><span class="line">       <span class="keyword">return</span> localDateTime.format(newDateTimeFormatter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  将旧格式字符串日期 转换成新格式字符串日期</span></span><br><span class="line"><span class="comment">     *  格式转换</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">dateStrConvertDateStrFromLocalDate</span><span class="params">(String dateStr,DateTimeFormatter oldDateTimeFormatter,DateTimeFormatter newDateTimeFormatter)</span></span>&#123;</span><br><span class="line">        LocalDate localDate = LocalDate.parse(dateStr, oldDateTimeFormatter);</span><br><span class="line">       <span class="keyword">return</span> localDate.format(newDateTimeFormatter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  将字符串日期转换成date类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">dateStrConvertDate</span><span class="params">(String dateStr,DateTimeFormatter dateTimeFormatter)</span></span>&#123;</span><br><span class="line">        LocalDateTime parse = LocalDateTime.parse(dateStr, dateTimeFormatter);</span><br><span class="line">        <span class="comment">// 获得 Instant</span></span><br><span class="line">        Instant instant = Instant.ofEpochSecond(parse.toEpochSecond(ZoneOffset.ofHours(<span class="number">8</span>)));</span><br><span class="line">        <span class="comment">// 获得 Date</span></span><br><span class="line">        <span class="keyword">return</span> Date.from(instant);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  将date类型转换成字符串日期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">dateConvertDateStr</span><span class="params">(Date date,DateTimeFormatter dateTimeFormatter)</span></span>&#123;</span><br><span class="line">        LocalDateTime localDateTime = date.toInstant().atOffset(ZoneOffset.ofHours(<span class="number">8</span>)).toLocalDateTime();</span><br><span class="line">        <span class="keyword">return</span> localDateTime.format(dateTimeFormatter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将date转换成localdate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDate <span class="title">dateConvertLocalDate</span><span class="params">(Date date)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> date.toInstant().atOffset(ZoneOffset.ofHours(<span class="number">8</span>)).toLocalDate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将date转换成localDateTime</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">dateConvertLocalDateTime</span><span class="params">(Date date)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> date.toInstant().atOffset(ZoneOffset.ofHours(<span class="number">8</span>)).toLocalDateTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将localdate转换成date(时分秒为零)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">localDateConvertDate</span><span class="params">(LocalDate localDate)</span></span>&#123;</span><br><span class="line">        Instant instant = localDate.atStartOfDay(ZoneOffset.ofHours(<span class="number">8</span>)).toInstant();</span><br><span class="line">        <span class="comment">// 获得 Date</span></span><br><span class="line">        <span class="keyword">return</span> Date.from(instant);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将localDateTime转换成date</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">localDateTimeConvertDate</span><span class="params">(LocalDateTime localDateTime)</span></span>&#123;</span><br><span class="line">        Instant instant = Instant.ofEpochSecond(localDateTime.toEpochSecond(ZoneOffset.ofHours(<span class="number">8</span>)));</span><br><span class="line">        <span class="comment">// 获得 Date</span></span><br><span class="line">        <span class="keyword">return</span> Date.from(instant);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前的日期</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDate <span class="title">getCurrentLocalDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDate.now();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalTime <span class="title">getCurrentLocalTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalTime.now();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前日期时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">getCurrentLocalDateTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.now();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前日期字符串以“yyyy-MM-dd”格式返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getCurrentDateStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDate.now().format(DATE_FORMATTER);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前日期字符串以“yyMMdd”格式返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getCurrentShortDateStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDate.now().format(SHORT_DATE_FORMATTER);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前日期字符串以“yyyy-MM”格式返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getCurrentMonthStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDate.now().format(YEAR_MONTH_FORMATTER);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前日期时间字符串以“yyyy-MM-dd HH:mm:ss”格式返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getCurrentDateTimeStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.now().format(DATETIME_FORMATTER);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前日期时间字符串以“yyyy-MM-dd HH:mm:ss SSS”格式返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getCurrentLongDateTimeStr</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.now().format(LONG_DATETIME_FORMATTER);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前日期时间字符串以“yyMMddHHmmss”格式返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getCurrentShortDateTimeStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.now().format(SHORT_DATETIME_FORMATTER);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前时间字符串以“HHmmss”格式返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getCurrentTimeStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalTime.now().format(TIME_FORMATTER);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前时间日期字符串以指定的字符串格式返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getCurrentDateTimeStr</span><span class="params">(String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.now().format(DateTimeFormatter.ofPattern(pattern));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将指定日期格式的字符串转为LocalDate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDate <span class="title">parseLocalDate</span><span class="params">(String dateStr, String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDate.parse(dateStr, DateTimeFormatter.ofPattern(pattern));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将指定日期格式的字符串转为LocalDateTime</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">parseLocalDateTime</span><span class="params">(String dateTimeStr, String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.parse(dateTimeStr, DateTimeFormatter.ofPattern(pattern));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将指定日期格式的字符串转为LocalTime</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalTime <span class="title">parseLocalTime</span><span class="params">(String timeStr, String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalTime.parse(timeStr, DateTimeFormatter.ofPattern(pattern));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将LocalTime转为指定日期格式的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">formatLocalDate</span><span class="params">(LocalDate date, String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> date.format(DateTimeFormatter.ofPattern(pattern));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将LocalDateTime转为指定日期格式的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">formatLocalDateTime</span><span class="params">(LocalDateTime datetime, String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> datetime.format(DateTimeFormatter.ofPattern(pattern));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将LocalTime转为指定日期格式的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">formatLocalTime</span><span class="params">(LocalTime time, String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> time.format(DateTimeFormatter.ofPattern(pattern));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将LocalTime转为指定日期格式的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDate <span class="title">formatLocalDate</span><span class="params">(String dateStr,DateTimeFormatter dateTimeFormatter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDate.parse(dateStr, dateTimeFormatter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将LocalDateTime转为指定日期格式的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">formatLocalDateTime</span><span class="params">(String dateTimeStr,DateTimeFormatter dateTimeFormatter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.parse(dateTimeStr, dateTimeFormatter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将LocalTime转为指定日期格式的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalTime <span class="title">formatLocalTime</span><span class="params">(String longDateTimeStr,DateTimeFormatter dateTimeFormatter)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalTime.parse(longDateTimeStr, dateTimeFormatter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 两个日期相隔秒数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">periodHours</span><span class="params">(LocalDateTime startDateTime,LocalDateTime endDateTime)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Duration.between(startDateTime, endDateTime).get(ChronoUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 两个日期相隔天数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">periodDays</span><span class="params">(LocalDate startDate, LocalDate endDate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> startDate.until(endDate, ChronoUnit.DAYS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 两个日期相隔周数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">periodWeeks</span><span class="params">(LocalDate startDate, LocalDate endDate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> startDate.until(endDate, ChronoUnit.WEEKS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 两个日期相隔月数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">periodMonths</span><span class="params">(LocalDate startDate, LocalDate endDate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> startDate.until(endDate, ChronoUnit.MONTHS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 两个日期相隔年数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">periodYears</span><span class="params">(LocalDate startDate, LocalDate endDate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> startDate.until(endDate, ChronoUnit.YEARS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否当天</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isToday</span><span class="params">(LocalDate date)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getCurrentLocalDate().equals(date);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据LocalDateTime获取时间日期的毫秒数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">localDateTimeToEpochMilli</span><span class="params">(LocalDateTime dateTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dateTime.atZone(ZoneId.systemDefault()).toInstant().toEpochMilli();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据时间毫秒数获取LocalDateTime</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">epochMilliToLocalDateTime</span><span class="params">(Long timeMillis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">new</span> Timestamp(timeMillis)).toLocalDateTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据LocalDateTime获取Timestamp</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Timestamp <span class="title">localDateTimeToTimestamp</span><span class="params">(LocalDateTime dateTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Timestamp(dateTime.atZone(ZoneId.systemDefault()).toInstant().toEpochMilli());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据Timestamp获取LocalDateTime</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">localDateTimeToTimestamp</span><span class="params">(Timestamp timestamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> timestamp.toLocalDateTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否为闰年</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isLeapYear</span><span class="params">(LocalDate localDate)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> localDate.isLeapYear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断时间A是否在时间B之前</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isBefore</span><span class="params">(LocalDateTime localDateTimeA,LocalDateTime localDateTimeB)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> localDateTimeA.isBefore(localDateTimeB);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断时间A是否在时间B之后</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isAfter</span><span class="params">(LocalDateTime localDateTimeA,LocalDateTime localDateTimeB)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> localDateTimeA.isAfter(localDateTimeB);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据合同开始时间和合同年限获取合同结束时间（整数年）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">getContractEndTimeByYear</span><span class="params">(LocalDateTime startTime,<span class="keyword">long</span> years)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> startTime.plusYears(years).minusSeconds(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据合同开始时间和合同年限获取合同结束时间(非整数年)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalDateTime <span class="title">getContractEndTimeByMonth</span><span class="params">(LocalDateTime startTime,<span class="keyword">long</span> monthValues)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> startTime.plusMonths(monthValues).minusSeconds(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="时间相应注解"><a href="#时间相应注解" class="headerlink" title="时间相应注解"></a>时间相应注解</h1><h2 id="将返回时间转为指定字符串格式"><a href="#将返回时间转为指定字符串格式" class="headerlink" title="将返回时间转为指定字符串格式"></a>将返回时间转为指定字符串格式</h2><p>@JsonFormat(pattern = “yyyy-MM-dd HH:mm:ss”, timezone = “GMT+8”)</p><h2 id="时间入参格式化"><a href="#时间入参格式化" class="headerlink" title="时间入参格式化"></a>时间入参格式化</h2><p>@DateTimeFormat(pattern = “yyyy-MM-dd”)</p><p>@DateTimeFormat(pattern = “yyyy-MM-dd HH:mm:ss”)</p>]]></content>
      
      
      <categories>
          
          <category> JDK8新特性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDK8 </tag>
            
            <tag> 时间 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dozer 轻松高效玩转DTO(Data Transfer Object)</title>
      <link href="/blog/2021/03/03/Dozer-%E8%BD%BB%E6%9D%BE%E9%AB%98%E6%95%88%E7%8E%A9%E8%BD%ACDTO/"/>
      <url>/blog/2021/03/03/Dozer-%E8%BD%BB%E6%9D%BE%E9%AB%98%E6%95%88%E7%8E%A9%E8%BD%ACDTO/</url>
      
        <content type="html"><![CDATA[<h1 id="Dozer-轻松高效玩转DTO-Data-Transfer-Object"><a href="#Dozer-轻松高效玩转DTO-Data-Transfer-Object" class="headerlink" title="Dozer 轻松高效玩转DTO(Data Transfer Object)"></a>Dozer 轻松高效玩转DTO(Data Transfer Object)</h1><h1 id="为什么需要使用Dozer？"><a href="#为什么需要使用Dozer？" class="headerlink" title="为什么需要使用Dozer？"></a>为什么需要使用Dozer？</h1><p>&emsp;&emsp;对于分布式系统，需要在不同系统之间传递与转换域对象。因为我们不希望外部公开内部域对象，也不允许外部域对象渗入系统。传统上，数据对象之间的映射通过手工编码(getter/setter)的方式实现，或对象组装器（或转换器）来解决。我们可能会开发某种自定义映射框架来满足我们的映射转换需求，但这一切都显得不够灵巧。</p><h1 id="什么是Dozer？Dozer有什么功能？"><a href="#什么是Dozer？Dozer有什么功能？" class="headerlink" title="什么是Dozer？Dozer有什么功能？"></a>什么是Dozer？Dozer有什么功能？</h1><p>&emsp;&emsp;Dozer 是 Java Bean 到 Java Bean 映射器，它以递归方式将数据从一个对象复制到另一个对象。</p><p>&emsp;&emsp;Dozer 支持简单属性映射，复杂类型映射，双向映射，隐式和显式映射以及递归映射。</p><p>&emsp;&emsp;Dozer不仅支持属性名称之间的映射，还支持在类型之间自动转换。大多数转换方案都是开箱即用的，但 Dozer 还允许您通过 XML / API 的方式指定自定义转换。</p><h1 id="如何使用Dozer？"><a href="#如何使用Dozer？" class="headerlink" title="如何使用Dozer？"></a>如何使用Dozer？</h1><h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><h3 id="普通spring项目"><a href="#普通spring项目" class="headerlink" title="普通spring项目"></a>普通spring项目</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.dozermapper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dozer-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="spring-boot项目"><a href="#spring-boot项目" class="headerlink" title="spring boot项目"></a>spring boot项目</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.dozermapper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dozer-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="默认使用Dozer（同名-field-的双向映射，即隐式映射）"><a href="#默认使用Dozer（同名-field-的双向映射，即隐式映射）" class="headerlink" title="默认使用Dozer（同名 field 的双向映射，即隐式映射）"></a>默认使用Dozer（同名 field 的双向映射，即隐式映射）</h2><p>Dozer starter 默认为我们注入了 Dozer Mapper，可以直接使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 身份ID</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="comment">// 电话</span></span><br><span class="line">    <span class="keyword">private</span> String mobile;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentVo</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 身份ID</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="comment">// 姓名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 年龄</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="comment">// 电话</span></span><br><span class="line">    <span class="keyword">private</span> String mobile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Mapper dozerMapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDefault</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Student student = <span class="keyword">new</span> Student(<span class="number">1L</span>, <span class="string">&quot;测试姓名&quot;</span>, <span class="number">18</span>, <span class="string">&quot;123333333&quot;</span>);</span><br><span class="line">    StudentVo studentVo = dozerMapper.map(student, StudentVo.class);</span><br><span class="line">    log.info(<span class="string">&quot;StudentVo: [&#123;&#125;]&quot;</span>, studentVo.toString());</span><br><span class="line">    studentVo.setAge(<span class="number">16</span>);</span><br><span class="line">    log.info(<span class="string">&quot;StudentDomain: [&#123;&#125;]&quot;</span>, dozerMapper.map(studentVo, Student.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要调用了dozerMapper的map方法</p><p>输出结果：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210305151431268.png" alt="image-20210305151431268"></p><h2 id="不同名-field-的双向映射，需要显式映射"><a href="#不同名-field-的双向映射，需要显式映射" class="headerlink" title="不同名 field 的双向映射，需要显式映射"></a>不同名 field 的双向映射，需要显式映射</h2><p>如果两个待映射的 field 不同名，Dozer 默认不会帮我们完成映射，忽略该值，所以我们需要显示映射该 field</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210305151431269.png" alt="image-20210305151431269"></p><p>增加DozerConfig文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DozerConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mapper <span class="title">dozerMapper</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Mapper mapper = DozerBeanMapperBuilder.create()</span><br><span class="line">                <span class="comment">//指定 dozer mapping 的配置文件(放到 resources 类路径下即可)，可添加多个 xml 文件，用逗号隔开</span></span><br><span class="line">                .withMappingFiles(<span class="string">&quot;dozerBeanMapping.xml&quot;</span>)</span><br><span class="line">                .withMappingBuilder(beanMappingBuilder())</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> mapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanMappingBuilder <span class="title">beanMappingBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BeanMappingBuilder() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 显式配置添加在此</span></span><br><span class="line">                mapping(Student.class, StudentVo.class).fields(<span class="string">&quot;addr&quot;</span>,<span class="string">&quot;address&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210305151431270.png" alt="image-20210305151431270"></p><h2 id="关闭隐式匹配，则同名字段不会映射"><a href="#关闭隐式匹配，则同名字段不会映射" class="headerlink" title="关闭隐式匹配，则同名字段不会映射"></a>关闭隐式匹配，则同名字段不会映射</h2><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210305151431271.png" alt="image-20210305151431271"></p><p>输出结果：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210305151431272.png" alt="image-20210305151431272"></p><h2 id="排除不想映射的字段"><a href="#排除不想映射的字段" class="headerlink" title="排除不想映射的字段"></a>排除不想映射的字段</h2><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210305151431273.png" alt="image-20210305151431273"></p><p>输出结果：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210305151431274.png" alt="image-20210305151431274"></p><h2 id="嵌套对象或者集合对象的递归映射"><a href="#嵌套对象或者集合对象的递归映射" class="headerlink" title="嵌套对象或者集合对象的递归映射"></a>嵌套对象或者集合对象的递归映射</h2><h3 id="新增实体"><a href="#新增实体" class="headerlink" title="新增实体"></a>新增实体</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省</span></span><br><span class="line">    <span class="keyword">private</span> String province;</span><br><span class="line">    <span class="comment">// 市</span></span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="comment">// 区</span></span><br><span class="line">    <span class="keyword">private</span> String district;</span><br><span class="line">    <span class="comment">// 详细</span></span><br><span class="line">    <span class="keyword">private</span> String detail;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddressVo</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省</span></span><br><span class="line">    <span class="keyword">private</span> String province;</span><br><span class="line">    <span class="comment">// 市</span></span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="comment">// 区</span></span><br><span class="line">    <span class="keyword">private</span> String district;</span><br><span class="line">    <span class="comment">// 详细</span></span><br><span class="line">    <span class="keyword">private</span> String detailAddress;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Class</span> </span>&#123;</span><br><span class="line">    <span class="comment">//课程编码</span></span><br><span class="line">    <span class="keyword">private</span> String courseCode;</span><br><span class="line">    <span class="comment">//课程名称</span></span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line">    <span class="comment">//教师名称</span></span><br><span class="line">    <span class="keyword">private</span> String teacherName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassVo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//课程编码</span></span><br><span class="line">    <span class="keyword">private</span> String courseCode;</span><br><span class="line">    <span class="comment">//课程名称</span></span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line">    <span class="comment">//教师名称</span></span><br><span class="line">    <span class="keyword">private</span> String teacherName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Student和StudentVo增加字段"><a href="#Student和StudentVo增加字段" class="headerlink" title="Student和StudentVo增加字段"></a>Student和StudentVo增加字段</h3><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210305151431275.png" alt="image-20210305151431275"></p><h3 id="修改测试方法"><a href="#修改测试方法" class="headerlink" title="修改测试方法"></a>修改测试方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDefault1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Class&gt; classList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Class classes = <span class="keyword">new</span> Class(<span class="string">&quot;1001&quot;</span>,<span class="string">&quot;语文&quot;</span>,<span class="string">&quot;语文老师&quot;</span>);</span><br><span class="line">    Class classes1 = <span class="keyword">new</span> Class(<span class="string">&quot;1002&quot;</span>,<span class="string">&quot;数学&quot;</span>,<span class="string">&quot;数学老师&quot;</span>);</span><br><span class="line">    Class classes2 = <span class="keyword">new</span> Class(<span class="string">&quot;1003&quot;</span>,<span class="string">&quot;英语&quot;</span>,<span class="string">&quot;英语老师&quot;</span>);</span><br><span class="line">    Collections.addAll(classList,classes,classes1,classes2);</span><br><span class="line">    Student student = <span class="keyword">new</span> Student(<span class="number">1L</span>, <span class="string">&quot;测试姓名&quot;</span>, <span class="number">18</span>, <span class="string">&quot;123333333&quot;</span>,<span class="string">&quot;广州&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> Address(<span class="string">&quot;广东省&quot;</span>,<span class="string">&quot;广州市&quot;</span>,<span class="string">&quot;天河区&quot;</span>,<span class="string">&quot;XXX路201号&quot;</span>),classList);</span><br><span class="line">    StudentVo studentVo = dozerMapper.map(student, StudentVo.class);</span><br><span class="line">    log.info(<span class="string">&quot;StudentVo: [&#123;&#125;]&quot;</span>, studentVo.toString());</span><br><span class="line">    studentVo.setAge(<span class="number">16</span>);</span><br><span class="line">    log.info(<span class="string">&quot;Student: [&#123;&#125;]&quot;</span>, dozerMapper.map(studentVo, Student.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210305151431276.png" alt="image-20210305151431276"></p><h2 id="深度匹配"><a href="#深度匹配" class="headerlink" title="深度匹配"></a>深度匹配</h2><p>举例：在3.6中，语文老师同时也是班主任，所以希望语文老师的姓名也保存到Student上</p><h3 id="Student和StudentVo增加字段-1"><a href="#Student和StudentVo增加字段-1" class="headerlink" title="Student和StudentVo增加字段"></a>Student和StudentVo增加字段</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//班主任</span></span><br><span class="line"><span class="keyword">private</span> String leaderTeacher;</span><br></pre></td></tr></table></figure><h3 id="配置类添加配置，映射第一个老师的姓名字段到班主任字段上"><a href="#配置类添加配置，映射第一个老师的姓名字段到班主任字段上" class="headerlink" title="配置类添加配置，映射第一个老师的姓名字段到班主任字段上"></a>配置类添加配置，映射第一个老师的姓名字段到班主任字段上</h3><p><font color='red'>注意：使用单向映射，否则会出现反向映射会多一个空对象在原来的数组对象面。</font></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210305151431277.png" alt="image-20210305151431276"></p><p>输出结果：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210305151431278.png" alt="image-20210305151431276"></p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>Dozer 开箱即用的功能之一就是类型转换，大多数类型我们不需要手动转换类型，完全交给 Dozer即可</p><h3 id="StudentVo的age字段修改为String"><a href="#StudentVo的age字段修改为String" class="headerlink" title="StudentVo的age字段修改为String"></a>StudentVo的age字段修改为String</h3><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210305151431279.png" alt="image-20210305151431279"></p><p>输出结果：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210305151431280.png" alt="image-20210305151431280"></p><h2 id="类型转换的特殊情况（Date-和-String-不可以互转）"><a href="#类型转换的特殊情况（Date-和-String-不可以互转）" class="headerlink" title="类型转换的特殊情况（Date 和 String 不可以互转）"></a>类型转换的特殊情况（Date 和 String 不可以互转）</h2><h3 id="Student和StudentVo增加字段schoolTime"><a href="#Student和StudentVo增加字段schoolTime" class="headerlink" title="Student和StudentVo增加字段schoolTime"></a>Student和StudentVo增加字段schoolTime</h3><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210305151431281.png" alt="image-20210305151431281"></p><h3 id="config增加对时间格式的处理"><a href="#config增加对时间格式的处理" class="headerlink" title="config增加对时间格式的处理"></a>config增加对时间格式的处理</h3><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210305151431282.png" alt="image-20210305151431281"></p><p>输出结果：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210305151431283.png" alt="image-20210305151431281"></p><h3 id="也可以进行全局设置，在config里面配置的xml文件添加对时间格式化的代码即可，但是如果两边同时配置，会优先使用mapping里面的配置"><a href="#也可以进行全局设置，在config里面配置的xml文件添加对时间格式化的代码即可，但是如果两边同时配置，会优先使用mapping里面的配置" class="headerlink" title="也可以进行全局设置，在config里面配置的xml文件添加对时间格式化的代码即可，但是如果两边同时配置，会优先使用mapping里面的配置"></a>也可以进行全局设置，在config里面配置的xml文件添加对时间格式化的代码即可，但是如果两边同时配置，会优先使用mapping里面的配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 默认是 true，当发生转换错误时抛出异常，停止转换，这里设置成false，如果转换错误，继续转换 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">stop-on-errors</span>&gt;</span>false<span class="tag">&lt;/<span class="name">stop-on-errors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">date-format</span>&gt;</span>yyyy年MM月dd日 HH时mm分ss秒<span class="tag">&lt;/<span class="name">date-format</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210305151431284.png" alt="image-20210305151431284"></p><h2 id="指定情况进行映射"><a href="#指定情况进行映射" class="headerlink" title="指定情况进行映射"></a>指定情况进行映射</h2><h3 id="指定使用userFileldOneWay来设置年龄字段进行单向映射"><a href="#指定使用userFileldOneWay来设置年龄字段进行单向映射" class="headerlink" title="指定使用userFileldOneWay来设置年龄字段进行单向映射"></a>指定使用userFileldOneWay来设置年龄字段进行单向映射</h3><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210305151431285.png" alt="image-20210305151431285"></p><h3 id="编写测试类，输出年龄"><a href="#编写测试类，输出年龄" class="headerlink" title="编写测试类，输出年龄"></a>编写测试类，输出年龄</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDefault2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Class&gt; classList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Class classes = <span class="keyword">new</span> Class(<span class="string">&quot;1001&quot;</span>,<span class="string">&quot;语文&quot;</span>,<span class="string">&quot;语文老师&quot;</span>);</span><br><span class="line">    Class classes1 = <span class="keyword">new</span> Class(<span class="string">&quot;1002&quot;</span>,<span class="string">&quot;数学&quot;</span>,<span class="string">&quot;数学老师&quot;</span>);</span><br><span class="line">    Class classes2 = <span class="keyword">new</span> Class(<span class="string">&quot;1003&quot;</span>,<span class="string">&quot;英语&quot;</span>,<span class="string">&quot;英语老师&quot;</span>);</span><br><span class="line">    Collections.addAll(classList,classes,classes1,classes2);</span><br><span class="line">    Student student = <span class="keyword">new</span> Student();</span><br><span class="line">    student.setId(<span class="number">1L</span>);</span><br><span class="line">    student.setName(<span class="string">&quot;测试姓名&quot;</span>);</span><br><span class="line">    student.setAge(<span class="number">18</span>);</span><br><span class="line">    student.setMobile(<span class="string">&quot;123333333&quot;</span>);</span><br><span class="line">    student.setAddr(<span class="string">&quot;广州&quot;</span>);</span><br><span class="line">    student.setAddress(<span class="keyword">new</span> Address(<span class="string">&quot;广东省&quot;</span>,<span class="string">&quot;广州市&quot;</span>,<span class="string">&quot;天河区&quot;</span>,<span class="string">&quot;XXX路201号&quot;</span>));</span><br><span class="line">    student.setClassList(classList);</span><br><span class="line">    student.setSchoolTime(<span class="keyword">new</span> Timestamp(System.currentTimeMillis()));</span><br><span class="line">    StudentVo studentVo = dozerMapper.map(student, StudentVo.class);</span><br><span class="line">    log.info(<span class="string">&quot;不指定StudentVo: [&#123;&#125;]&quot;</span>, studentVo.getAge());</span><br><span class="line">    Student student1 = dozerMapper.map(studentVo, Student.class);</span><br><span class="line">    log.info(<span class="string">&quot;不指定Student: [&#123;&#125;]&quot;</span>,student1.getAge());</span><br><span class="line">    StudentVo studentVo1 = dozerMapper.map(student, StudentVo.class,<span class="string">&quot;userFieldOneWay&quot;</span>);</span><br><span class="line">    log.info(<span class="string">&quot;指定StudentVo: [&#123;&#125;]&quot;</span>, studentVo1.getAge());</span><br><span class="line">    Student student2 = dozerMapper.map(studentVo1, Student.class,<span class="string">&quot;userFieldOneWay&quot;</span>);</span><br><span class="line">    log.info(<span class="string">&quot;指定Student: [&#123;&#125;]&quot;</span>,student2.getAge());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210305151431286.png" alt="image-20210305151431286"></p><p>输出结果：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210305151431287.png" alt="image-20210305151431287"></p><h2 id="自定义进行映射转换"><a href="#自定义进行映射转换" class="headerlink" title="自定义进行映射转换"></a>自定义进行映射转换</h2><h3 id="新增学生成绩字段Student是Integer类型，StudentVo是枚举类型"><a href="#新增学生成绩字段Student是Integer类型，StudentVo是枚举类型" class="headerlink" title="新增学生成绩字段Student是Integer类型，StudentVo是枚举类型"></a>新增学生成绩字段Student是Integer类型，StudentVo是枚举类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.g4b.study.dozer.config;</span><br><span class="line"><span class="comment">/**分数等级枚举类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cqw*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ScoreEnum</span> </span>&#123;</span><br><span class="line">    <span class="comment">//85~100分为等级A</span></span><br><span class="line">    A,</span><br><span class="line">    <span class="comment">//75~84分为等级B</span></span><br><span class="line">    B,</span><br><span class="line">    <span class="comment">//60~74分为等级C</span></span><br><span class="line">    C,</span><br><span class="line">    <span class="comment">//&lt;60分为等级D</span></span><br><span class="line">    D</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210305151431288.png" alt="image-20210305151431288"></p><h3 id="定义之定义的方法"><a href="#定义之定义的方法" class="headerlink" title="定义之定义的方法"></a>定义之定义的方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScoreConverter</span> <span class="keyword">extends</span> <span class="title">DozerConverter</span>&lt;<span class="title">Integer</span>,<span class="title">ScoreEnum</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ScoreConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(Integer.class, ScoreEnum.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ScoreEnum <span class="title">convertTo</span><span class="params">(Integer score, ScoreEnum scoreEnum)</span> </span>&#123;</span><br><span class="line">        ScoreEnum result = ScoreEnum.D;</span><br><span class="line">        <span class="keyword">if</span>(score &gt;= <span class="number">85</span>)&#123;</span><br><span class="line">            result = ScoreEnum.A;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(score &gt;= <span class="number">75</span> &amp;&amp; score &lt; <span class="number">85</span>)&#123;</span><br><span class="line">            result = ScoreEnum.B;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(score &gt;= <span class="number">60</span> &amp;&amp; score &lt; <span class="number">75</span>)&#123;</span><br><span class="line">            result = ScoreEnum.C;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">convertFrom</span><span class="params">(ScoreEnum scoreEnum, Integer integer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScoreConverter</span> <span class="keyword">extends</span> <span class="title">DozerConverter</span>&lt;<span class="title">Integer</span>,<span class="title">ScoreEnum</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ScoreConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(Integer.class, ScoreEnum.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ScoreEnum <span class="title">convertTo</span><span class="params">(Integer score, ScoreEnum scoreEnum)</span> </span>&#123;</span><br><span class="line">        ScoreEnum result = ScoreEnum.D;</span><br><span class="line">        <span class="keyword">if</span>(score &gt;= <span class="number">85</span>)&#123;</span><br><span class="line">            result = ScoreEnum.A;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(score &gt;= <span class="number">75</span> &amp;&amp; score &lt; <span class="number">85</span>)&#123;</span><br><span class="line">            result = ScoreEnum.B;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(score &gt;= <span class="number">60</span> &amp;&amp; score &lt; <span class="number">75</span>)&#123;</span><br><span class="line">            result = ScoreEnum.C;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">convertFrom</span><span class="params">(ScoreEnum scoreEnum, Integer integer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置转换字段"><a href="#配置转换字段" class="headerlink" title="配置转换字段"></a>配置转换字段</h3><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210305151431289.png" alt="image-20210305151431289"></p><h3 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDefault3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Student&gt; students = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Student student = <span class="keyword">new</span> Student();</span><br><span class="line">    student.setName(<span class="string">&quot;小明&quot;</span>);</span><br><span class="line">    student.setScore(<span class="number">80</span>);</span><br><span class="line">    students.add(student);</span><br><span class="line">    Student student1 = <span class="keyword">new</span> Student();</span><br><span class="line">    student1.setName(<span class="string">&quot;小宏&quot;</span>);</span><br><span class="line">    student1.setScore(<span class="number">55</span>);</span><br><span class="line">    students.add(student1);</span><br><span class="line">    Student student2 = <span class="keyword">new</span> Student();</span><br><span class="line">    student2.setName(<span class="string">&quot;小红&quot;</span>);</span><br><span class="line">    student2.setScore(<span class="number">94</span>);</span><br><span class="line">    students.add(student2);</span><br><span class="line">    Student student3 = <span class="keyword">new</span> Student();</span><br><span class="line">    student3.setName(<span class="string">&quot;小1&quot;</span>);</span><br><span class="line">    student3.setScore(<span class="number">65</span>);</span><br><span class="line">    students.add(student3);</span><br><span class="line">    <span class="keyword">for</span> (Student stu : students) &#123;</span><br><span class="line">        StudentVo studentVo1 = dozerMapper.map(stu, StudentVo.class);</span><br><span class="line">        log.info(studentVo1.getName()+<span class="string">&quot;的成绩是: [&#123;&#125;],其等级是: [&#123;&#125;];&quot;</span>,stu.getScore(), studentVo1.getScore());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210305151431290.png" alt="image-20210305151431290"></p><h1 id="实现转换List的工具类"><a href="#实现转换List的工具类" class="headerlink" title="实现转换List的工具类"></a>实现转换List的工具类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.g4b.study.dozer.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.dozer.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.NonNull;</span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DozerUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * dozer转换的核心mapper对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Mapper dozerMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Mapper mapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DozerUtil.setDozerMapper(mapper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDozerMapper</span><span class="params">(Mapper dozerMapper)</span> </span>&#123;</span><br><span class="line">        DozerUtil.dozerMapper = dozerMapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 转换实体为另一个指定的实体</span></span><br><span class="line"><span class="comment">     * 任意一个参数为NULL时 会抛出NPE</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source 源实体 不能为NULL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz 目标实体 不能为NULL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; 泛型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 转换后的结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">convert</span><span class="params">(<span class="meta">@NonNull</span> Object source, <span class="meta">@NonNull</span> Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  dozerMapper.map(source, clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 转换List实体为另一个指定的实体</span></span><br><span class="line"><span class="comment">     * source如果为NULL 会使用空集合</span></span><br><span class="line"><span class="comment">     * 在目标实体为NULL时 会抛出NPE</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source 源集合 可以为NULL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz 目标实体 不能为NULL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; 泛型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 转换后的结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">convert</span><span class="params">(<span class="meta">@Nullable</span> List&lt;?&gt; source, <span class="meta">@NonNull</span> Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.ofNullable(source)</span><br><span class="line">                .orElse(Collections.emptyList())</span><br><span class="line">                .stream()</span><br><span class="line">                .map(bean -&gt; dozerMapper.map(bean, clazz))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDefault6</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Class classes = <span class="keyword">new</span> Class(<span class="string">&quot;1001&quot;</span>,<span class="string">&quot;语文&quot;</span>,<span class="string">&quot;语文老师&quot;</span>);</span><br><span class="line">        Class classes1 = <span class="keyword">new</span> Class(<span class="string">&quot;1002&quot;</span>,<span class="string">&quot;数学&quot;</span>,<span class="string">&quot;数学老师&quot;</span>);</span><br><span class="line">        Class classes2 = <span class="keyword">new</span> Class(<span class="string">&quot;1003&quot;</span>,<span class="string">&quot;英语&quot;</span>,<span class="string">&quot;英语老师&quot;</span>);</span><br><span class="line">        List&lt;Class&gt; paramList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Collections.addAll(paramList,classes,classes1,classes2);</span><br><span class="line">        List&lt;ClassVo&gt; convert = DozerUtil.convert(paramList, ClassVo.class);</span><br><span class="line">        System.out.println(convert);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210305161853199.png" alt="image-20210305161853199"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> Dozer </category>
          
          <category> 对象拷贝 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dozer </tag>
            
            <tag> 复制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apache JMeter的介绍和使用</title>
      <link href="/blog/2021/03/01/Apache%20JMeter%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
      <url>/blog/2021/03/01/Apache%20JMeter%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Apache-JMeter的介绍和使用"><a href="#Apache-JMeter的介绍和使用" class="headerlink" title="Apache JMeter的介绍和使用"></a>Apache JMeter的介绍和使用</h1><p>​        Apache JMeter是一款纯java编写负载功能测试和性能测试开源工具软件。相比Loadrunner而言，JMeter小巧轻便且免费，逐渐成为了主流的性能测试工具，是每个测试人员都必须要掌握的工具之一。</p><h1 id="JMeter的安装"><a href="#JMeter的安装" class="headerlink" title="JMeter的安装"></a>JMeter的安装</h1><h2 id="安装要求"><a href="#安装要求" class="headerlink" title="安装要求"></a>安装要求</h2><p>由于JMeter是基于java进行开发，所以需要安装JDK，安装JDK8或以上。</p><h2 id="安装Jmeter"><a href="#安装Jmeter" class="headerlink" title="安装Jmeter"></a>安装Jmeter</h2><h3 id="Jmeter的下载"><a href="#Jmeter的下载" class="headerlink" title="Jmeter的下载"></a>Jmeter的下载</h3><p>下载地址：<a href="http://jmeter.apache.org/download_jmeter.cgi">http://jmeter.apache.org/download_jmeter.cgi</a></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1607852531286.png" alt="1607852531286"></p><h3 id="解压安装包，打开安装包bin目录，双击jmeter-bat启动"><a href="#解压安装包，打开安装包bin目录，双击jmeter-bat启动" class="headerlink" title="解压安装包，打开安装包bin目录，双击jmeter.bat启动"></a>解压安装包，打开安装包bin目录，双击jmeter.bat启动</h3><p><img src="http://cheng_qiwei.gitee.io/blog/img/1607853875816.png" alt="1607853875816"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1607853902084.png" alt="1607853902084"></p><p>3、设置语言为中文</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1607854203203.png" alt="1607854203203"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1607854246428.png" alt="1607854246428"></p><h1 id="Jmeter的使用"><a href="#Jmeter的使用" class="headerlink" title="Jmeter的使用"></a>Jmeter的使用</h1><h2 id="创建线程组"><a href="#创建线程组" class="headerlink" title="创建线程组"></a>创建线程组</h2><p>​        右键点击“测试计划” -&gt; “添加” -&gt; “线程（用户）” -&gt; “线程组”</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1607854808012.png" alt="1607854808012"></p><p>线程组参数详解： </p><p><strong>线程数</strong>：虚拟用户数。一个虚拟用户占用一个进程或线程。设置多少虚拟用户数在这里也就是设置多少个线程数。 </p><p><strong>Ramp-Up Period(in seconds)准备时长</strong>：设置的虚拟用户数需要多长时间全部启动。如果线程数为10，准备时长为2，那么需要2秒钟启动10个线程，也就是每秒钟启动5个线程。 </p><p><strong>循环次数</strong>：每个线程发送请求的次数。如果线程数为10，循环次数为100，那么每个线程发送100次请求。总请求数为10*100=1000 。如果勾选了“永远”，那么所有线程会一直发送请求，一到选择停止运行脚本。  </p><p><strong>调度器</strong>：设置线程组启动的开始时间和结束时间(配置调度器时，需要勾选循环次数为永远) 。</p><p><strong>持续时间（秒）</strong>：测试持续时间，会覆盖结束时间 。</p><p><strong>启动延迟（秒）</strong>：测试延迟启动时间，会覆盖启动时间 。</p><p><strong>启动时间</strong>：测试启动时间，启动延迟会覆盖它。当启动时间已过，手动只需测试时当前时间也会覆盖它。 </p><p><strong>结束时间</strong>：测试结束时间，持续时间会覆盖它。</p><h2 id="添加请求"><a href="#添加请求" class="headerlink" title="添加请求"></a>添加请求</h2><p>​        右键点击“线程组” -&gt; “添加” -&gt; “Sampler” -&gt; “HTTP请求” </p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1607855692886.png" alt="1607855692886"></p><p>​        假设我们的测试接口是：<a href="http://www.baidu.com/s?ie=utf-8&amp;wd=jmeter%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%8F%82%E8%80%83%E4%B8%8B%E5%9B%BE%E5%A1%AB%E5%86%99%EF%BC%9A">http://www.baidu.com/s?ie=utf-8&amp;wd=jmeter性能测试，可以参考下图填写：</a></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1607855972981.png" alt="1607855972981"></p><p>Http请求主要参数详解：</p><p><strong>协议</strong>：向目标服务器发送HTTP请求协议，可以是HTTP或HTTPS，默认为HTTP。 </p><p><strong>服务器名称或IP</strong>：HTTP请求发送的目标服务器名称或IP 。</p><p><strong>端口号</strong>：目标服务器的端口号，默认值为80 。</p><p><strong>方法</strong>：发送HTTP请求的方法，可用方法包括GET、POST、HEAD、PUT、OPTIONS、TRACE、DELETE等。 </p><p><strong>路径</strong>：目标URL路径（URL中去掉服务器地址、端口及参数后剩余部分） 。</p><p><strong>Content encoding内容编码</strong> ：编码方式，默认为ISO-8859-1编码，这里配置为utf-8。</p><p><strong>同请求一起发送参数</strong>：在请求中发送的URL参数，用户可以将URL中所有参数设置在本表中，表中每行为一个参数（对应URL中的 name=value），注意参数传入中文时需要勾选“编码”。</p><h2 id="添加察看结果树"><a href="#添加察看结果树" class="headerlink" title="添加察看结果树"></a>添加察看结果树</h2><p>​        右键点击“线程组” -&gt; “添加” -&gt; “监听器” -&gt; “察看结果树” </p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1607856632948.png" alt="1607856632948"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1607856844503.png" alt="1607856844503"></p><p>​        由于这个页面是一个html页面，所以我们要配置响应数据格式为“HTML Source Formatted”</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><img src="http://cheng_qiwei.gitee.io/blog/img/1607873443952.png" alt="1607873443952"></p><p>​        点击测试开始的按钮，我们可以看到测试了10个数据，返回status都是ok</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1607857241735.png" alt="1607857241735"></p><p>​        这样一个jmeter的测试就结束了</p><h2 id="添加自定义变量"><a href="#添加自定义变量" class="headerlink" title="添加自定义变量"></a>添加自定义变量</h2><p>​        我们可以添加用户自定义变量用以Http请求参数化，右键点击“线程组” -&gt; “添加” -&gt; “配置元件” -&gt; “用户定义的变量”：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1607857512292.png" alt="1607857512292"></p><h3 id="设置名称为wd，值为Jmeter测试动态变量"><a href="#设置名称为wd，值为Jmeter测试动态变量" class="headerlink" title="设置名称为wd，值为Jmeter测试动态变量"></a>设置名称为wd，值为Jmeter测试动态变量</h3><p><img src="http://cheng_qiwei.gitee.io/blog/img/1607871038056.png" alt="1607871038056"></p><h3 id="http请求的值，使用-wd-来动态获取该变量的值"><a href="#http请求的值，使用-wd-来动态获取该变量的值" class="headerlink" title="http请求的值，使用${wd}来动态获取该变量的值"></a>http请求的值，使用${wd}来动态获取该变量的值</h3><p><img src="http://cheng_qiwei.gitee.io/blog/img/1607871132432.png" alt="1607871132432"></p><h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><p><img src="http://cheng_qiwei.gitee.io/blog/img/1607871275266.png" alt="1607871275266"></p><p>​        点击测试，观察结果，返回了我们自定义的搜索词Jmeter测试动态变量，修改成功！</p><h2 id="添加断言结果"><a href="#添加断言结果" class="headerlink" title="添加断言结果"></a>添加断言结果</h2><p>​        上一步测试中如果返回的内容复杂且多，那我们可能要找到的难度就会提高，此时我们可以使用断言结果来进行处理。</p><p>​        右键点击“线程组” -&gt; “添加”-&gt; “断言” -&gt; “响应断言” </p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1607871694041.png" alt="1607871694041"></p><h3 id="添加匹配规则为包括，测试模式为我们添加的参数，用-wd-代替，点击保存"><a href="#添加匹配规则为包括，测试模式为我们添加的参数，用-wd-代替，点击保存" class="headerlink" title="添加匹配规则为包括，测试模式为我们添加的参数，用${wd}代替，点击保存"></a>添加匹配规则为包括，测试模式为我们添加的参数，用${wd}代替，点击保存</h3><p><img src="http://cheng_qiwei.gitee.io/blog/img/1607871803267.png" alt="1607871803267"></p><h3 id="添加断言结果-1"><a href="#添加断言结果-1" class="headerlink" title="添加断言结果"></a>添加断言结果</h3><p><img src="http://cheng_qiwei.gitee.io/blog/img/1607871993115.png" alt="1607871993115"></p><p>​        当前的测试规则是，结果包含参数数据则为true</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1607873562323.png" alt="1607873562323"></p><h3 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h3><p><img src="http://cheng_qiwei.gitee.io/blog/img/1607873130707.png" alt="1607873130707"></p><p>​        点击测试，如果断言结果为true，则不会返回什么内容，如图为成功，如果失败，则会返回如下图展示的内容</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1607873228037.png" alt="1607873228037"></p><h2 id="设置动态参数"><a href="#设置动态参数" class="headerlink" title="设置动态参数"></a>设置动态参数</h2><p>​        有时候我们的测试参数不是一成不变的，如果我们需要在测试的时候动态修改参数，则可以进行以下配置。</p><p>​        右键点击“http请求” -&gt; “添加”-&gt; “配置元件” -&gt; “CSV Data Set Config” </p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1607873807373.png" alt="1607873807373"></p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1607874202732.png" alt="1607874202732"></p><p>​        这里要注意文本保存的编码方式要和设置的文件编码方式一致，否则会出现中文乱码的情况。</p><p>测试：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1607874474506.png" alt="1607874474506"></p><h2 id="添加聚合报告"><a href="#添加聚合报告" class="headerlink" title="添加聚合报告"></a>添加聚合报告</h2><p>​        右键点击“线程组” -&gt; “添加” -&gt; “监听器” -&gt; “聚合报告”，用以存放性能测试报告 </p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1607875044907.png" alt="1607875044907"></p><p>测试：</p><p><img src="http://cheng_qiwei.gitee.io/blog/img/1607875196722.png" alt="1607875196722"></p><p>聚合报告参数详解： </p><p><strong>Label</strong>：每个 JMeter 的 element（例如 HTTP Request）都有一个 Name 属性，这里显示的就是 Name 属性的值 ；</p><p><strong>#Samples（样本）</strong>：请求数——表示这次测试中一共发出了多少个请求，如果模拟10个用户，每个用户迭代10次，那么这里显示100 ；</p><p> <strong>Average</strong>：平均响应时间——默认情况下是单个 Request 的平均响应时间，当使用了 Transaction Controller 时，以Transaction 为单位显示平均响应时间 ；</p><p><strong>Median</strong>：中位数，也就是 50％ 用户的响应时间；</p><p><strong>90% Line</strong>：90％ 用户的响应时间 ；</p><p><strong>Min</strong>：最小响应时间 ；</p><p><strong>Max</strong>：最大响应时间 ；</p><p>**Error%**：错误率——错误请求数/请求总数 ；</p><p><strong>Throughput</strong>：吞吐量——默认情况下表示每秒完成的请求数（Request per Second），当使用了 Transaction Controller 时，也可以表示类似 LoadRunner 的 Transaction per Second 数 ；</p><p> <strong>KB/Sec</strong>：每秒从服务器端接收到的数据量，相当于LoadRunner中的Throughput/Sec；</p><p>​        一般而言，性能测试中我们需要重点关注的数据有： #Samples 请求数，Average 平均响应时间，Min 最小响应时间，Max 最大响应时间，Error% 错误率及Throughput 吞吐量。</p>]]></content>
      
      
      <categories>
          
          <category> 辅助工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JMeter </tag>
            
            <tag> 性能测试 </tag>
            
            <tag> 压力测试 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
