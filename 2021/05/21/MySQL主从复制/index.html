<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>MySQL主从复制 | WinKings Blogs</title><meta name="keywords" content="MySQL,主从复制"><meta name="author" content="WinKing"><meta name="copyright" content="WinKing"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="MySQL主从复制一、为什么要做主从复制？ 读写分离。在业务复杂的系统中，有这么一个情景，有一句sql语句需要锁表，导致暂时不能使用读的服务，那么就很影响运行中的业务，使用主从复制，让主库负责写，从库负责读，这样，即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运作； 做数据的热备； 架构的扩展。业务量越来越大，I&#x2F;O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I&#x2F;O访问的频率，">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL主从复制">
<meta property="og:url" content="http://cheng_qiwei.gitee.io/blog/2021/05/21/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/index.html">
<meta property="og:site_name" content="WinKings Blogs">
<meta property="og:description" content="MySQL主从复制一、为什么要做主从复制？ 读写分离。在业务复杂的系统中，有这么一个情景，有一句sql语句需要锁表，导致暂时不能使用读的服务，那么就很影响运行中的业务，使用主从复制，让主库负责写，从库负责读，这样，即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运作； 做数据的热备； 架构的扩展。业务量越来越大，I&#x2F;O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I&#x2F;O访问的频率，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2021-05-21T14:00:00.000Z">
<meta property="article:modified_time" content="2021-06-12T07:25:50.465Z">
<meta property="article:author" content="WinKing">
<meta property="article:tag" content="MySQL">
<meta property="article:tag" content="主从复制">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/blog/img/favicon.png"><link rel="canonical" href="http://cheng_qiwei.gitee.io/blog/2021/05/21/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/blog/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/blog/WinKings%20Blogs" media="print" onload="this.media='all'"><script>var GLOBAL_CONFIG = { 
  root: '/blog/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}

// https://stackoverflow.com/questions/16839698/jquery-getscript-alternative-in-native-javascript
const getScript = url => new Promise((resolve, reject) => {
  const script = document.createElement('script')
  script.src = url
  script.async = true
  script.onerror = reject
  script.onload = script.onreadystatechange = function() {
    const loadState = this.readyState
    if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
    script.onload = script.onreadystatechange = null
    resolve()
  }
  document.head.appendChild(script)
})</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-06-12 15:25:50'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/blog/img/touxiang.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/blog/archives/"><div class="headline">文章</div><div class="length-num">20</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/blog/tags/"><div class="headline">标签</div><div class="length-num">39</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/blog/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/blog/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/blog/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/blog/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/blog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/blog/">WinKings Blogs</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/blog/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/blog/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/blog/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/blog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">MySQL主从复制</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-05-21T14:00:00.000Z" title="发表于 2021-05-21 22:00:00">2021-05-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-06-12T07:25:50.465Z" title="更新于 2021-06-12 15:25:50">2021-06-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/blog/categories/MySQL/">MySQL</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="MySQL主从复制"><a href="#MySQL主从复制" class="headerlink" title="MySQL主从复制"></a>MySQL主从复制</h1><h1 id="一、为什么要做主从复制？"><a href="#一、为什么要做主从复制？" class="headerlink" title="一、为什么要做主从复制？"></a>一、为什么要做主从复制？</h1><ol>
<li>读写分离。在业务复杂的系统中，有这么一个情景，有一句sql语句需要锁表，导致暂时不能使用读的服务，那么就很影响运行中的业务，使用主从复制，让主库负责写，从库负责读，这样，即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运作；</li>
<li>做数据的热备；</li>
<li>架构的扩展。业务量越来越大，I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问的频率，提高单个机器的I/O性能。</li>
</ol>
<h1 id="二、主从复制的原理"><a href="#二、主从复制的原理" class="headerlink" title="二、主从复制的原理"></a>二、主从复制的原理</h1><p>&emsp;&emsp;MySQL 默认采用异步复制方式，这样从节点不用一直访问主服务器来更新自己的数据，数据的更新可以在远程连接上进行，从节点可以复制主数据库中的所有数据库或者特定的数据库，或者特定的表。</p>
<p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210526152857598.png" alt="image-20210526152857598"></p>
<blockquote>
<p>具体复制步骤：</p>
<ol>
<li>在Slave服务器上执行start slave命令开启主从复制开关，开始进行主从复制；</li>
<li>Slave服务器的IO线程会通过在master上已经授权的复制用户权限请求连接Master服务器【username、password、ip、port】，并请求从执行bin log日志文件中的指定位置【file名称和position号】之后开始发送bin log日志内容；</li>
<li>从库的IO线程和主库的dump线程建立连接，其上负责复制的IO线程会根据Slave服务器的IO线程请求的信息分批读取指定bin log日志文件指定位置之后的bin log日志信息，然后返回给Slave端的IO线程。返回的信息中除了bin log日志内容外，还有在Master服务器端记录的IO线程；</li>
<li>当Slave服务器的IO线程获取到Master服务器上IO线程发送的日志内容、日志文件及位置点后，会将bin log日志内容依次写到Slave端自身的Relay Log（即中继日志）文件（Mysql-relay-bin.xxx）的最末端，并将新的bin log文件名和位置记录到master-info文件中，以便下一次读取master端新bin log日志时能告诉Master服务器从新bin log日志的指定文件及位置开始读取新的bin log日志内容；</li>
<li>Slave服务器端的SQL线程会实时检测本地Relay log 中IO线程新增的日志内容，然后及时把Relay log 文件中的内容解析成sql语句，并在自身Slave服务器上按解析SQL语句的位置顺序执行应用这样SQL语句，并在relay-log.info中记录当前应用中继日志的文件名和位置点。已经应用过的Relay log会被purge清理。</li>
</ol>
</blockquote>
<p>简单来讲：</p>
<blockquote>
<p>1、从库会生成两个线程。一个是I/O线程，一个是SQL线程；</p>
<p>2、I/O线程的作用是：请求主库的bin log日志，并将获得的bin log日志写入本地的relay-log（中继日志）文件中；</p>
<p>3、主库会生成一个log dump线程，用来给从库I/O线程传递bin log；</p>
<p>4、SQL线程则会读取保存的relay-log，并解析成SQL语句逐一执行（这个过程也称为重放）。</p>
</blockquote>
<h1 id="三、主从复制操作"><a href="#三、主从复制操作" class="headerlink" title="三、主从复制操作"></a>三、主从复制操作</h1><p>&emsp;&emsp;主从复制可以分为一主一从、一主多从、多主多从等。本节演示的是一主一从的操作。</p>
<h2 id="1、修改配置文件"><a href="#1、修改配置文件" class="headerlink" title="1、修改配置文件"></a>1、修改配置文件</h2><h3 id="1-1、保证两部机器能够ping通"><a href="#1-1、保证两部机器能够ping通" class="headerlink" title="1.1、保证两部机器能够ping通"></a>1.1、保证两部机器能够ping通</h3><p>&emsp;&emsp;本次使用两台虚拟机的数据库来进行操作。两台机器的配置如下：</p>
<table>
<thead>
<tr>
<th align="center">机器类型</th>
<th align="center">IP</th>
<th align="center">PORT</th>
</tr>
</thead>
<tbody><tr>
<td align="center">主机</td>
<td align="center">192.168.66.129</td>
<td align="center">3306</td>
</tr>
<tr>
<td align="center">从机</td>
<td align="center">192.168.66.130</td>
<td align="center">3306</td>
</tr>
</tbody></table>
<p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210527000012385.png" alt="image-20210527000012385"></p>
<h3 id="1-2、修改配置文件"><a href="#1-2、修改配置文件" class="headerlink" title="1.2、修改配置文件"></a>1.2、修改配置文件</h3><h4 id="1-2-1、修改master配置文件vi-etc-my-cnf"><a href="#1-2-1、修改master配置文件vi-etc-my-cnf" class="headerlink" title="1.2.1、修改master配置文件vi /etc/my.cnf"></a>1.2.1、修改<code>master</code>配置文件<code>vi /etc/my.cnf</code></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">mysql服务唯一id，不同的mysql服务必须拥有全局唯一的id</span></span><br><span class="line">server-id=1</span><br><span class="line"><span class="meta">#</span><span class="bash">启动二进制日志</span></span><br><span class="line">log-bin=mysql-bin</span><br><span class="line"><span class="meta">#</span><span class="bash">设置不要复制的数据库</span></span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line">binlog-ignore-db=information-schema</span><br><span class="line"><span class="meta">#</span><span class="bash">设置需要复制的数据库</span></span><br><span class="line">binlog-do-db=mytest</span><br><span class="line"><span class="meta">#</span><span class="bash">设置binlog的格式row（在binlog里面记录在哪个行上做了修改，逻辑语法）、statement（保存操作时的语句）、mixed（两种方式混合使用）</span></span><br><span class="line">binlog_format=statement</span><br></pre></td></tr></table></figure>

<h4 id="1-2-2、修改slave配置文件vi-etc-my-cnf"><a href="#1-2-2、修改slave配置文件vi-etc-my-cnf" class="headerlink" title="1.2.2、修改slave配置文件vi /etc/my.cnf"></a>1.2.2、修改<code>slave</code>配置文件<code>vi /etc/my.cnf</code></h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#服务器唯一id</span></span><br><span class="line">server-id=2</span><br><span class="line"><span class="comment">#启动中继日志</span></span><br><span class="line">relay-log=mysql-relay</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;修改完成后，需要重启主机和从机的mysql</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysql restart</span><br></pre></td></tr></table></figure>

<h2 id="2、授权账户"><a href="#2、授权账户" class="headerlink" title="2、授权账户"></a>2、授权账户</h2><p>&emsp;&emsp;登录master的mysql服务，授权账户主从复制权限</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 授权主从复制权限</span><br><span class="line">grant replication slave on *.* to &#x27;root&#x27;@&#x27;%&#x27; identified by &#x27;Root_123&#x27;;</span><br><span class="line">-- 在进行授权的时候，如果提示密码的问题，把密码验证取消</span><br><span class="line">set global validate_password_policy=0;</span><br><span class="line">set global validate_password_length=1;</span><br></pre></td></tr></table></figure>

<p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210527001610045.png" alt="image-20210527001610045"></p>
<h2 id="3、查看主机状态"><a href="#3、查看主机状态" class="headerlink" title="3、查看主机状态"></a>3、查看主机状态</h2><p>&emsp;&emsp;使用<code>show master status</code>查询master状态</p>
<p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210527002003154.png" alt="image-20210527002003154"></p>
<p>&emsp;&emsp;这里File和Position的值在下面的slave服务中会使用到；</p>
<p>&emsp;&emsp;我们可以通过<code>start master</code>、<code>stop master</code>、<code>reset master</code>等命令操作master，但是操作之后的master状态值可能发生变化。</p>
<h2 id="4、执行主从复制"><a href="#4、执行主从复制" class="headerlink" title="4、执行主从复制"></a>4、执行主从复制</h2><h3 id="4-1、slave执行主从复制命令"><a href="#4-1、slave执行主从复制命令" class="headerlink" title="4.1、slave执行主从复制命令"></a>4.1、slave执行主从复制命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CHANGE MASTER TO MASTER_HOST=&#x27;192.168.66.129&#x27;,MASTER_USER=&#x27;root&#x27;,MASTER_PASSWORD=&#x27;Root_123&#x27;,MASTER_LOG_FILE=&#x27;mysql-bin.000001&#x27;,MASTER_LOG_POS=429;</span><br></pre></td></tr></table></figure>

<p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210527002242562.png" alt="image-20210527002242562"></p>
<h3 id="4-2、查看从机状态"><a href="#4-2、查看从机状态" class="headerlink" title="4.2、查看从机状态"></a>4.2、查看从机状态</h3><p>&emsp;&emsp;使用命令查看从机状态，此时发现 I/O 线程和 SQL 线程都是停止的。此时需要启动它们。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">show slave status\G;</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动线程</span></span><br><span class="line">start slave;</span><br></pre></td></tr></table></figure>



<p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210527002326955.png" alt="image-20210527002326955"></p>
<p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210527002643485.png" alt="image-20210527002643485"></p>
<p>&emsp;&emsp;这里可能会出现异常，例如I/O线程为NO，这种情况有可能是以下几个：</p>
<blockquote>
<p>1、mysql5.6以上版本使用唯一uuid表示符，数据迁移是使用的物理备份，uuid会重复，修改uuid不一致即可。这个是最有可能的原因。拷贝虚拟机之后就会出现这种情况。</p>
<p>修改 /usr/local/mysql-5.7.28/data 路径下的 auto.cnf 文件即可。</p>
<p>2、确认server-id 是否唯一， mysql 有可能并没有加载my.cnf 文件中的server-id。</p>
<p>3、这种原因有可能是主库重启造成的二进制文件位置从库于主库不一致。</p>
<p>需要手动将这些文件二进制日志mysql-bin.00000x,mysql-bin.index删除，rm -rf 掉 在重启数据库。</p>
</blockquote>
<p>&emsp;&emsp;此时，主从复制基本部署完毕。关于slave，也可以通过<code>start slave</code>、<code>stop slave</code>、<code>reset slave</code>等命令操作slave。</p>
<h2 id="5、测试主从复制"><a href="#5、测试主从复制" class="headerlink" title="5、测试主从复制"></a>5、测试主从复制</h2><h3 id="5-1、测试建库"><a href="#5-1、测试建库" class="headerlink" title="5.1、测试建库"></a>5.1、测试建库</h3><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210527003940415.png" alt="image-20210527003940415"></p>
<h3 id="5-2、测试建表"><a href="#5-2、测试建表" class="headerlink" title="5.2、测试建表"></a>5.2、测试建表</h3><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210527004219989.png" alt="image-20210527004219989"></p>
<h3 id="5-3、测试插入数据"><a href="#5-3、测试插入数据" class="headerlink" title="5.3、测试插入数据"></a>5.3、测试插入数据</h3><p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210527004353664.png" alt="image-20210527004353664"></p>
<h3 id="5-4、注意事项"><a href="#5-4、注意事项" class="headerlink" title="5.4、注意事项"></a>5.4、注意事项</h3><p>&emsp;&emsp;当master执行的语句被同步到slave时，如果slave存在对应的语句在约束上与master同步过来的语句冲突时，同步会失败，在<code>/var/log/mysqld.log</code>中可以看到错误。所以一般来说从库不允许写入，只能读取。</p>
<h1 id="四、双主双从复制的操作"><a href="#四、双主双从复制的操作" class="headerlink" title="四、双主双从复制的操作"></a>四、双主双从复制的操作</h1><h2 id="1、修改配置文件-1"><a href="#1、修改配置文件-1" class="headerlink" title="1、修改配置文件"></a>1、修改配置文件</h2><h3 id="1-1、保证四部机器能够ping通"><a href="#1-1、保证四部机器能够ping通" class="headerlink" title="1.1、保证四部机器能够ping通"></a>1.1、保证四部机器能够ping通</h3><p>&emsp;&emsp;本次使用四台虚拟机的数据库来进行操作。四台机器的配置如下：</p>
<table>
<thead>
<tr>
<th align="center">机器类型</th>
<th align="center">IP</th>
<th align="center">PORT</th>
</tr>
</thead>
<tbody><tr>
<td align="center">主机</td>
<td align="center">192.168.66.131</td>
<td align="center">3306</td>
</tr>
<tr>
<td align="center">主机从机</td>
<td align="center">192.168.66.132</td>
<td align="center">3306</td>
</tr>
<tr>
<td align="center">备机</td>
<td align="center">192.168.66.133</td>
<td align="center">3306</td>
</tr>
<tr>
<td align="center">备机从机</td>
<td align="center">192.168.66.134</td>
<td align="center">3306</td>
</tr>
</tbody></table>
<h3 id="1-2、停止原来的主从复制"><a href="#1-2、停止原来的主从复制" class="headerlink" title="1.2、停止原来的主从复制"></a>1.2、停止原来的主从复制</h3><p>&emsp;&emsp;在开始配置之前，我们先将之前配置的主从复制停掉并重置，如果没有，则跳过这一步。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">停止从服务器复制</span></span><br><span class="line">stop slave;</span><br><span class="line"><span class="meta">#</span><span class="bash">重置主服务器主机配置</span></span><br><span class="line">reset master;</span><br></pre></td></tr></table></figure>

<h3 id="1-3、修改配置文件"><a href="#1-3、修改配置文件" class="headerlink" title="1.3、修改配置文件"></a>1.3、修改配置文件</h3><p>修改每台仪器的<code>my.cnf</code>文件<code>[vim /etc/my.cnf]</code></p>
<h4 id="1-3-1、Master1-主机-配置"><a href="#1-3-1、Master1-主机-配置" class="headerlink" title="1.3.1、Master1[主机]配置"></a>1.3.1、Master1[主机]配置</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">mysql服务唯一id，不同的mysql服务必须拥有全局唯一的id</span></span><br><span class="line">server-id=1</span><br><span class="line"><span class="meta">#</span><span class="bash">启动二进制日志</span></span><br><span class="line">log-bin=mysql-bin</span><br><span class="line"><span class="meta">#</span><span class="bash">设置不要复制的数据库</span></span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line">binlog-ignore-db=information-schema</span><br><span class="line"><span class="meta">#</span><span class="bash">设置需要复制的数据库</span></span><br><span class="line">binlog-do-db=mytest</span><br><span class="line"><span class="meta">#</span><span class="bash">设置binlog的格式row（在binlog里面记录在哪个行上做了修改，逻辑语法）、statement（保存操作时的语句）、mixed（两种方式混合使用）</span></span><br><span class="line">binlog_format=statement</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在作为从数据库的时候， 有写入操作也要更新二进制日志文件</span></span><br><span class="line">log-slave-updates</span><br><span class="line"><span class="meta">#</span><span class="bash">表示自增长字段每次递增的量，指自增字段的起始值，其默认值是1， 取值范围是1 .. 65535</span></span><br><span class="line">auto-increment-increment=2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示自增长字段从哪个数开始，指字段一次递增多少，他的取值范围是1 .. 65535</span></span><br><span class="line">auto-increment-offset=1</span><br></pre></td></tr></table></figure>

<h4 id="1-3-2、Master2-备机-配置"><a href="#1-3-2、Master2-备机-配置" class="headerlink" title="1.3.2、Master2[备机]配置"></a>1.3.2、Master2[备机]配置</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">主服务器唯一ID</span></span><br><span class="line">server-id=3</span><br><span class="line"><span class="meta">#</span><span class="bash">启用二进制日志</span></span><br><span class="line">log-bin=mysql-bin</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置不要复制的数据库(可设置多个)</span></span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line">binlog-ignore-db=information_schema</span><br><span class="line"><span class="meta">#</span><span class="bash">设置需要复制的数据库</span></span><br><span class="line">binlog-do-db=mytest</span><br><span class="line"><span class="meta">#</span><span class="bash">设置logbin格式</span></span><br><span class="line">binlog_format=STATEMENT</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在作为从数据库的时候，有写入操作也要更新二进制日志文件</span></span><br><span class="line">log-slave-updates</span><br><span class="line"><span class="meta">#</span><span class="bash">表示自增长字段每次递增的量，指自增字段的起始值，其默认值是1，取值范围是1 .. 65535</span></span><br><span class="line">auto-increment-increment=2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示自增长字段从哪个数开始，指字段一次递增多少，他的取值范围是1 .. 65535</span></span><br><span class="line">auto-increment-offset=2</span><br></pre></td></tr></table></figure>

<h4 id="1-3-3、Slave1-主机从机-配置"><a href="#1-3-3、Slave1-主机从机-配置" class="headerlink" title="1.3.3、Slave1[主机从机]配置"></a>1.3.3、Slave1[主机从机]配置</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">从服务器唯一ID</span></span><br><span class="line">server-id=2</span><br><span class="line"><span class="meta">#</span><span class="bash">启用中继日志</span></span><br><span class="line">relay-log=mysql-relay</span><br></pre></td></tr></table></figure>

<h4 id="1-3-4、Slave2-备机从机-配置"><a href="#1-3-4、Slave2-备机从机-配置" class="headerlink" title="1.3.4、Slave2[备机从机]配置"></a>1.3.4、Slave2[备机从机]配置</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">从服务器唯一ID</span></span><br><span class="line">server-id=4</span><br><span class="line"><span class="meta">#</span><span class="bash">启用中继日志</span></span><br><span class="line">relay-log=mysql-relay</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;修改完成后，需要重启双主机和双从机的mysql</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysql restart</span><br></pre></td></tr></table></figure>

<h2 id="2、授权账户-1"><a href="#2、授权账户-1" class="headerlink" title="2、授权账户"></a>2、授权账户</h2><h3 id="2-1、获取主机信息"><a href="#2-1、获取主机信息" class="headerlink" title="2.1、获取主机信息"></a>2.1、获取主机信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 授权主从复制权限</span><br><span class="line">grant replication slave on *.* to &#x27;root&#x27;@&#x27;%&#x27; identified by &#x27;123456&#x27;;</span><br><span class="line">-- 在进行授权的时候，如果提示密码的问题，把密码验证取消</span><br><span class="line">set global validate_password_policy=0;</span><br><span class="line">set global validate_password_length=1;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查询Master1的状态</span></span><br><span class="line">show master status;</span><br></pre></td></tr></table></figure>

<p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210602233656164.png" alt="image-20210602233656164"></p>
<p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210602233721649.png" alt="image-20210602233721649"></p>
<h3 id="2-2、授权从机"><a href="#2-2、授权从机" class="headerlink" title="2.2、授权从机"></a>2.2、授权从机</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 主机授权主机从机</span></span><br><span class="line">CHANGE MASTER TO MASTER_HOST=&#x27;192.168.66.131&#x27;,MASTER_USER=&#x27;root&#x27;,MASTER_PASSWORD=&#x27;123456&#x27;,MASTER_LOG_FILE=&#x27;mysql-bin.000002&#x27;,MASTER_LOG_POS=610;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 备机授权备机从机</span></span><br><span class="line">CHANGE MASTER TO MASTER_HOST=&#x27;192.168.66.133&#x27;,MASTER_USER=&#x27;root&#x27;,MASTER_PASSWORD=&#x27;123456&#x27;,MASTER_LOG_FILE=&#x27;mysql-bin.000001&#x27;,MASTER_LOG_POS=442;</span><br></pre></td></tr></table></figure>

<p>查看状态并启动线程</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">show slave status\G;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">启动线程</span></span><br><span class="line">start slave;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;保证Slave_IO_Running和Slave_SQL_Running是Yes即可，异常情况参考一主一从的处理。</p>
<h3 id="2-3、双主机相互授权"><a href="#2-3、双主机相互授权" class="headerlink" title="2.3、双主机相互授权"></a>2.3、双主机相互授权</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 主机授权备机</span></span><br><span class="line">CHANGE MASTER TO MASTER_HOST=&#x27;192.168.66.131&#x27;,MASTER_USER=&#x27;root&#x27;,MASTER_PASSWORD=&#x27;123456&#x27;,MASTER_LOG_FILE=&#x27;mysql-bin.000002&#x27;,MASTER_LOG_POS=610;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 备机授权主机</span></span><br><span class="line">CHANGE MASTER TO MASTER_HOST=&#x27;192.168.66.133&#x27;,MASTER_USER=&#x27;root&#x27;,MASTER_PASSWORD=&#x27;123456&#x27;,MASTER_LOG_FILE=&#x27;mysql-bin.000001&#x27;,MASTER_LOG_POS=442;</span><br></pre></td></tr></table></figure>

<p>查看状态并启动线程</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">show slave status\G;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">启动线程</span></span><br><span class="line">start slave;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;保证Slave_IO_Running和Slave_SQL_Running是Yes即可，异常情况参考一主一从的处理。</p>
<h2 id="3、测试双主双从复制"><a href="#3、测试双主双从复制" class="headerlink" title="3、测试双主双从复制"></a>3、测试双主双从复制</h2><p>&emsp;&emsp;Master1 主机新建库、新建表、 insert 记录， Master2 和从机复制 。</p>
<p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210603001143525.png" alt="image-20210603001143525"></p>
<h1 id="五、MySQL主从复制的复制方式"><a href="#五、MySQL主从复制的复制方式" class="headerlink" title="五、MySQL主从复制的复制方式"></a>五、MySQL主从复制的复制方式</h1><p>&emsp;&emsp;MySQL的主从复制并不完美，多多少少存在一部分缺陷。MySQL的主从复制的复制方式有以下几种：</p>
<blockquote>
<ol>
<li>基于SQL语句的复制（SBR）；</li>
<li>基于行的复制（RBR）；</li>
<li>混合模式的复制（MBR）；</li>
<li>全局事务标识符GTID。</li>
</ol>
</blockquote>
<h2 id="1、基于SQL语句的复制-SBR"><a href="#1、基于SQL语句的复制-SBR" class="headerlink" title="1、基于SQL语句的复制 SBR"></a>1、基于SQL语句的复制 SBR</h2><p>&emsp;&emsp;基于SQL语句的方式是最古老的方式，也是目前默认的复制方式，后来的三种是MySQL 5以后才出现的复制方式。</p>
<h3 id="1-1、SBR方式的优点"><a href="#1-1、SBR方式的优点" class="headerlink" title="1.1、SBR方式的优点"></a>1.1、SBR方式的优点</h3><blockquote>
<ol>
<li>历史悠久，技术成熟；</li>
<li>bin log文件较小；</li>
<li>bin log文件包含所有数据的更改信息，可以审视数据库的安全情况；</li>
<li>bin log可以用于实时还原而不止复制；</li>
<li>主从数据库版本可以不一致，从库版本可以比主库高。</li>
</ol>
</blockquote>
<h3 id="1-2、SBR方式的缺点"><a href="#1-2、SBR方式的缺点" class="headerlink" title="1.2、SBR方式的缺点"></a>1.2、SBR方式的缺点</h3><blockquote>
<ol>
<li>不是所有UPDATE语句都能够被复制，尤其包含不确定操作的时候；</li>
<li>复制需要进行全表扫描的UPDATE时（没有索引），需要比 RBR 请求更多的行级锁；</li>
<li>对于一些复杂的语句，在从服务器上消耗资源的情况会更加严重，而在 RBR 中，只会对那个发生变化的记录产生影响；</li>
<li>数据表必须几乎和主服务器保持一致，否则会导致复制出错；</li>
<li>执行复杂语句如果出错时，会消耗更多资源。</li>
</ol>
</blockquote>
<h2 id="2、基于行的复制-RBR"><a href="#2、基于行的复制-RBR" class="headerlink" title="2、基于行的复制 RBR"></a>2、基于行的复制 RBR</h2><h3 id="2-1、RBR方式的优点"><a href="#2-1、RBR方式的优点" class="headerlink" title="2.1、RBR方式的优点"></a>2.1、RBR方式的优点</h3><blockquote>
<ol>
<li>任何情况下都能够被复制；</li>
<li>和其他大多数数据库系统的复制技术是一样的；</li>
<li>多数情况下，从库的表如果有主键的话，复制的效率会高很多。</li>
</ol>
</blockquote>
<h3 id="2-2、RBR方式的缺点"><a href="#2-2、RBR方式的缺点" class="headerlink" title="2.2、RBR方式的缺点"></a>2.2、RBR方式的缺点</h3><blockquote>
<ol>
<li>bin log文件相比较SBR来讲大了很多；</li>
<li>复杂的回滚时，bin log中会包含大量数据；</li>
<li>无法从bin log中看到都复制了写什么的语句；</li>
<li>主库上执行UPDATE语句时，所有的变化都会写到bin log上，而SBR只会写一次，从而导致频繁的bin log并发写问题。</li>
</ol>
</blockquote>
<h2 id="3、混合模式的复制-MBR"><a href="#3、混合模式的复制-MBR" class="headerlink" title="3、混合模式的复制 MBR"></a>3、混合模式的复制 MBR</h2><p>&emsp;&emsp;混合模式就是由MySQL自身选择RBR还是SBR，能够充分发挥两种方式的优点，一般情况下都是使用该方式实现主从复制。但是，该情况下不能操作系统变量。</p>
<h2 id="4、全局事务标识符-GTID"><a href="#4、全局事务标识符-GTID" class="headerlink" title="4、全局事务标识符 GTID"></a>4、全局事务标识符 GTID</h2><p>&emsp;&emsp;GTID，也叫全局事务ID，它保证为每一个在主上提交的事务在复制集群中可以生成一个唯一的ID。GITD由两部分组成的，分别是source_id 和transaction_id，GTID =source_id:transaction_id，其中source_id就是执行事务的主库的server-uuid值，server-uuid值是在mysql服务首次启动生成的，保存在数据库的数据目录中，在数据目录中有一个auto.conf文件，这个文件保存了server-uuid值（唯一的）。而事务ID则是从1开始自增的序列，表示这个事务是在主库上执行的第几个事务，Mysql会保证这个事务和GTID是一比一的关系。</p>
<p>&emsp;&emsp;基于GTID的复制是从Mysql5.6开始支持的一种新的复制方式，此方式与传统基于日志的方式存在很大的差异，在原来的基于日志的复制中，<strong>从服务器连接到主服务器并告诉主服务器要从哪个二进制日志的偏移量开始执行增量同步，这时我们如果指定的日志偏移量不对，这与可能造成主从数据的不一致</strong>，而基于GTID的复制会避免。</p>
<p>&emsp;&emsp;在基于GTID的复制中，首先从服务器会告诉主服务器已经在从服务器执行完了哪些事务的GTID值，然后<strong>主库会有把所有没有在从库上执行的事务，发送到从库上进行执行，并且使用GTID的复制可以保证同一个事务只在指定的从库上执行一次，这样可以避免由于偏移量的问题造成数据不一致</strong>。</p>
<h3 id="4-1、GTID方式的优点"><a href="#4-1、GTID方式的优点" class="headerlink" title="4.1、GTID方式的优点"></a>4.1、GTID方式的优点</h3><blockquote>
<ol>
<li>很方便的进行故障转移，因为GTID是全局唯一的标识符，所以就很简单知道哪些事务在从服务器没有执行，在多个从服务器也没必要进行多个日志偏移量配置了；</li>
<li>从库和主库的数据一致性。</li>
</ol>
</blockquote>
<h3 id="4-2、GTID方式的缺点"><a href="#4-2、GTID方式的缺点" class="headerlink" title="4.2、GTID方式的缺点"></a>4.2、GTID方式的缺点</h3><blockquote>
<ol>
<li>故障处理比日志处理复杂;</li>
<li>执行语句的一些限制。</li>
</ol>
</blockquote>
<h1 id="六、MySQL主从复制的延迟问题"><a href="#六、MySQL主从复制的延迟问题" class="headerlink" title="六、MySQL主从复制的延迟问题"></a>六、MySQL主从复制的延迟问题</h1><h2 id="1、为什么会出现延迟？"><a href="#1、为什么会出现延迟？" class="headerlink" title="1、为什么会出现延迟？"></a>1、为什么会出现延迟？</h2><p>&emsp;&emsp;既然是延迟，那么就说明是哪里执行慢了、跟不上了导致的延迟。所以我们就需要从主从复制的流程来进行分析：</p>
<blockquote>
<ul>
<li>mysql的主从复制都是单线程的操作，主库对所有DDL和DML产生的日志写进bin log，由于bin log是顺序写，所以效率很高；</li>
<li>master和slave之间的数据传输依靠了内部网络或专线，一般来说也是比较快的；</li>
<li>slave读取master的数据写入relay log是追加日志，属于顺序io效率并不低；</li>
<li>slave的sql thread线程将主库的DDL和DML操作事件在slave中重放。DML和DDL的IO操作是随机的，不是顺序，所以成本要高很多；</li>
<li>另一方面，由于sql thread也是单线程的，当主库的并发较高时，产生的DML数量超过slave的SQL thread所能处理的速度，或者当slave中有大型query语句产生了锁等待，那么延时就产生了。</li>
</ul>
</blockquote>
<p>&emsp;&emsp;从上面的分析来看，延迟主要体现在<code>sql thread</code>处理数据入库阶段。</p>
<h2 id="2、如何查看同步延迟状态？"><a href="#2、如何查看同步延迟状态？" class="headerlink" title="2、如何查看同步延迟状态？"></a>2、如何查看同步延迟状态？</h2><p>&emsp;&emsp;在从服务器上通过执行 show slave status 查看具体的参数，有几个参数比较重要：</p>
<blockquote>
<p><strong>master_log_file：slave中的IO线程正在读取的主服务器二进制日志文件的名称</strong></p>
<p> <strong>read_master_log_pos：在当前的主服务器二进制日志中，slave中的IO线程已经读取的位置</strong></p>
<p> <strong>relay_log_file：sql线程当前正在读取和执行的中继日志文件的名称</strong></p>
<p> <strong>relay_log_pos：在当前的中继日志中，sql线程已经读取和执行的位置</strong></p>
<p> <strong>relay_master_log_file：由sql线程执行的包含多数近期事件的主服务器二进制日志文件的名称</strong></p>
<p> <strong>slave_io_running：IO线程是否被启动并成功的连接到主服务器上</strong></p>
<p> <strong>slave_sql_running：sql线程是否被启动</strong></p>
<p> <strong>seconds_behind_master：从属服务器sql线程和从属服务器IO线程之间的事件差距，单位以秒计</strong></p>
</blockquote>
<p> &emsp;&emsp;在浙西参数中有一个最最重要的参数需要我们引起注意，那就是<code>seconds_behind_master</code>，这个参数就表示当前备库延迟了多长时间，那么这个值是如何计算的呢？</p>
<p> 在进行主从复制的时候，需要注意以下几个关键的时刻：</p>
<ul>
<li>主库A执行完成一个事务，写入binlog，我们把这个时刻记为T1；</li>
<li>主库A将binlog传给备库B,我们把备库B接受完这个binlog的时刻记为T2；</li>
<li>备库B执行完成这个事务，我们把这个时刻记为T3。</li>
</ul>
<p>&emsp;&emsp;所谓的主备延迟就是同一个事务，在备库执行完成的时间和主库执行完成的时间之间的差值，也就是T3-T1。SBM在进行计算的时候也是按照这样的方式，每个事务的binlog中都有一个时间字段，用于记录主库写入的时间，备库取出当前正在执行的事务的时间字段的值，计算它与当前系统时间的差值，得到SBM。</p>
<h2 id="3、主从复制产生延迟的原因"><a href="#3、主从复制产生延迟的原因" class="headerlink" title="3、主从复制产生延迟的原因"></a>3、主从复制产生延迟的原因</h2><p>&emsp;&emsp;根据上面我们的分析，我们可以来总结一下主从复制产生延迟的原因：</p>
<h3 id="3-1、服务器性能"><a href="#3-1、服务器性能" class="headerlink" title="3.1、服务器性能"></a>3.1、服务器性能</h3><p>&emsp;&emsp;在某些环境中，slave 所在的服务器性能会比 master 对应服务器的性能差。此时如果 slave 的资源不足就会影响其同步效率。</p>
<h3 id="3-2、查询压力过大"><a href="#3-2、查询压力过大" class="headerlink" title="3.2、查询压力过大"></a>3.2、查询压力过大</h3><p>&emsp;&emsp;slave 作为读库，会提供一部分读的压力。而当 slave 的查询压力过大时，会消耗大量CPU资源，这就会影响同步的速度了。</p>
<h3 id="3-3、大事务的执行"><a href="#3-3、大事务的执行" class="headerlink" title="3.3、大事务的执行"></a>3.3、大事务的执行</h3><p>&emsp;&emsp;当执行一个大事务时，如果在 master 上面执行花费了 10 分钟，而bin log需要等待事务完成后，才会传入 slave，此时 slave 开始执行时就已经延迟了 10 分钟。</p>
<h3 id="3-4、随机io"><a href="#3-4、随机io" class="headerlink" title="3.4、随机io"></a>3.4、随机io</h3><p>&emsp;&emsp;master的对于bin log的写操作是追加日志，属于顺序写，slave单线程去master顺序读bin log，slave取到bin log之后在本地执行。mysql的主从复制都是<strong>单线程</strong>的操作，但是由于master是顺序写，所以效率很高，而slave也是顺序读取master的日志，此时的效率也是比较高的，但是当数据拉取回来之后，sql thread处理数据变成了随机的操作，而不是顺序的，所以此时成本会提高。</p>
<h3 id="3-5、线程抢占"><a href="#3-5、线程抢占" class="headerlink" title="3.5、线程抢占"></a>3.5、线程抢占</h3><p>&emsp;&emsp;slave 在同步数据的同时，可能和其他查询的线程发生锁抢占的情况，此时也会发生延迟。</p>
<h3 id="3-6、其他情况"><a href="#3-6、其他情况" class="headerlink" title="3.6、其他情况"></a>3.6、其他情况</h3><p>&emsp;&emsp;当master的TPS并发非常高的时候，产生的DDL数量超过了一个线程所能承受的范围的时候，那么也可能带来延迟。</p>
<p>&emsp;&emsp;在进行bin log日志传输的时候，如果网络带宽也不是很好，那么网络延迟也可能造成数据同步延迟。</p>
<h1 id="七、如何解决复制延迟"><a href="#七、如何解决复制延迟" class="headerlink" title="七、如何解决复制延迟"></a>七、如何解决复制延迟</h1><h2 id="1、硬件方面的优化"><a href="#1、硬件方面的优化" class="headerlink" title="1、硬件方面的优化"></a>1、硬件方面的优化</h2><p>&emsp;&emsp;采用更好的服务器（CPU、SSD等），硬件强劲、延迟肯定会变小。但是，需要花费的金钱也会随之提升。</p>
<h2 id="2、架构方面的优化"><a href="#2、架构方面的优化" class="headerlink" title="2、架构方面的优化"></a>2、架构方面的优化</h2><blockquote>
<ol>
<li>业务的持久化层的实现采用分库架构，mysql服务可平行扩展，分散压力；</li>
<li>单个库达到某个数据量时执行读写分离，一主多从，主写从读，分散压力。这样从库压力比主库高，保护主库；</li>
<li>服务的基础架构在业务和mysql之间加入缓存层，可以减少mysql的读的压力。但是需要注意的是，如果数据经常要发生修改，那么这种设计是不合理的，因为需要频繁的去更新缓存中的数据，保持数据的一致性，导致缓存的命中率很低，所以此时就要慎用缓存了；</li>
<li>使用比主库更好的硬件设备作为 slave 从库，从库压力小，延迟自然会变小。</li>
</ol>
</blockquote>
<h2 id="3、从库配置的优化"><a href="#3、从库配置的优化" class="headerlink" title="3、从库配置的优化"></a>3、从库配置的优化</h2><h3 id="3-1、修改sync-binlog的参数的值"><a href="#3-1、修改sync-binlog的参数的值" class="headerlink" title="3.1、修改sync_binlog的参数的值"></a>3.1、修改sync_binlog的参数的值</h3><p>&emsp;&emsp;我们先了解一下binlog的写盘的流程：</p>
<p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210531160301862.png" alt="image-20210531160301862"></p>
<p>&emsp;&emsp;从图中可以看到，每个线程有自己的bin log cache，但是共用同一份bin log。</p>
<blockquote>
<p>图中的write，指的就是把日志写入到文件系统的page cache，并没有把数据持久化到磁盘，所以速度快；</p>
<p>图中的fsync，才是将数据持久化到磁盘的操作。一般情况下，我们认为fsync才占用磁盘的IOPS。 </p>
</blockquote>
<p>&emsp;&emsp;而write和fsync的时机就是由参数sync_binlog来进行控制的。</p>
<blockquote>
<p> 1、当sync_binlog=0的时候，表示每次提交事务都只write，不fsync</p>
<p> 2、当sync_binlog=1的时候，表示每次提交事务都执行fsync</p>
<p> 3、当sync_binlog=N的时候，表示每次提交事务都write，但积累N个事务后才fsync。</p>
</blockquote>
<p>&emsp;&emsp;一般在公司的大部分应用场景中，我们建议将此参数的值设置为1，因为这样的话能够保证数据的安全性。但是如果出现主从复制的延迟问题，可以考虑将此值设置为100~1000中的某个数值，非常不建议设置为0，因为设置为0的时候没有办法控制丢失日志的数据量，但是如果是对安全性要求比较高的业务系统，这个参数产生的意义就不是那么大了。</p>
<h3 id="3-2、禁用-slave-的bin-log"><a href="#3-2、禁用-slave-的bin-log" class="headerlink" title="3.2、禁用 slave 的bin log"></a>3.2、禁用 slave 的bin log</h3><p>&emsp;&emsp;当从库的数据在做同步的时候，有可能从库的bin log也会进行记录，此时的话肯定也会消耗io的资源，因此可以考虑将其关闭。但是需要注意，如果你搭建的集群是级联的模式的话，那么此时的bin log也会发送到另外一台从库里方便进行数据同步，此时的话，这个配置项也不会起到太大的作用。</p>
<h3 id="3-3、设置innodb-flush-log-at-trx-commit-属性"><a href="#3-3、设置innodb-flush-log-at-trx-commit-属性" class="headerlink" title="3.3、设置innodb_flush_log_at_trx_commit 属性"></a>3.3、设置innodb_flush_log_at_trx_commit 属性</h3><p>&emsp;&emsp;这个属性用来表示每一次的事务提交是否需要把日志都写入磁盘，这是很浪费时间的，一共有三个属性值，分别是0（每次写到服务缓存，一秒钟刷写一次），1（每次事务提交都刷写一次磁盘），2（每次写到os缓存，一秒钟刷写一次），一般情况下我们推荐设置成2，这样就算mysql的服务宕机了，卸载os缓存中的数据也会进行持久化。</p>
<h1 id="八、MTS解决主从复制的延迟问题"><a href="#八、MTS解决主从复制的延迟问题" class="headerlink" title="八、MTS解决主从复制的延迟问题"></a>八、MTS解决主从复制的延迟问题</h1><p>&emsp;&emsp;在mysql5.6版本之后引入了一个概念，就是我们通常说的<code>MTS</code> 【Multi Thread Slave】（并行复制），如下图：</p>
<p><img src="http://cheng_qiwei.gitee.io/blog/img/%E5%B9%B6%E8%A1%8C%E5%A4%8D%E5%88%B6.png"></p>
<p>&emsp;&emsp;通过上图我们可以发现其实所谓的<code>MTS-并行复制</code>，就是在中间添加了一个分发的环节，也就是说原来的<code>sql thread</code>变成了现在的coordinator组件，当日志来了之后，coordinator负责读取日志信息以及分发事务，真正的日志执行的过程是放在了worker线程上，由多个线程并行的去执行。</p>
<h2 id="1、MTS配置"><a href="#1、MTS配置" class="headerlink" title="1、MTS配置"></a>1、MTS配置</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-- 查看并行的slave的线程的个数，默认是0-表示单线程</span><br><span class="line">show global variables like &#x27;slave_parallel_workers&#x27;;</span><br><span class="line">-- 根据实际情况保证开启多少线程</span><br><span class="line">set global slave_parallel_workers = 4;</span><br><span class="line">-- 设置并发复制的方式，默认是一个线程处理一个库，值为database</span><br><span class="line">show global variables like &#x27;%slave_parallel_type%&#x27;;</span><br><span class="line">-- 停止slave</span><br><span class="line">stop slave;</span><br><span class="line">-- 设置属性值</span><br><span class="line">set global slave_parallel_type=&#x27;logical_check&#x27;;</span><br><span class="line">-- 开启slave</span><br><span class="line">start slave</span><br><span class="line">-- 查看线程数</span><br><span class="line">show full processlist;</span><br></pre></td></tr></table></figure>

<h2 id="2、关于并行复制的思考"><a href="#2、关于并行复制的思考" class="headerlink" title="2、关于并行复制的思考"></a>2、关于并行复制的思考</h2><p><strong>2.1、在并行操作的时候，可能会有并发的事务问题，slave在执行的时候可以按照轮询的方式发送给各个worker吗？</strong></p>
<p>&emsp;&emsp;不行。因为事务被分发给worker以后，不同的worker就开始独立执行了，但是，由于CPU的不同调度策略，很可能第二个事务最终比第一个事务先执行，而如果刚刚好他们修改的是同一行数据，那么因为执行顺序的问题，可能导致主备的数据不一致。</p>
<p><strong>2.2、同一个事物的多个更新语句，能不能分给不同的worker来执行？</strong></p>
<p>&emsp;&emsp;不行。一个事务更新了表t1和表t2中的各一行，如果这两条更新语句被分到不同worker的话，虽然最终的结果是主备一致的，但如果表t1执行完成的瞬间，备库上有一个查询，就会看到这个事务更新了一半的结果，破坏了事务逻辑的隔离性。</p>
<p>&emsp;&emsp;根据上面两个问题，我们可以总结coordinator在进行分发的时候，需要遵循的策略：</p>
<blockquote>
<p>1、不能造成更新覆盖。这就要求更新同一行的两个事务，必须被分发到同一个worker中。</p>
<p>2、同一个事务不能被拆开，必须放到同一个worker中。</p>
</blockquote>
<h2 id="3、MTS的实现原理"><a href="#3、MTS的实现原理" class="headerlink" title="3、MTS的实现原理"></a>3、MTS的实现原理</h2><p>&emsp;&emsp;正由于在分发的时候必须要满足我们上面说的两条规则，所以当我们进行分发的时候要在每一个worker上定义一个hash表，用来保存当前这个work正在执行的事务所涉及到的表。hash表的key值按照不同的粒度需要存储不同的值：</p>
<p> 按库分发：key值是数据库的名字，这个比较简单</p>
<p> 按表分发：key值是库名+表名</p>
<p> 按行分发：key值是库名+表名+唯一键</p>
<p>&emsp;&emsp;接下来，我们来看看各个版本的MYS是如何实现的。</p>
<h3 id="3-1、MySQL-5-6-版本的并行复制策略"><a href="#3-1、MySQL-5-6-版本的并行复制策略" class="headerlink" title="3.1、MySQL 5.6 版本的并行复制策略"></a>3.1、MySQL 5.6 版本的并行复制策略</h3><p>&emsp;&emsp;MySQL在5.6版本开始就已经支持了并行复制，只是支持的粒度是按库并行。这也是为什么现在的版本中可以选择类型为database。</p>
<p>&emsp;&emsp;而这个策略的并行效果，取决于压力模型。如果在主库上有多个DB，并且各个DB的压力均衡，使用这个策略的效果会很好，但是如果主库的所有表都放在同一DB上，那么所有的操作都会分发给一个worker，变成单线程操作了，那么这个策略的效果就不好了，因此在实际的生产环境中，用的并不是特别多。</p>
<h3 id="3-2、MariaDB的并行复制策略"><a href="#3-2、MariaDB的并行复制策略" class="headerlink" title="3.2、MariaDB的并行复制策略"></a>3.2、MariaDB的并行复制策略</h3><p>&emsp;&emsp;MariaDB的并行复制策略是：</p>
<blockquote>
<p> 1、能够在同一组里提交的事务，一定不会修改同一行；</p>
<p> 2、master上可以并行执行的事务，slave上也一定是可以并行执行的。</p>
</blockquote>
<p> &emsp;&emsp;在实现上，mariaDB是这么做的：</p>
<blockquote>
<p>1、在一组里面一起提交的事务，有一个相同的commit_id,下一组就是commit_id+1;</p>
<p> 2、commit_id直接写到binlog里面；</p>
<p> 3、传到slave应用的时候，相同commit_id的事务会分发到多个worker执行；</p>
<p> 4、这一组全部执行完成后，coordinator再去取下一批。</p>
</blockquote>
<p>&emsp;&emsp;这是mariaDB的并行复制策略，大体上看起来是没有问题的，但是你仔细观察的话会发现他并没有实现“真正的模拟主库并发度”这个目标，在主库上，一组事务在commit的时候，下一组事务是同时处于“执行中”状态的。</p>
<p>&emsp;&emsp;我们真正想要达到的并行复制应该是如下图1的状态，也就是说当第一组事务提交的是，下一组事务是运行的状态，当第一组事务提交完成之后，下一组事务会立刻变成commit状态。 但是按照mariaDB的并行复制策略，那么备库上的执行状态会变成如下图2。</p>
<p>&emsp;&emsp;可以看到，图2跟上面图1的最大区别在于，slave上执行的时候必须要等第一组事务执行完成之后，第二组事务才能开始执行，这样系统的吞吐量就不够了。而且这个方案很容易被大事务拖后腿，如果trx2是一个大事务，那么在备库应用的时候，trx1和trx3执行完成之后，就只能等trx2完全执行完成，下一组才能开始执行，这段时间，只有一个worker线程在工作，是对资源的浪费。</p>
<p><img src="http://cheng_qiwei.gitee.io/blog/img/mariaDB1.png" alt="mariaDB1"></p>
<p><img src="http://cheng_qiwei.gitee.io/blog/img/mariaDB2.png" alt="mariaDB2"></p>
<h3 id="3-3、MySQL-5-7-的并行复制策略"><a href="#3-3、MySQL-5-7-的并行复制策略" class="headerlink" title="3.3、MySQL 5.7 的并行复制策略"></a>3.3、MySQL 5.7 的并行复制策略</h3><p>&emsp;&emsp;在MySQL5.7版本，它的并行复制策略是根据mariaDB的并行复制策略，做了相应的优化调整后，提供了自己的并行复制策略，并且可以通过参数slave-parallel-type来控制并行复制的策略：</p>
<blockquote>
<p>1、当配置的值为DATABASE的时候，表示使用5.6版本的按库并行策略；</p>
<p> 2、当配置的值为LOGICAL_CLOCK的时候，表示使用跟MariaDB相同的策略。</p>
</blockquote>
<p>此时，大家需要思考一个问题：<strong>同时处于执行状态的所有事务，是否可以并行？</strong></p>
<p>答案：不行，因为多个执行中的事务是有可能出现锁冲突的，锁冲突之后就会产生锁等待问题。在mariaDB中，所有处于commit状态的事务是可以并行，因为如果能commit的话就说明已经没有锁的问题，但是大家回想下，我们mysql的日志提交是两阶段提交，如下图，其实只要处于prepare状态就已经表示没有锁的问题了。</p>
<p>&emsp;&emsp;在MySQL5.7的时候采用的是基于组提交的并行复制，换句话说，slave服务器的回放与主机是一致的，即主库是如何并行执行的那么slave就如何怎样进行并行回放，这点其实是参考了mariaDB的并行复制。</p>
<p><img src="http://cheng_qiwei.gitee.io/blog/img/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4.png"></p>
<p>总结：MySQL5.7的并行复制策略的思想是：</p>
<p>1、同时处于prepare状态的事务，在slave执行是可以并行的；</p>
<p>2、处于prepare状态的事务，与处于commit状态的事务之间，在slave上执行也是可以并行的。</p>
<p>基于这样的处理机制，我们可以将大部分的日志处于prepare状态，因此可以设置：</p>
<p>1、binlog_group_commit_sync_delay 参数，表示延迟多少微秒后才调用 fsync；</p>
<p>2、binlog_group_commit_sync_no_delay_count 参数，表示累积多少次以后才调用 fsync。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">WinKing</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://cheng_qiwei.gitee.io/blog/2021/05/21/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/">http://cheng_qiwei.gitee.io/blog/2021/05/21/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://cheng_qiwei.gitee.io/blog" target="_blank">WinKings Blogs</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/blog/tags/MySQL/">MySQL</a><a class="post-meta__tags" href="/blog/tags/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/">主从复制</a></div><div class="post_share"><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=null" async="async"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/blog/2021/06/01/MyCat/"><img class="prev-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/blog/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MyCat</div></div></a></div><div class="next-post pull-right"><a href="/blog/2021/05/15/MySQL%E9%94%81%E4%B8%8E%E6%97%A5%E5%BF%97/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/blog/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MySQL锁与日志</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/blog/2021/05/15/MySQL锁与日志/" title="MySQL锁与日志"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-15</div><div class="title">MySQL锁与日志</div></div></a></div><div><a href="/blog/2021/05/10/MySQL原理与优化/" title="MySQL原理与优化"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-10</div><div class="title">MySQL原理与优化</div></div></a></div></div></div></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" src="/blog/img/touxiang.jpg" onerror="this.onerror=null;this.src='/blog/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">WinKing</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/blog/archives/"><div class="headline">文章</div><div class="length-num">20</div></a></div><div class="card-info-data-item is-center"><a href="/blog/tags/"><div class="headline">标签</div><div class="length-num">39</div></a></div><div class="card-info-data-item is-center"><a href="/blog/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://gitee.com/cheng_qiwei"><i class="fab fa-gitee"></i><span>Follow Me</span></a></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-text">MySQL主从复制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%81%9A%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%EF%BC%9F"><span class="toc-text">一、为什么要做主从复制？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">二、主从复制的原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%93%8D%E4%BD%9C"><span class="toc-text">三、主从复制操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-text">1、修改配置文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1%E3%80%81%E4%BF%9D%E8%AF%81%E4%B8%A4%E9%83%A8%E6%9C%BA%E5%99%A8%E8%83%BD%E5%A4%9Fping%E9%80%9A"><span class="toc-text">1.1、保证两部机器能够ping通</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2%E3%80%81%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-text">1.2、修改配置文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1%E3%80%81%E4%BF%AE%E6%94%B9master%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6vi-etc-my-cnf"><span class="toc-text">1.2.1、修改master配置文件vi &#x2F;etc&#x2F;my.cnf</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2%E3%80%81%E4%BF%AE%E6%94%B9slave%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6vi-etc-my-cnf"><span class="toc-text">1.2.2、修改slave配置文件vi &#x2F;etc&#x2F;my.cnf</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E6%8E%88%E6%9D%83%E8%B4%A6%E6%88%B7"><span class="toc-text">2、授权账户</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E6%9F%A5%E7%9C%8B%E4%B8%BB%E6%9C%BA%E7%8A%B6%E6%80%81"><span class="toc-text">3、查看主机状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E6%89%A7%E8%A1%8C%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-text">4、执行主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1%E3%80%81slave%E6%89%A7%E8%A1%8C%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%91%BD%E4%BB%A4"><span class="toc-text">4.1、slave执行主从复制命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2%E3%80%81%E6%9F%A5%E7%9C%8B%E4%BB%8E%E6%9C%BA%E7%8A%B6%E6%80%81"><span class="toc-text">4.2、查看从机状态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E6%B5%8B%E8%AF%95%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-text">5、测试主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1%E3%80%81%E6%B5%8B%E8%AF%95%E5%BB%BA%E5%BA%93"><span class="toc-text">5.1、测试建库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2%E3%80%81%E6%B5%8B%E8%AF%95%E5%BB%BA%E8%A1%A8"><span class="toc-text">5.2、测试建表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3%E3%80%81%E6%B5%8B%E8%AF%95%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-text">5.3、测试插入数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4%E3%80%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">5.4、注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%8F%8C%E4%B8%BB%E5%8F%8C%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-text">四、双主双从复制的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-1"><span class="toc-text">1、修改配置文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1%E3%80%81%E4%BF%9D%E8%AF%81%E5%9B%9B%E9%83%A8%E6%9C%BA%E5%99%A8%E8%83%BD%E5%A4%9Fping%E9%80%9A"><span class="toc-text">1.1、保证四部机器能够ping通</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2%E3%80%81%E5%81%9C%E6%AD%A2%E5%8E%9F%E6%9D%A5%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-text">1.2、停止原来的主从复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3%E3%80%81%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-text">1.3、修改配置文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1%E3%80%81Master1-%E4%B8%BB%E6%9C%BA-%E9%85%8D%E7%BD%AE"><span class="toc-text">1.3.1、Master1[主机]配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2%E3%80%81Master2-%E5%A4%87%E6%9C%BA-%E9%85%8D%E7%BD%AE"><span class="toc-text">1.3.2、Master2[备机]配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-3%E3%80%81Slave1-%E4%B8%BB%E6%9C%BA%E4%BB%8E%E6%9C%BA-%E9%85%8D%E7%BD%AE"><span class="toc-text">1.3.3、Slave1[主机从机]配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-4%E3%80%81Slave2-%E5%A4%87%E6%9C%BA%E4%BB%8E%E6%9C%BA-%E9%85%8D%E7%BD%AE"><span class="toc-text">1.3.4、Slave2[备机从机]配置</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E6%8E%88%E6%9D%83%E8%B4%A6%E6%88%B7-1"><span class="toc-text">2、授权账户</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%E3%80%81%E8%8E%B7%E5%8F%96%E4%B8%BB%E6%9C%BA%E4%BF%A1%E6%81%AF"><span class="toc-text">2.1、获取主机信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%E3%80%81%E6%8E%88%E6%9D%83%E4%BB%8E%E6%9C%BA"><span class="toc-text">2.2、授权从机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3%E3%80%81%E5%8F%8C%E4%B8%BB%E6%9C%BA%E7%9B%B8%E4%BA%92%E6%8E%88%E6%9D%83"><span class="toc-text">2.3、双主机相互授权</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E6%B5%8B%E8%AF%95%E5%8F%8C%E4%B8%BB%E5%8F%8C%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-text">3、测试双主双从复制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E5%A4%8D%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-text">五、MySQL主从复制的复制方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%9F%BA%E4%BA%8ESQL%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%A4%8D%E5%88%B6-SBR"><span class="toc-text">1、基于SQL语句的复制 SBR</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1%E3%80%81SBR%E6%96%B9%E5%BC%8F%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-text">1.1、SBR方式的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2%E3%80%81SBR%E6%96%B9%E5%BC%8F%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-text">1.2、SBR方式的缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%9F%BA%E4%BA%8E%E8%A1%8C%E7%9A%84%E5%A4%8D%E5%88%B6-RBR"><span class="toc-text">2、基于行的复制 RBR</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%E3%80%81RBR%E6%96%B9%E5%BC%8F%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-text">2.1、RBR方式的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%E3%80%81RBR%E6%96%B9%E5%BC%8F%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-text">2.2、RBR方式的缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%A4%8D%E5%88%B6-MBR"><span class="toc-text">3、混合模式的复制 MBR</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%85%A8%E5%B1%80%E4%BA%8B%E5%8A%A1%E6%A0%87%E8%AF%86%E7%AC%A6-GTID"><span class="toc-text">4、全局事务标识符 GTID</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1%E3%80%81GTID%E6%96%B9%E5%BC%8F%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-text">4.1、GTID方式的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2%E3%80%81GTID%E6%96%B9%E5%BC%8F%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-text">4.2、GTID方式的缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E5%BB%B6%E8%BF%9F%E9%97%AE%E9%A2%98"><span class="toc-text">六、MySQL主从复制的延迟问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0%E5%BB%B6%E8%BF%9F%EF%BC%9F"><span class="toc-text">1、为什么会出现延迟？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E5%90%8C%E6%AD%A5%E5%BB%B6%E8%BF%9F%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="toc-text">2、如何查看同步延迟状态？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%BA%A7%E7%94%9F%E5%BB%B6%E8%BF%9F%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-text">3、主从复制产生延迟的原因</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD"><span class="toc-text">3.1、服务器性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2%E3%80%81%E6%9F%A5%E8%AF%A2%E5%8E%8B%E5%8A%9B%E8%BF%87%E5%A4%A7"><span class="toc-text">3.2、查询压力过大</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3%E3%80%81%E5%A4%A7%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%89%A7%E8%A1%8C"><span class="toc-text">3.3、大事务的执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4%E3%80%81%E9%9A%8F%E6%9C%BAio"><span class="toc-text">3.4、随机io</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5%E3%80%81%E7%BA%BF%E7%A8%8B%E6%8A%A2%E5%8D%A0"><span class="toc-text">3.5、线程抢占</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6%E3%80%81%E5%85%B6%E4%BB%96%E6%83%85%E5%86%B5"><span class="toc-text">3.6、其他情况</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%A4%8D%E5%88%B6%E5%BB%B6%E8%BF%9F"><span class="toc-text">七、如何解决复制延迟</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E7%A1%AC%E4%BB%B6%E6%96%B9%E9%9D%A2%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-text">1、硬件方面的优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E6%9E%B6%E6%9E%84%E6%96%B9%E9%9D%A2%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-text">2、架构方面的优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E4%BB%8E%E5%BA%93%E9%85%8D%E7%BD%AE%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-text">3、从库配置的优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E3%80%81%E4%BF%AE%E6%94%B9sync-binlog%E7%9A%84%E5%8F%82%E6%95%B0%E7%9A%84%E5%80%BC"><span class="toc-text">3.1、修改sync_binlog的参数的值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2%E3%80%81%E7%A6%81%E7%94%A8-slave-%E7%9A%84bin-log"><span class="toc-text">3.2、禁用 slave 的bin log</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3%E3%80%81%E8%AE%BE%E7%BD%AEinnodb-flush-log-at-trx-commit-%E5%B1%9E%E6%80%A7"><span class="toc-text">3.3、设置innodb_flush_log_at_trx_commit 属性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E3%80%81MTS%E8%A7%A3%E5%86%B3%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E5%BB%B6%E8%BF%9F%E9%97%AE%E9%A2%98"><span class="toc-text">八、MTS解决主从复制的延迟问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81MTS%E9%85%8D%E7%BD%AE"><span class="toc-text">1、MTS配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%85%B3%E4%BA%8E%E5%B9%B6%E8%A1%8C%E5%A4%8D%E5%88%B6%E7%9A%84%E6%80%9D%E8%80%83"><span class="toc-text">2、关于并行复制的思考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81MTS%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">3、MTS的实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E3%80%81MySQL-5-6-%E7%89%88%E6%9C%AC%E7%9A%84%E5%B9%B6%E8%A1%8C%E5%A4%8D%E5%88%B6%E7%AD%96%E7%95%A5"><span class="toc-text">3.1、MySQL 5.6 版本的并行复制策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2%E3%80%81MariaDB%E7%9A%84%E5%B9%B6%E8%A1%8C%E5%A4%8D%E5%88%B6%E7%AD%96%E7%95%A5"><span class="toc-text">3.2、MariaDB的并行复制策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3%E3%80%81MySQL-5-7-%E7%9A%84%E5%B9%B6%E8%A1%8C%E5%A4%8D%E5%88%B6%E7%AD%96%E7%95%A5"><span class="toc-text">3.3、MySQL 5.7 的并行复制策略</span></a></li></ol></li></ol></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/blog/2021/06/01/MyCat/" title="MyCat"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="MyCat"/></a><div class="content"><a class="title" href="/blog/2021/06/01/MyCat/" title="MyCat">MyCat</a><time datetime="2021-06-01T14:00:00.000Z" title="发表于 2021-06-01 22:00:00">2021-06-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2021/05/21/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/" title="MySQL主从复制"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="MySQL主从复制"/></a><div class="content"><a class="title" href="/blog/2021/05/21/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/" title="MySQL主从复制">MySQL主从复制</a><time datetime="2021-05-21T14:00:00.000Z" title="发表于 2021-05-21 22:00:00">2021-05-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2021/05/15/MySQL%E9%94%81%E4%B8%8E%E6%97%A5%E5%BF%97/" title="MySQL锁与日志"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="MySQL锁与日志"/></a><div class="content"><a class="title" href="/blog/2021/05/15/MySQL%E9%94%81%E4%B8%8E%E6%97%A5%E5%BF%97/" title="MySQL锁与日志">MySQL锁与日志</a><time datetime="2021-05-15T14:00:00.000Z" title="发表于 2021-05-15 22:00:00">2021-05-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2021/05/10/MySQL%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BC%98%E5%8C%96/" title="MySQL原理与优化"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="MySQL原理与优化"/></a><div class="content"><a class="title" href="/blog/2021/05/10/MySQL%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BC%98%E5%8C%96/" title="MySQL原理与优化">MySQL原理与优化</a><time datetime="2021-05-10T14:00:00.000Z" title="发表于 2021-05-10 22:00:00">2021-05-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2021/05/04/JUC%EF%BC%88%E4%B8%8B%EF%BC%89/" title="JUC（下）"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="JUC（下）"/></a><div class="content"><a class="title" href="/blog/2021/05/04/JUC%EF%BC%88%E4%B8%8B%EF%BC%89/" title="JUC（下）">JUC（下）</a><time datetime="2021-05-04T14:00:00.000Z" title="发表于 2021-05-04 22:00:00">2021-05-04</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By WinKing</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/blog/js/utils.js"></script><script src="/blog/js/main.js"></script><script src="/blog/js/tw_cn.js"></script><script src="/blog/js/search/local-search.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script></div></body></html>