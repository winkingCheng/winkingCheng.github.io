<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Redis介绍与命令 | WinKings Blogs</title><meta name="keywords" content="安装,Redis,命令"><meta name="author" content="WinKing"><meta name="copyright" content="WinKing"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="Redis介绍与命令一、NoSQL简介1、什么是NoSQL&amp;emsp;&amp;emsp;NoSQL(NoSQL &#x3D; Not Only SQL)，意即“不仅仅是SQL”，泛指非关系型的数据库。随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis介绍与命令">
<meta property="og:url" content="http://cheng_qiwei.gitee.io/blog/2021/06/07/Redis%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%91%BD%E4%BB%A4/index.html">
<meta property="og:site_name" content="WinKings Blogs">
<meta property="og:description" content="Redis介绍与命令一、NoSQL简介1、什么是NoSQL&amp;emsp;&amp;emsp;NoSQL(NoSQL &#x3D; Not Only SQL)，意即“不仅仅是SQL”，泛指非关系型的数据库。随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2021-06-07T14:00:00.000Z">
<meta property="article:modified_time" content="2021-07-20T15:18:16.592Z">
<meta property="article:author" content="WinKing">
<meta property="article:tag" content="安装">
<meta property="article:tag" content="Redis">
<meta property="article:tag" content="命令">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/blog/img/favicon.png"><link rel="canonical" href="http://cheng_qiwei.gitee.io/blog/2021/06/07/Redis%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%91%BD%E4%BB%A4/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/blog/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/blog/WinKings%20Blogs" media="print" onload="this.media='all'"><script>var GLOBAL_CONFIG = { 
  root: '/blog/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}

// https://stackoverflow.com/questions/16839698/jquery-getscript-alternative-in-native-javascript
const getScript = url => new Promise((resolve, reject) => {
  const script = document.createElement('script')
  script.src = url
  script.async = true
  script.onerror = reject
  script.onload = script.onreadystatechange = function() {
    const loadState = this.readyState
    if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
    script.onload = script.onreadystatechange = null
    resolve()
  }
  document.head.appendChild(script)
})</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-07-20 23:18:16'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/blog/img/touxiang.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/blog/archives/"><div class="headline">文章</div><div class="length-num">25</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/blog/tags/"><div class="headline">标签</div><div class="length-num">48</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/blog/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/blog/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/blog/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/blog/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/blog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/blog/">WinKings Blogs</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/blog/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/blog/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/blog/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/blog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Redis介绍与命令</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-06-07T14:00:00.000Z" title="发表于 2021-06-07 22:00:00">2021-06-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-07-20T15:18:16.592Z" title="更新于 2021-07-20 23:18:16">2021-07-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/blog/categories/Redis/">Redis</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Redis介绍与命令"><a href="#Redis介绍与命令" class="headerlink" title="Redis介绍与命令"></a>Redis介绍与命令</h1><h1 id="一、NoSQL简介"><a href="#一、NoSQL简介" class="headerlink" title="一、NoSQL简介"></a>一、NoSQL简介</h1><h2 id="1、什么是NoSQL"><a href="#1、什么是NoSQL" class="headerlink" title="1、什么是NoSQL"></a>1、什么是NoSQL</h2><p>&emsp;&emsp;NoSQL(<strong>NoSQL = Not Only SQL</strong>)，意即“不仅仅是SQL”，泛指非关系型的数据库。随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL 数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题，包括超大规模数据的存储。</p>
<h2 id="2、为什么需要NoSQL"><a href="#2、为什么需要NoSQL" class="headerlink" title="2、为什么需要NoSQL"></a>2、为什么需要NoSQL</h2><h3 id="2-1、易扩展"><a href="#2-1、易扩展" class="headerlink" title="2.1、易扩展"></a>2.1、易扩展</h3><p>&emsp;&emsp;NoSQL数据库种类繁多，但是一个共同的特点都是去掉关系数据库的关系型特性。数据之间无关系，这样就非常容易扩展。也无形之间，在架构的层面上带来了可扩展的能力。</p>
<h3 id="2-2、大数据量高性能"><a href="#2-2、大数据量高性能" class="headerlink" title="2.2、大数据量高性能"></a>2.2、大数据量高性能</h3><p>&emsp;&emsp;NoSQL数据库都具有非常高的读写性能，尤其在大数据量下，同样表现优秀。这得益于它的无关系性，数据库的结构简单。</p>
<p>&emsp;&emsp;一般MySQL使用Query Cache，每次表的更新Cache就失效，是一种大粒度的Cache，在针对web2.0的交互频繁的应用，Cache性能不高。而NoSQL的Cache是记录级的，是一种细粒度的Cache，所以NoSQL在这个层面上来说就要性能高很多了。</p>
<h3 id="2-3、多样灵活的数据模型"><a href="#2-3、多样灵活的数据模型" class="headerlink" title="2.3、多样灵活的数据模型"></a>2.3、多样灵活的数据模型</h3><p>&emsp;&emsp;NoSQL无需事先为要存储的数据建立字段，随时可以存储自定义的数据格式。而在关系数据库里，增删字段是一件非常麻烦的事情。如果是非常大数据量的表，增加字段简直就是一个噩梦。</p>
<h2 id="3、NoSQL数据库的四大分类"><a href="#3、NoSQL数据库的四大分类" class="headerlink" title="3、NoSQL数据库的四大分类"></a>3、NoSQL数据库的四大分类</h2><h3 id="3-1、KV键值对"><a href="#3-1、KV键值对" class="headerlink" title="3.1、KV键值对"></a>3.1、KV键值对</h3><p>&emsp;&emsp;使用KV键值对的NoSQL有：Redis、memcache 、BerkeleyDB 等，各大公司使用KV键值对的NoSQL软件如下：</p>
<blockquote>
<p>新浪：BerkeleyDB + Redis<br>美团：Redis + tair<br>阿里、百度：memcache + Redis</p>
</blockquote>
<h3 id="3-2、文档型数据库"><a href="#3-2、文档型数据库" class="headerlink" title="3.2、文档型数据库"></a>3.2、文档型数据库</h3><p>&emsp;&emsp;文档型数据库一般使用<strong>bson格式</strong>比较多。使用文档型数据库的NoSQL有：CouchDB、MongoDB等。</p>
<h3 id="3-3、列存储数据库"><a href="#3-3、列存储数据库" class="headerlink" title="3.3、列存储数据库"></a>3.3、列存储数据库</h3><p>&emsp;&emsp;使用列存储数据库的NoSQL有：Cassandra、HBase等。</p>
<h3 id="3-4、图关系数据库"><a href="#3-4、图关系数据库" class="headerlink" title="3.4、图关系数据库"></a>3.4、图关系数据库</h3><p>&emsp;&emsp;它不是放图形的、放的是关系比如：朋友圈社交网络、广告推荐系统、社交网络、推荐系统。专注于构建关系图谱。使用图关系数据库的NoSQL有：Neo4j、InfoGrid等。</p>
<p><strong>NoSQL数据库四大分类对比如下：</strong></p>
<p><img src="http://cheng_qiwei.gitee.io/blog/img/2021022516092576.png" alt="2021022516092576"></p>
<h1 id="二、Redis安装"><a href="#二、Redis安装" class="headerlink" title="二、Redis安装"></a>二、Redis安装</h1><p>&emsp;&emsp;Redis:REmote DIctionary Server(远程字典服务)。是由意大利人Salvatore Sanfilippo（网名：antirez）开发的一款内存高速<strong>缓存</strong>数据库。是完全开源免费的，用<strong>C语言</strong>编写的，遵守BSD协议，高性能的(<strong>key/value</strong>)<strong>分布式内存数据库</strong>，基于内存运行并支持<strong>持久化</strong>的<strong>NoSQL</strong>数据库。</p>
<h2 id="1、Redis官方地址"><a href="#1、Redis官方地址" class="headerlink" title="1、Redis官方地址"></a>1、Redis官方地址</h2><p>官方地址：<a target="_blank" rel="noopener" href="https://redis.io/">https://redis.io/</a></p>
<p>中文网地址：<a target="_blank" rel="noopener" href="http://www.redis.cn/">http://www.redis.cn/</a></p>
<p>Github地址：<a target="_blank" rel="noopener" href="https://github.com/http://cheng_qiwei.gitee.io/blog/img/redis">https://github.com/http://cheng_qiwei.gitee.io/blog/img/redis</a></p>
<h2 id="2、下载安装包"><a href="#2、下载安装包" class="headerlink" title="2、下载安装包"></a>2、下载安装包</h2><p>&emsp;&emsp;本次使用的是Redis 6.2.4版本，进入官方地址后下载对应安装包即可。</p>
<p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210614180221234.png" alt="image-20210614180221234"></p>
<p>&emsp;&emsp;Linux环境直接执行以下命令即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://download.redis.io/releases/redis-6.2.4.tar.gz</span><br></pre></td></tr></table></figure>

<h2 id="3、安装Redis"><a href="#3、安装Redis" class="headerlink" title="3、安装Redis"></a>3、安装Redis</h2><h3 id="3-1、解压Redis"><a href="#3-1、解压Redis" class="headerlink" title="3.1、解压Redis"></a>3.1、解压Redis</h3><p>&emsp;&emsp;将Redis解压到安装目录<code>/usr/local</code>上</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxf redis-6.2.4.tar.gz -C /usr/<span class="built_in">local</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2、编译安装"><a href="#3-2、编译安装" class="headerlink" title="3.2、编译安装"></a>3.2、编译安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> redis-6.2.4 &amp;&amp; make</span><br><span class="line"></span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210614181636058.png" alt="image-20210614181636058"></p>
<p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210614181806842.png" alt="image-20210614181806842"></p>
<blockquote>
<p>安装完成后进入bin目录下，可以看到以下内容</p>
<ol>
<li>redis-benchmark redis性能测试工具</li>
<li>redis-check-aof AOF文件修复工具</li>
<li>redis-check-rdb RDB文件修复工具</li>
<li>redis-cli redis命令行客户端</li>
<li>redis.conf redis配置文件</li>
<li>redis-sentinal redis集群管理工具</li>
<li>redis-server redis服务进程</li>
</ol>
</blockquote>
<h3 id="3-3、启动Redis"><a href="#3-3、启动Redis" class="headerlink" title="3.3、启动Redis"></a>3.3、启动Redis</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/redis &amp;&amp; ./bin/redis-server ./redis.conf</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;按照正常情况下，以下命令即可启动redis，但是你会发现启动完成后你的窗口就不能做其他工作了，所以需要配置后台启动。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拷贝配置文件</span></span><br><span class="line">cp /usr/<span class="built_in">local</span>/redis-6.2.4/redis.conf /usr/<span class="built_in">local</span>/bin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改配置文件</span></span><br><span class="line">vim /usr/<span class="built_in">local</span>/bin/redis.conf</span><br><span class="line">...</span><br><span class="line">daemonize yes</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动redis</span></span><br><span class="line">/usr/<span class="built_in">local</span>/bin/redis-server /usr/<span class="built_in">local</span>/bin/redis.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看启动情况</span></span><br><span class="line">ps -ef | grep redis</span><br><span class="line">losf -i:6379</span><br></pre></td></tr></table></figure>

<p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210614191126800.png" alt="image-20210614191126800"></p>
<p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210614191702361.png" alt="image-20210614191702361"></p>
<h3 id="3-4、连接Redis"><a href="#3-4、连接Redis" class="headerlink" title="3.4、连接Redis"></a>3.4、连接Redis</h3><p>&emsp;&emsp;我们可以使用Redis自带的客户端redis-cli redis命令行客户端进行连接。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 6379</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入ping测试是否连接成功，返回pong为成功</span></span><br><span class="line">ping</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在启动命令中添加 --raw 可以使中文不乱码</span></span><br><span class="line">redis-cli -p 6379 --raw</span><br></pre></td></tr></table></figure>

<p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210614192656994.png" alt="image-20210614192656994"></p>
<h3 id="3-5、关闭Redis"><a href="#3-5、关闭Redis" class="headerlink" title="3.5、关闭Redis"></a>3.5、关闭Redis</h3><p>&emsp;&emsp;redis-cli shutdown：安全关闭，如果有密码需要加上 -a {password} 参数（<strong>推荐使用</strong>此方式关闭，会进行持久化文件生成，能够防止数据丢失）。</p>
<h1 id="三、Redis命令"><a href="#三、Redis命令" class="headerlink" title="三、Redis命令"></a>三、Redis命令</h1><h2 id="1、通用命令"><a href="#1、通用命令" class="headerlink" title="1、通用命令"></a>1、通用命令</h2><table>
<thead>
<tr>
<th align="left">命令</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">DEL key</td>
<td align="center">当 key 存在时删除 key</td>
</tr>
<tr>
<td align="left">FLUSHDB</td>
<td align="center">清除当前数据库数据</td>
</tr>
<tr>
<td align="left">FLUSHALL</td>
<td align="center">清除所有数据库数据</td>
</tr>
<tr>
<td align="left">SCAN cursor</td>
<td align="center">游标扫描匹配的key</td>
</tr>
<tr>
<td align="left">KEYS  pattern</td>
<td align="center">查找所有符合匹配模式 pattern 的 key</td>
</tr>
<tr>
<td align="left">DBSIZE</td>
<td align="center">返回当前数据库的 key 的数量</td>
</tr>
<tr>
<td align="left">SELECT dbnum</td>
<td align="center">切换数据库</td>
</tr>
<tr>
<td align="left">EXISTS key</td>
<td align="center">检查给定 key 是否存在</td>
</tr>
<tr>
<td align="left">TYPE key</td>
<td align="center">返回 key 所储存的值的类型</td>
</tr>
<tr>
<td align="left">MOVE key db</td>
<td align="center">将当前数据库的 key 移动到给定的数据库 db 当中</td>
</tr>
<tr>
<td align="left">RANDOMKEY</td>
<td align="center">从当前数据库中随机返回一个 key</td>
</tr>
<tr>
<td align="left">RENAME key newkey</td>
<td align="center">修改 key 的名称</td>
</tr>
<tr>
<td align="left">RENAMENX key newkey</td>
<td align="center">仅当 newkey 不存在时，将 key 改名为 newkey</td>
</tr>
<tr>
<td align="left">OBJECT encoding key</td>
<td align="center">查看键对应值的类型（int raw等等）</td>
</tr>
</tbody></table>
<p><strong>过期时间相关命令</strong></p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">EXPIRE key seconds</td>
<td align="center">为给定 key 设置过期时间，单位：秒</td>
</tr>
<tr>
<td align="left">EXPIREAT key timestamp</td>
<td align="center">为给定 key 设置过期时间，单位： UNIX 时间戳(unix timestamp)。</td>
</tr>
<tr>
<td align="left">PEXPIRE key milliseconds</td>
<td align="center">为给定 key 设置过期时间，单位：毫秒</td>
</tr>
<tr>
<td align="left">PEXPIREAT key milliseconds-timestamp</td>
<td align="center">设置 key 过期时间的时间戳(unix timestamp) 以毫秒计</td>
</tr>
<tr>
<td align="left">PTTL key</td>
<td align="center">以毫秒为单位，返回 key 的剩余的过期时间</td>
</tr>
<tr>
<td align="left">TTL key</td>
<td align="center">以秒为单位，返回给定 key 的剩余生存时间</td>
</tr>
<tr>
<td align="left">PERSIST key</td>
<td align="center">移除 key 的过期时间，key 将持久保持</td>
</tr>
</tbody></table>
<h2 id="2、string命令"><a href="#2、string命令" class="headerlink" title="2、string命令"></a>2、string命令</h2><p>&emsp;&emsp;string是redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。string类型是Redis最基本的数据类型，<strong>一个redis中字符串value最多可以是512M</strong>。</p>
<h3 id="2-1、Redis字符串类型键的设置和查询"><a href="#2-1、Redis字符串类型键的设置和查询" class="headerlink" title="2.1、Redis字符串类型键的设置和查询"></a>2.1、Redis字符串类型键的设置和查询</h3><blockquote>
<p>参考案例：</p>
<p>案例一：高速缓存（HTML / DATA / SESSION）</p>
<p>案例二：分布式锁</p>
<p>案例三：防止重复提交</p>
<p>案例四：存储设置固定格式的字符串序列（例如：时间序列）</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th>描述</th>
<th>参数解析</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SET key value [EX seconds] [PX milliseconds] [NX|XX]</td>
<td>设置指定 key 的值，如果 key 已经持有其他值， SET 就覆写旧值， 无视类型</td>
<td><strong>EX seconds</strong> ： 将键的过期时间设置为 seconds 秒。 执行 SET key value EX seconds 的效果等同于执行 SETEX key seconds value 。            <br/><strong>PX milliseconds</strong> ： 将键的过期时间设置为 milliseconds 毫秒。 执行 SET key value PX milliseconds 的效果等同于执行 PSETEX key milliseconds value 。<br/><strong>NX **： 只在键不存在时， 才对键进行设置操作。 执行 SET key value NX 的效果等同于执行 SETNX key value 。<br/>**XX</strong> ： 只在键已经存在时， 才对键进行设置操作。</td>
</tr>
<tr>
<td align="left">MSET key value [ key value … ]</td>
<td>同时设置一个或多个 key-value 对</td>
<td>成功返回OK。</td>
</tr>
<tr>
<td align="left">SETEX key seconds value</td>
<td>将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位)</td>
<td>如果键 key 已经存在， 那么 SETEX 命令将覆盖已有的值。<br/>SETEX 和SET EXPIRE这两个命令的不同之处在于 SETEX 是一个原子（atomic）操作， 它可以在同一时间内完成设置值和设置过期时间这两个操作， 因此 SETEX 命令在储存缓存的时候非常实用。</td>
</tr>
<tr>
<td align="left">PSETEX key milliseconds value</td>
<td>将值 value 关联到 key ，并将 key 的过期时间设为 milliseconds (以毫秒为单位)</td>
<td>这个命令和 SETEX 命令功能相同，但它以毫秒为单位设置 key 的生存时间。</td>
</tr>
<tr>
<td align="left">SETNX key value</td>
<td>只有在 key 不存在时设置 key 的值为value</td>
<td>若键 key 已经存在， 则 SETNX 命令不做任何动作。设置成功时返回 1 ， 设置失败时返回 0 。</td>
</tr>
<tr>
<td align="left">MSETNX key value [key value …]</td>
<td>同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在</td>
<td>同时设置多个key，如果其中一个key存在则设置失败，不考虑其他键是否存在。 msetnx 是原子的，所有键会同时设置成功或者失败。</td>
</tr>
<tr>
<td align="left">SETRANGE key offset value</td>
<td>用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始。</td>
<td>不存在的键 key 当作空白字符串处理。<br/>SETRANGE 命令会确保字符串足够长以便将 value 设置到指定的偏移量上， 如果键 key 原来储存的字符串长度比偏移量小(比如字符串只有 5 个字符长，但你设置的 offset 是 10 )， 那么原字符和偏移量之间的空白将用零字节(zerobytes, “\x00” )进行填充。<br/>因为 Redis 字符串的大小被限制在 512 兆(megabytes)以内， 所以用户能够使用的最大偏移量为 2^29-1(536870911) ， 如果你需要使用比这更大的空间， 请使用多个 key 。</td>
</tr>
<tr>
<td align="left">APPEND key value</td>
<td>如果 key 已经存在并且是一个字符串， APPEND 命令将指定的 value 追加到该 key 原来值（value）的末尾</td>
<td>如果 key 不存在， APPEND 就简单地将键 key 的值设为 value ， 就像执行 SET key value 一样。追加 value 之后， 返回键 key 的值的长度。</td>
</tr>
<tr>
<td align="left">GET key</td>
<td>获取指定 key 的值</td>
<td>如果键 key 不存在， 那么返回特殊值 nil ； 否则， 返回键 key 的值 ； 如果键 key 的值并非字符串类型， 那么返回一个错误， 因为 GET 命令只能用于字符串值。</td>
</tr>
<tr>
<td align="left">MGET [key1 key2…]</td>
<td>获取所有(一个或多个)给定 key 的值</td>
<td></td>
</tr>
<tr>
<td align="left">GETRANGE key start end</td>
<td>返回 key 中字符串值的子字符</td>
<td>返回键 key 储存的字符串值的指定部分， 字符串的截取范围由 start 和 end 两个偏移量决定 (包括 start 和 end 在内)。<br/>负数偏移量表示从字符串的末尾开始计数， -1 表示最后一个字符， -2 表示倒数第二个字符， 以此类推。<br/>GETRANGE 通过保证子字符串的值域(range)不超过实际字符串的值域来处理超出范围的值域请求。</td>
</tr>
<tr>
<td align="left">GETSET key value</td>
<td>将给定 key 的值设为 value ，并返回 key 的旧值</td>
<td>如果键 key 没有旧值， 也即是说， 键 key 在被设置之前并不存在， 那么命令返回 nil 。当键 key 存在但不是字符串类型时， 命令返回一个错误。</td>
</tr>
<tr>
<td align="left">STRLEN key</td>
<td>返回 key 所储存的字符串值的长度。</td>
<td>当键 key 不存在时， 命令返回 0 。当 key 储存的不是字符串值时， 返回一个错误。</td>
</tr>
</tbody></table>
<h3 id="2-2、Redis字符串类型键的计数操作"><a href="#2-2、Redis字符串类型键的计数操作" class="headerlink" title="2.2、Redis字符串类型键的计数操作"></a>2.2、Redis字符串类型键的计数操作</h3><blockquote>
<p>参考案例：</p>
<p>案例一：统计网站访问者数量</p>
<p>案例二：每天注册用户数</p>
<p>案例三：限制API在某一时段的访问次数</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th>描述</th>
<th>参数解析</th>
</tr>
</thead>
<tbody><tr>
<td align="left">INCR key</td>
<td>将 key 中储存的数字值增一</td>
<td>如果键 key 不存在， 那么它的值会先被初始化为 0 ， 然后再执行 INCR 命令。<br/>如果键 key 储存的值不能被解释为数字， 那么 INCR 命令将返回一个错误。<br/>本操作的值限制在 64 位(bit)有符号数字表示之内。<br/>返回键 key 在执行加一操作之后的值。</td>
</tr>
<tr>
<td align="left">INCRBY key increment</td>
<td>将 key 所储存的值加上给定的增量值</td>
<td>同上</td>
</tr>
<tr>
<td align="left">INCRBYFLOAT key increment</td>
<td>将 key 所储存的值加上给定的增量值，增加量为小数</td>
<td>计算结果最多只保留小数点的后十七位。<br/>键 key 当前的值或者给定的增量 increment 不能被解释(parse)为双精度浮点数时返回异常。</td>
</tr>
<tr>
<td align="left">DECR key</td>
<td>将 key 中储存的数字值减一</td>
<td>如果键 key 不存在， 那么它的值会先被初始化为 0 ， 然后再执行 DECR 命令。<br/>如果键 key 储存的值不能被解释为数字， 那么 DECR 命令将返回一个错误。<br/>本操作的值限制在 64 位(bit)有符号数字表示之内。<br/>返回键 key 在执行减一操作之后的值。</td>
</tr>
<tr>
<td align="left">DECRBY key decrement</td>
<td>将 key 所储存的减少给定的减量值</td>
<td>同上</td>
</tr>
</tbody></table>
<h3 id="2-3、Redis字符串类型键的二进制操作（Bitmap位图）"><a href="#2-3、Redis字符串类型键的二进制操作（Bitmap位图）" class="headerlink" title="2.3、Redis字符串类型键的二进制操作（Bitmap位图）"></a>2.3、Redis字符串类型键的二进制操作（Bitmap位图）</h3><blockquote>
<p>参考案例：</p>
<p>案例一：用户签到</p>
<p>案例二：统计活跃用户</p>
<p>案例三：用户在线状态</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th>描述</th>
<th>参数解析</th>
</tr>
</thead>
<tbody><tr>
<td align="left">GETBIT key offset</td>
<td>对 key 所储存的字符串值，获取指定偏移量上的位(bit)</td>
<td>当 offset 比字符串值的长度大，或者 key 不存在时，返回 0 。<br/>字符串值指定偏移量上的位(bit)。</td>
</tr>
<tr>
<td align="left">SETBIT key offset value</td>
<td>对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。</td>
<td>当 key 不存在时，自动生成一个新的字符串值。</td>
</tr>
<tr>
<td align="left">BITCOUNT  key [start] [end]</td>
<td>计算给定字符串中，被设置为 1 的比特位的数量。</td>
<td>一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行。 返回值： 不存在的 key 被当成是空字符串来处理，因此对一个不存在的 key 进行 BITCOUNT 操作，结果为 0 / 被设置为 1 的位的数量。</td>
</tr>
<tr>
<td align="left">BITOP operation destkey key [key …]</td>
<td>对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。</td>
<td>OPERATION： 可以是 AND 、 OR 、 NOT 、 XOR 这四种操作中的任意一种。 除了 NOT 操作之外，其他操作都可以接受一个或多个 key 作为输入。 <br/>注意： 当 bitop 处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 0 。空的 key 也被看作是包含 0 的字符串序列。 返回值： 保存到 destkey 的字符串的长度，和输入 key 中最长的字符串长度相等。</td>
</tr>
<tr>
<td align="left">BITPOP key bit [start] [end]</td>
<td>返回字符串里面第一个被设置为1或者0的bit位。</td>
<td>命令返回字符串里面第一个被设置为1或者0的bit位。 如果我们在空字符串或者0字节的字符串里面查找bit为1的内容，那么结果将返回-1。</td>
</tr>
<tr>
<td align="left">BITFIELD key [GET type offset] [SET type offset value] [INCRBY type offset increment] [OVERFLOW WRAP|SAT|FAIL]</td>
<td>把Redis字符串当作位数组，并能对变长位宽和任意未字节对齐的指定整型位域进行寻址。</td>
<td>把Redis字符串当作位数组，并能对变长位宽和任意未字节对齐的指定整型位域进行寻址。在实践中，可以使用该命令对一个有符号的5位整型数的1234位设置指定值，也可以对一个31位无符号整型数的4567位进行取值。类似地，在对指定的整数进行自增和自减操作，本命令可以提供有保证的、可配置的上溢和下溢处理操作。 返回值： get 当前偏移位置所在的值。 set 当前偏移量的旧值。 incrby 当前偏移量的旧值。 nil 设置失败。 值的类型有误或者命令语法有误返回错误。<br/>返回值：<br/>a、get 当前偏移位置所在的值。 <br/>b、set 当前偏移量的旧值。 <br/>c、incrby 当前偏移量的旧值。 <br/>d、nil 设置失败。</td>
</tr>
</tbody></table>
<h2 id="3、Hash命令"><a href="#3、Hash命令" class="headerlink" title="3、Hash命令"></a>3、Hash命令</h2><p>&emsp;&emsp;Redis hash 是一个键值对集合，类似Java里面的Map&lt;String,Object&gt;。Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">描述</th>
<th>参数解析</th>
</tr>
</thead>
<tbody><tr>
<td align="left">HSET key field value</td>
<td align="left">将哈希表 key 中的字段 field 的值设为 value</td>
<td>如果给定的哈希表并不存在， 那么一个新的哈希表将被创建并执行 HSET 操作。如果域 field 已经存在于哈希表中， 那么它的旧值将被新值 value 覆盖。<br/>当 HSET 命令在哈希表中新创建 field 域并成功为它设置值时， 命令返回 1 ； 如果域 field 已经存在于哈希表， 并且 HSET 命令成功使用新值覆盖了它的旧值， 那么命令返回 0</td>
</tr>
<tr>
<td align="left">HSETNX key field value</td>
<td align="left">只有在字段 field 不存在时，设置哈希表字段的值</td>
<td>如果给定域已经存在于哈希表当中， 那么命令将放弃执行设置操作。<br/>在设置成功时返回 1 ， 在给定域已经存在而放弃执行设置操作时返回 0 。</td>
</tr>
<tr>
<td align="left">HMSET key field1 value1 [field2 value2 ]</td>
<td align="left">同时将多个 field-value (域-值)对设置到哈希表 key 中</td>
<td>此命令会覆盖哈希表中已存在的域。<br/>如果 key 不存在，一个空哈希表被创建并执行 HMSET 操作。</td>
</tr>
<tr>
<td align="left">HGET key field</td>
<td align="left">获取存储在哈希表中指定字段的值</td>
<td>如果给定域不存在于哈希表中， 又或者给定的哈希表并不存在， 那么命令返回 nil 。</td>
</tr>
<tr>
<td align="left">HMGET key field1 [field2]</td>
<td align="left">获取所有给定字段的值</td>
<td></td>
</tr>
<tr>
<td align="left">HGETALL key</td>
<td align="left">获取在哈希表中指定 key 的所有字段和值</td>
<td>如果给定的域不存在于哈希表，那么返回一个 nil 值。<br/>因为不存在的 key 被当作一个空哈希表来处理，所以对一个不存在的 key 进行 HMGET 操作将返回一个只带有 nil 值的表。</td>
</tr>
<tr>
<td align="left">HEXISTS key field</td>
<td align="left">查看哈希表 key 中，指定的字段是否存在</td>
<td>在给定field存在时返回 1 ， 在给定field不存在时返回 0 。</td>
</tr>
<tr>
<td align="left">HKEYS key</td>
<td align="left">获取所有哈希表中的字段</td>
<td></td>
</tr>
<tr>
<td align="left">HLEN key</td>
<td align="left">获取哈希表中字段的数量</td>
<td>当 key 不存在时，返回 0 。</td>
</tr>
<tr>
<td align="left">HVALS key</td>
<td align="left">获取哈希表中所有值</td>
<td></td>
</tr>
<tr>
<td align="left">HDEL key field1 [field2]</td>
<td align="left">删除一个或多个哈希表字段</td>
<td>删除哈希表 key 中的一个或多个指定域，不存在的域将被忽略。<br/>被成功移除的域的数量，不包括被忽略的域。</td>
</tr>
<tr>
<td align="left">HSCAN key cursor [MATCH pattern] [COUNT count]</td>
<td align="left">迭代哈希表中的键值对</td>
<td>简单来讲，这个命令就是可以将Key中的某些有相同规则的键找出来。pattern是规则，cursor是指光标，我们输入0即可。Count这个参数似乎在数据量较小的情况下不会生效。<br/>返回的每个元素都是一个键值对，一个键值对由一个键和一个值组成。</td>
</tr>
<tr>
<td align="left">HINCRBY key field increment</td>
<td align="left">为哈希表 key 中的指定字段的整数值加上增量 increment</td>
<td>为哈希表 key 中的指定字段的浮点数值加上增量 increment <br/>如果 key 不存在，一个新的哈希表被创建并执行 HINCRBY 命令。<br/>如果域 field 不存在，那么在执行命令前，域的值被初始化为 0 。<br/>对一个储存字符串值的域 field 执行 HINCRBY 命令将造成一个错误。<br/>本操作的值被限制在 64 位(bit)有符号数字表示之内。</td>
</tr>
<tr>
<td align="left">HINCRBYFLOAT key field increment</td>
<td align="left">为哈希表 key 中的指定字段的浮点数值加上增量 increment</td>
<td>同上</td>
</tr>
</tbody></table>
<h2 id="4、List命令"><a href="#4、List命令" class="headerlink" title="4、List命令"></a>4、List命令</h2><p>&emsp;&emsp;Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）。它的底层实际是个双向链表。</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">描述</th>
<th>参数解析</th>
</tr>
</thead>
<tbody><tr>
<td align="left">LPUSH key value1 [value2]</td>
<td align="left">将一个或多个值插入到列表头部</td>
<td>如果有多个 value 值，那么各个 value 值按从左到右的顺序依次插入到表头： 比如说，对空列表 mylist 执行命令 LPUSH mylist a b c ，列表的值将是 c b a 。<br/>如果 key 不存在，一个空列表会被创建并执行 LPUSH 操作。<br/>当 key 存在但不是列表类型时，返回一个错误。</td>
</tr>
<tr>
<td align="left">LPUSHX key value</td>
<td align="left">将一个值插入到已存在的列表头部</td>
<td>将值 value 插入到列表 key 的表头，当且仅当 key 存在并且是一个列表。Key 不存在时则不进行操作。</td>
</tr>
<tr>
<td align="left">LSET key index value</td>
<td align="left">通过索引设置列表元素的值</td>
<td>当 index 参数超出范围，或对一个空列表( key 不存在)进行 LSET 时，返回一个错误。</td>
</tr>
<tr>
<td align="left">LINSERT key BEFORE|AFTER pivot value</td>
<td align="left">在列表的元素前或者后插入元素</td>
<td>当 pivot 不存在于列表 key 时，不执行任何操作，返回 -1 。       <br/>当 key 不存在时， key 被视为空列表，不执行任何操作，返回 0 。<br/>如果 key 不是列表类型，返回一个错误。</td>
</tr>
<tr>
<td align="left">LRANGE key start stop</td>
<td align="left">获取列表指定范围内的元素</td>
<td>下标(index)参数 start 和 stop 都以 0 为底，也就是说，以 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。<br/>如果 start 下标比列表的最大下标 end ( LLEN list 减去 1 )还要大，那么 LRANGE 返回一个空列表。如果 stop 下标比 end 下标还要大，Redis将 stop 的值设置为 end 。</td>
</tr>
<tr>
<td align="left">LPOP key</td>
<td align="left">移出并获取列表的第一个元素</td>
<td>列表的头元素。 当 key 不存在时，返回 nil 。</td>
</tr>
<tr>
<td align="left">LINDEX key index</td>
<td align="left">通过索引获取列表中的元素</td>
<td>下标(index)参数 start 和 stop 都以 0 为底，也就是说，以 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推 。你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。如果 key 不是列表类型，返回一个错误。</td>
</tr>
<tr>
<td align="left">LLEN key</td>
<td align="left">获取列表长度</td>
<td>如果 key 不存在，则 key 被解释为一个空列表，返回 0 。如果 key 不是列表类型，返回一个错误。</td>
</tr>
<tr>
<td align="left">LREM key count value</td>
<td align="left">移除列表元素</td>
<td>count &gt; 0 : 从表头开始向表尾搜索，移除与 value 相等的元素，数量为 count 。<br/>count &lt; 0 : 从表尾开始向表头搜索，移除与 value 相等的元素，数量为 count 的绝对值。<br/> count = 0 : 移除表中所有与 value 相等的值。</td>
</tr>
<tr>
<td align="left">LTRIM key start stop</td>
<td align="left">对一个列表进行修剪(trim)</td>
<td>让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</td>
</tr>
<tr>
<td align="left">RPUSH key value1 [value2]</td>
<td align="left">将一个或多个值 value 插入到列表 key 的表尾(最右边)</td>
<td>如果有多个 value 值，那么各个 value 值按从左到右的顺序依次插入到表尾：比如对一个空列表 mylist 执行 RPUSH mylist a b c ，得出的结果列表为 a b c 。<br/> 如果 key 不存在，一个空列表会被创建并执行 RPUSH 操作。当 key 存在但不是列表类型时，返回一个错误。</td>
</tr>
<tr>
<td align="left">RPUSHX key value</td>
<td align="left">将值 value 插入到列表 key 的表尾，当且仅当 key 存在并且是一个列表</td>
<td>和 RPUSH key value [value …] 命令相反，当 key 不存在时， RPUSHX 命令什么也不做。</td>
</tr>
<tr>
<td align="left">RPOP key</td>
<td align="left">移除列表的最后一个元素，返回值为移除的元素</td>
<td></td>
</tr>
<tr>
<td align="left">RPOPLPUSH source destination</td>
<td align="left">移除列表的最后一个元素，并将该元素添加到另一个列表并返回</td>
<td>命令 RPOPLPUSH 在一个原子时间内，执行以下两个动作：<br/>将列表 source 中的最后一个元素(尾元素)弹出，并返回给客户端。<br/>将 source 弹出的元素插入到列表 destination ，作为 destination 列表的的头元素。<br/>如果 source 不存在，值 nil 被返回，并且不执行其他动作。<br/>如果 source 和 destination 相同，则列表中的表尾元素被移动到表头，并返回该元素，可以把这种特殊情况视作列表的旋转(rotation)操作。</td>
</tr>
<tr>
<td align="left">BLPOP key1 [key2 ] timeout</td>
<td align="left">移出并获取列表的第一个元素</td>
<td>它是 LPOP key 命令的阻塞版本，当给定列表内没有任何元素可供弹出的时候，连接将被 BLPOP 命令阻塞，直到等待超时或发现可弹出元素为止。<br/>当给定多个 key 参数时，按参数 key 的先后顺序依次检查各个列表，弹出第一个非空列表的头元素。<br/>如果列表为空，返回一个 nil 。 否则，返回一个含有两个元素的列表，第一个元素是被弹出元素所属的 key ，第二个元素是被弹出元素的值</td>
</tr>
<tr>
<td align="left">BRPOP key1 [key2] timeout</td>
<td align="left">移出并获取列表的最后一个元素</td>
<td>它是 RPOP key 命令的阻塞版本，当给定列表内没有任何元素可供弹出的时候，连接将被 BRPOP 命令阻塞，直到等待超时或发现可弹出元素为止。<br/>当给定多个 key 参数时，按参数 key 的先后顺序依次检查各个列表，弹出第一个非空列表的尾部元素。<br/>假如在指定时间内没有任何元素被弹出，则返回一个 nil 和等待时长。 反之，返回一个含有两个元素的列表，第一个元素是被弹出元素所属的 key ，第二个元素是被弹出元素的值。</td>
</tr>
<tr>
<td align="left">BRPOPLPUSH source destination timeout</td>
<td align="left">从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它</td>
<td>BRPOPLPUSH 是 RPOPLPUSH source destination 的阻塞版本，当给定列表 source 不为空时， BRPOPLPUSH 的表现和 RPOPLPUSH source destination 一样。<br/>当列表 source 为空时， BRPOPLPUSH 命令将阻塞连接，直到等待超时，或有另一个客户端对 source 执行 LPUSH key value [value …] 或 RPUSH key value [value …] 命令为止。<br/>超时参数 timeout 接受一个以秒为单位的数字作为值。超时参数设为 0 表示阻塞时间可以无限期延长(block indefinitely) 。<br/>假如在指定时间内没有任何元素被弹出，则返回一个 nil 和等待时长。 反之，返回一个含有两个元素的列表，第一个元素是被弹出元素的值，第二个元素是等待时长。</td>
</tr>
</tbody></table>
<h2 id="5、set命令"><a href="#5、set命令" class="headerlink" title="5、set命令"></a>5、set命令</h2><p>&emsp;&emsp;Redis的Set是string类型的无序集合。它是通过HashTable实现实现的。</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">描述</th>
<th>参数解析</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SADD key member1 [member2]</td>
<td align="left">向集合添加一个或多个成员，已经存在于集合的 member 元素将被忽略</td>
<td>假如 key 不存在，则创建一个只包含 member 元素作成员的集合。<br/>当 key 不是集合类型时，返回一个错误。</td>
</tr>
<tr>
<td align="left">SCARD key</td>
<td align="left">获取集合的元素数量</td>
<td>当 key 不存在时，返回 0 。</td>
</tr>
<tr>
<td align="left">SMEMBERS key</td>
<td align="left">返回集合中的所有成员</td>
<td>不存在的 key 被视为空集合。</td>
</tr>
<tr>
<td align="left">SISMEMBER key member</td>
<td align="left">判断 member 元素是否是集合 key 的成员</td>
<td>如果 member 元素是集合的成员，返回 1 。 如果 member 元素不是集合的成员，或 key 不存在，返回 0 。</td>
</tr>
<tr>
<td align="left">SREM key member1 [member2]</td>
<td align="left">移除集合中一个或多个成员</td>
<td>不存在的 member 元素会被忽略。当 key 不是集合类型，返回一个错误。同时，被成功移除的元素的数量，不包括被忽略的元素。</td>
</tr>
<tr>
<td align="left">SPOP key</td>
<td align="left">移除并返回集合中的一个随机元素</td>
<td>如果只想获取一个随机元素，但不想该元素从集合中被移除的话，可以使用 SRANDMEMBER key [count] 命令。<br/>被移除的随机元素。 当 key 不存在或 key 是空集时，返回 nil 。</td>
</tr>
<tr>
<td align="left">SRANDMEMBER key [count]</td>
<td align="left">返回集合中一个或多个随机数</td>
<td>从 Redis 2.6 版本开始， SRANDMEMBER 命令接受可选的 count 参数：<br/>a、 如果 count 为正数，且小于集合基数，那么命令返回一个包含 count 个元素的数组，数组中的元素各不相同。如果 count 大于等于集合基数，那么返回整个集合。<br/>b、 如果 count 为负数，那么命令返回一个数组，数组中的元素可能会重复出现多次，而数组的长度为 count 的绝对值。<br/>该操作和 SPOP key 相似，但 SPOP key 将随机元素从集合中移除并返回，而 SRANDMEMBER 则仅仅返回随机元素，而不对集合进行任何改动。</td>
</tr>
<tr>
<td align="left">SSCAN key cursor [MATCH pattern] [COUNT count]</td>
<td align="left">迭代集合中的元素</td>
<td>简单来讲，这个命令就是可以将集合中的某些有相同规则的内容找出来。pattern是规则。</td>
</tr>
<tr>
<td align="left">SMOVE source destination member 将 member</td>
<td align="left">元素从 source 集合移动到 destination 集合</td>
<td>如果 source 集合不存在或不包含指定的 member 元素，则 SMOVE 命令不执行任何操作，仅返回 0 。否则， member 元素从 source 集合中被移除，并添加到 destination 集合中去。<br/>当 destination 集合已经包含 member 元素时， SMOVE 命令只是简单地将 source 集合中的 member 元素删除。<br/>当 source 或 destination 不是集合类型时，返回一个错误。<br/>如果 member 元素被成功移除，返回 1 。 如果 member 元素不是 source 集合的成员，并且没有任何操作对 destination 集合执行，那么返回 0 。</td>
</tr>
<tr>
<td align="left">SDIFF key1 [key2]</td>
<td align="left">返回第一个集合与其他集合之间的差集</td>
<td>不存在的 key 被视为空集</td>
</tr>
<tr>
<td align="left">SDIFFSTORE destination key1 [key2]</td>
<td align="left">返回给定所有集合的差集并存储在 destination 中</td>
<td>如果 destination 集合已经存在，则将其覆盖。       <br/>destination 可以是 key 本身</td>
</tr>
<tr>
<td align="left">SINTER key1 [key2]</td>
<td align="left">返回给定所有集合的交集</td>
<td>不存在的 key 被视为空集。<br/>当给定集合当中有一个空集时，结果也为空集(根据集合运算定律)。</td>
</tr>
<tr>
<td align="left">SINTERSTORE destination key1 [key2]</td>
<td align="left">返回给定所有集合的交集并存储在 destination 中</td>
<td>如果 destination 集合已经存在，则将其覆盖。       <br/>destination 可以是 key 本身。</td>
</tr>
<tr>
<td align="left">SUNION key1 [key2]</td>
<td align="left">返回所有给定集合的并集</td>
<td>不存在的 key 被视为空集。</td>
</tr>
<tr>
<td align="left">SUNIONSTORE destination key1 [key2]</td>
<td align="left">所有给定集合的并集存储在 destination 集合中</td>
<td>如果 destination 已经存在，则将其覆盖。<br/>destination 可以是 key 本身。<br/>结果集中的元素数量。</td>
</tr>
</tbody></table>
<h2 id="6、Sorted-Set命令（ZSet）"><a href="#6、Sorted-Set命令（ZSet）" class="headerlink" title="6、Sorted Set命令（ZSet）"></a>6、Sorted Set命令（ZSet）</h2><p>&emsp;&emsp;Redis zset 和 set 一样也是string类型元素的集合，且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。Redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的，但分数(score)却可以重复。<br>&emsp;&emsp;Sorted Set实现方式：Redis Sorted Set 的内部使用 HashMap 和跳跃表（skipList）来保证数据的存储和有序，HashMap 里放的是成员到 Score 的映射。</p>
<h3 id="6-1、基本命令"><a href="#6-1、基本命令" class="headerlink" title="6.1、基本命令"></a>6.1、基本命令</h3><table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">描述</th>
<th>参数解析</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ZADD key [NX|XX] [CH] [INCR] score member [score member …]</td>
<td align="left">向有序集合添加一个或多个成员，或者更新已存在成员的分数</td>
<td>如果某个 member 已经是有序集的成员，那么更新这个 member 的 score 值，并通过重新插入这个 member 元素，来保证该 member 在正确的位置上。       <br/>score 值可以是整数值或双精度浮点数。<br/>如果 key 不存在，则创建一个空的有序集并执行 ZADD 操作。<br/>当 key 存在但不是有序集类型时，返回一个错误。</td>
</tr>
<tr>
<td align="left">ZCARD key</td>
<td align="left">获取有序集合的成员数</td>
<td>当 key 不存在时，返回 0 。</td>
</tr>
<tr>
<td align="left">ZCOUNT key min max</td>
<td align="left">计算在有序集合中指定区间分数的成员数</td>
<td>score 值在 min 和 max 之间(默认包括 score 值等于 min 或 max )的成员的数量。</td>
</tr>
<tr>
<td align="left">ZINCRBY key increment member</td>
<td align="left">有序集合中对指定成员的分数加上增量 increment</td>
<td>可以通过传递一个负数值 increment ，让 score 减去相应的值<br/>当 key 不存在，或 member 不是 key 的成员时， ZINCRBY key increment member 等同于 ZADD key increment member 。当 key 不是有序集类型时，返回一个错误。<br/>score 值可以是整数值或双精度浮点数<br/>member 成员的新 score 值，以字符串形式表示。</td>
</tr>
<tr>
<td align="left">ZINTERSTORE destination numkeys key [key …]</td>
<td align="left">计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 destination 中</td>
<td>计算给定的一个或多个有序集的交集，其中给定 key 的数量必须以 numkeys 参数指定，并将该交集(结果集)储存到 destination 。<br/>默认情况下，结果集中某个成员的 score 值是所有给定集下该成员 score 值之和。<br/>WEIGHTS指定对应key的权重，redis该key对应值得分值乘上权重系数，再根据AGGREGATE聚合函数统计，默认相加。</td>
</tr>
<tr>
<td align="left">ZLEXCOUNT key min max</td>
<td align="left">在有序集合中计算指定字典区间内成员数量</td>
<td>对于一个所有成员的分值都相同的有序集合键 key 来说， 这个命令会返回该集合中， 成员介于 min 和 max 范围内的元素数量。<br/>这个命令的 min 参数和 max 参数的意义和 ZRANGEBYLEX key min max [LIMIT offset count] 命令的 min 参数和 max 参数的意义一样。</td>
</tr>
<tr>
<td align="left">ZRANGE key start stop [WITHSCORES]</td>
<td align="left">通过索引区间返回有序集合指定区间内的成员</td>
<td>其中成员的位置按 score 值递增(从小到大)来排序。具有相同 score 值的成员按字典序(lexicographical order )来排列。<br/>如果你需要成员按 score 值递减(从大到小)来排列，请使用 ZREVRANGE key start stop [WITHSCORES] 命令。<br/>下标参数 start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推。 你也可以使用负数下标，以 -1 表示最后一个成员， -2 表示倒数第二个成员，以此类推。超出范围的下标并不会引起错误。 比如说，当 start 的值比有序集的最大下标还要大，或是 start &gt; stop 时， ZRANGE 命令只是简单地返回一个空列表。 另一方面，假如 stop 参数的值比有序集的最大下标还要大，那么 Redis 将 stop 当作最大下标来处理。<br/>可以通过使用 WITHSCORES 选项，来让成员和它的 score 值一并返回，返回列表以 value1,score1, …, valueN,scoreN 的格式表示。 客户端库可能会返回一些更复杂的数据类型，比如数组、元组等。</td>
</tr>
<tr>
<td align="left">ZRANGEBYLEX key min max [LIMIT offset count]</td>
<td align="left">通过字典区间返回有序集合的成员</td>
<td>如果有序集合里面的成员带有不同的分值， 那么命令返回的结果是未指定的（unspecified）。<br/>命令会使用 C 语言的 memcmp() 函数， 对集合中的每个成员进行逐个字节的对比（byte-by-byte compare）， 并按照从低到高的顺序， 返回排序后的集合成员。 如果两个字符串有一部分内容是相同的话， 那么命令会认为较长的字符串比较短的字符串要大。<br/>可选的 LIMIT offset count 参数用于获取指定范围内的匹配元素 （就像 SQL 中的 SELECT LIMIT offset count 语句）。 需要注意的一点是， 如果 offset 参数的值非常大的话， 那么命令在返回结果之前， 需要先遍历至 offset 所指定的位置， 这个操作会为命令加上最多 O(N) 复杂度。<br/>合法的 min 和 max 参数必须包含 ( 或者 [ ， 其中 ( 表示开区间（指定的值不会被包含在范围之内）， 而 [ 则表示闭区间（指定的值会被包含在范围之内）。<br/>特殊值 + 和 - 在 min 参数以及 max 参数中具有特殊的意义， 其中 + 表示正无限， 而 - 表示负无限。 因此， 向一个所有成员的分值都相同的有序集合发送命令 <code>ZRANGEBYLEX &lt;zset&gt; - + </code>， 命令将返回有序集合中的所有元素。</td>
</tr>
<tr>
<td align="left">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</td>
<td align="left">通过分数返回有序集合指定区间内的成员</td>
<td>如果有序集合里面的成员带有不同的分值， 那么命令返回的结果是未指定的（unspecified）。<br/>命令会使用 C 语言的 memcmp() 函数， 对集合中的每个成员进行逐个字节的对比（byte-by-byte compare）， 并按照从低到高的顺序， 返回排序后的集合成员。 如果两个字符串有一部分内容是相同的话， 那么命令会认为较长的字符串比较短的字符串要大。<br/>可选的 LIMIT offset count 参数用于获取指定范围内的匹配元素 （就像 SQL 中的 SELECT LIMIT offset count 语句）。 需要注意的一点是， 如果 offset 参数的值非常大的话， 那么命令在返回结果之前， 需要先遍历至 offset 所指定的位置， 这个操作会为命令加上最多 O(N) 复杂度。<br/>合法的 min 和 max 参数必须包含 ( 或者 [ ， 其中 ( 表示开区间（指定的值不会被包含在范围之内）， 而 [ 则表示闭区间（指定的值会被包含在范围之内）。<br/>特殊值 + 和 - 在 min 参数以及 max 参数中具有特殊的意义， 其中 + 表示正无限， 而 - 表示负无限。 因此， 向一个所有成员的分值都相同的有序集合发送命令 ZRANGEBYLEX <zset> - + ， 命令将返回有序集合中的所有元素。</td>
</tr>
<tr>
<td align="left">ZRANK key member</td>
<td align="left">返回有序集合中指定成员的索引</td>
<td>使用 ZREVRANK key member 命令可以获得成员按 score 值递减(从大到小)排列的排名。<br/>如果 member 是有序集 key 的成员，返回 member 的排名。 如果 member 不是有序集 key 的成员，返回 nil 。</td>
</tr>
<tr>
<td align="left">ZREM key member [member …]</td>
<td align="left">移除有序集合中的一个或多个成员</td>
<td>不存在的成员将被忽略，当 key 存在但不是有序集类型时，返回一个错误。</td>
</tr>
<tr>
<td align="left">ZREMRANGEBYLEX key min max</td>
<td align="left">移除有序集合中给定的字典区间的所有成员</td>
<td>这个命令的 min 参数和 max 参数的意义和 ZRANGEBYLEX key min max [LIMIT offset count] 命令的 min 参数和 max 参数的意义一样。结果返回被移除的元素数量。</td>
</tr>
<tr>
<td align="left">ZREMRANGEBYRANK key start stop</td>
<td align="left">移除有序集合中给定的排名区间的所有成员</td>
<td>区间分别以下标参数 start 和 stop 指出，包含 start 和 stop 在内。结果返回被移除的元素数量。<br/>下标参数 start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推。 你也可以使用负数下标，以 -1 表示最后一个成员， -2 表示倒数第二个成员，以此类推。</td>
</tr>
<tr>
<td align="left">ZREMRANGEBYSCORE key min max</td>
<td align="left">移除有序集合中给定的分数区间的所有成员</td>
<td>移除有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。可以使用括号（）来指定不包括min和max。结果返回被移除的元素数量。</td>
</tr>
<tr>
<td align="left">ZREVRANGE key start stop [WITHSCORES]</td>
<td align="left">返回有序集中指定区间内的成员，通过索引，分数从高到低</td>
<td>其中成员的位置按 score 值递减(从大到小)来排列。 具有相同 score 值的成员按字典序的逆序(reverse lexicographical order)排列。<br/>除了成员按 score 值递减的次序排列这一点外， ZREVRANGE 命令的其他方面和 ZRANGE key start stop [WITHSCORES] 命令一样。</td>
</tr>
<tr>
<td align="left">ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]</td>
<td align="left">返回有序集中指定分数区间内的成员，分数从高到低排序</td>
<td>具有相同 score 值的成员按字典序的逆序(reverse lexicographical order )排列。<br/>除了成员按 score 值递减的次序排列这一点外， ZREVRANGEBYSCORE 命令的其他方面和 ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count] 命令一样。</td>
</tr>
<tr>
<td align="left">ZREVRANK key member</td>
<td align="left">返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</td>
<td>排名以 0 为底，也就是说， score 值最大的成员排名为 0 。<br/>使用 ZRANK key member 命令可以获得成员按 score 值递增(从小到大)排列的排名。</td>
</tr>
<tr>
<td align="left">ZSCAN key cursor [MATCH pattern] [COUNT count]</td>
<td align="left">返回有序集中，成员的分数值</td>
<td>以上列出的四个命令都支持增量式迭代， 它们每次执行都只会返回少量元素， 所以这些命令可以用于生产环境， 而不会出现像 KEYS 命令、 SMEMBERS 命令带来的问题 —— 当 KEYS 命令被用于处理一个大的数据库时， 又或者 SMEMBERS 命令被用于处理一个大的集合键时， 它们可能会阻塞服务器达数秒之久。不过， 增量式迭代命令也不是没有缺点的： 举个例子， 使用 SMEMBERS 命令可以返回集合键当前包含的所有元素， 但是对于 SCAN 这类增量式迭代命令来说， 因为在对键进行增量式迭代的过程中， 键可能会被修改， 所以增量式迭代命令只能对被返回的元素提供有限的保证 （offer limited guarantees about the returned elements）。</td>
</tr>
<tr>
<td align="left">ZUNIONSTORE destination numkeys key [key …]</td>
<td align="left">计算给定的一个或多个有序集的并集，并存储在新的 key 中</td>
<td>计算给定的一个或多个有序集的并集，其中给定 key 的数量必须以 numkeys 参数指定，并将该并集(结果集)储存到 destination 。<br/>默认情况下，结果集中某个成员的 score 值是所有给定集下该成员 score 值之 和 。<br/>使用 WEIGHTS 选项，你可以为 每个 给定有序集 分别 指定一个乘法因子(multiplication factor)，每个给定有序集的所有成员的 score 值在传递给聚合函数(aggregation function)之前都要先乘以该有序集的因子。如果没有指定 WEIGHTS 选项，乘法因子默认设置为 1 。<br/>使用 AGGREGATE 选项，你可以指定并集的结果集的聚合方式。<br/>默认使用的参数 SUM ，可以将所有集合中某个成员的 score 值之 和 作为结果集中该成员的 score 值；使用参数 MIN ，可以将所有集合中某个成员的 最小 score 值作为结果集中该成员的 score 值；而参数 MAX 则是将所有集合中某个成员的 最大 score 值作为结果集中该成员的 score 值。</td>
</tr>
<tr>
<td align="left">ZSCORE key member</td>
<td align="left">返回有序集 key 中，成员 member 的 score 值</td>
<td>如果 member 元素不是有序集 key 的成员，或 key 不存在，返回 nil 。</td>
</tr>
</tbody></table>
<h3 id="6-2、地理空间-geospatial"><a href="#6-2、地理空间-geospatial" class="headerlink" title="6.2、地理空间(geospatial)"></a>6.2、地理空间(geospatial)</h3><p>&emsp;&emsp;把某个具体的位置信息（经度，纬度，名称）添加到指定的key中，数据将会用一个sorted set存储，以便稍后能使用其他命令来根据半径来查询位置信息。注意：插入geospatial中的数据必须保证以下几点：</p>
<blockquote>
<ul>
<li>经度必须放在纬度前面；</li>
<li>有效的经度是-180度到180度；</li>
<li>有效的纬度是-85.05112878度到85.05112878度。</li>
</ul>
</blockquote>
<p>&emsp;&emsp;同时，由上面可知geospatial本质上是sorted set，所以如果需要删除一个地理位置的话，则直接使用sort set相关命令删除即可。geospatial的一个使用场景可以用来查询附近的人。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>GEOADD key longitude latitude member [longitude latitude member …]</td>
<td>添加一个或多个地理位置元素到一个key中<br/>longitude ：经度，latitude：纬度</td>
</tr>
<tr>
<td>GEODIST key member1 member2 [unit]</td>
<td>返回一个key中指定两个位置之间的直线距离<br />unit可以指定长度单位：m,km,ft等 默认为m</td>
</tr>
<tr>
<td>GEOHASH key member [member …]</td>
<td>返回一个或多个位置元素的 Geohash 表示，Geohash是一种经纬度散列算法，具体请百度。</td>
</tr>
<tr>
<td>GEOPOS key member [member …]</td>
<td>返回一个或多个位置的经纬度信息，由于采用了geohash算法，返回的经纬度和添加时的数据可能会有细小误差</td>
</tr>
<tr>
<td>GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count]</td>
<td>以给定位置为中心，半径不超过给定半径的附近所有位置</td>
</tr>
<tr>
<td>GEORADIUSBYMEMBER key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count]</td>
<td>同上，只是中心点不是指定经纬度，而是指定已添加的某个位置作为中心</td>
</tr>
</tbody></table>
<h2 id="7、Hyperloglog"><a href="#7、Hyperloglog" class="headerlink" title="7、Hyperloglog"></a>7、Hyperloglog</h2><p>&emsp;&emsp;Redis HyperLogLog是用来做基数统计的算法，HyperLogLog的优点是：在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且使很小的。每个HyperLogLog键只需要花费12kb内存，就可以计算接近2^64个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。但是，因为HyperLogLog只会根据输入元素来计算基数，而不会存储输入元素本身，所以HyperLogLog不能像集合那样，返回输入的各个元素。</p>
<p>&emsp;&emsp;基数简介：比如数据集{1,3,5,7,5,7,8}，那么这个数据集的基数集为{1,3,5,7,8},基数(不重复元素)为5。基数估计就是在误差可接受的范围内，快速计算基数。这里有一个重点，基数是可以存在误差的，所以在使用时需要考虑这一点。</p>
<p>&emsp;&emsp;Hyperloglog的使用场景一般可以用来统计系统的访问量。传统上我们可以把用户id保存在一个set集合上，但是当数量越大，这个集合需要占用的内存就越大，而Hyperloglog只需要12kb就可以解决。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>PFADD key element [element……]</td>
<td>将任意数量的元素添加到指定的HyperLogLog里面。</td>
</tr>
<tr>
<td>PFCOUNT key [key……]</td>
<td>当其作用于当个键时，返回储存在给定键的HyperLogLog的近似基数，如果键不存在，那么返回0。当其作用于多个键时，返回所有给定HyperLogLog的并集的近似基数，这个近似基数是通过将所有给定HyperLogLog合并至一个临时HyperLogLog来计算得出的。</td>
</tr>
<tr>
<td>PFMERGE destkey sourcekey [sourcekey……]</td>
<td>将多个HyperLogLog合并（merge）为一个HyperLogLog，合并后的HyperLogLog的基数接近于所有输入HyperLogLog的可见集合(observed set)的并集。</td>
</tr>
</tbody></table>
<h2 id="8、Transactions"><a href="#8、Transactions" class="headerlink" title="8、Transactions"></a>8、Transactions</h2><p>&emsp;&emsp;Redis事务提供了一种“将多个命令打包， 然后一次性、按顺序地执行”的机制， 并且事务在执行的期间不会主动中断 —— 服务器在执行完事务中的所有命令之后， 才会继续处理其他客户端的其他命令。</p>
<p>&emsp;&emsp;Redis中的事务是可以视为一个队列，即我们可以通过MULTI开始一个事务，这相当于我们声明了一个命令队列。接下来，我们向Redis中提交的每条命令，都会被排入这个命令队列。当我们输入EXEC命令时，将触发当前事务，这相当于我们从命令队列中取出命令并执行，所以Redis中一个事务从开始到执行会经历 <strong>开始事务</strong> 、 <strong>命令入队</strong> 和 <strong>执行事务</strong> 三个阶段。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
<th>参数解析</th>
</tr>
</thead>
<tbody><tr>
<td>MULTI</td>
<td>标记一个事务块的开始</td>
<td>事务块内的多条命令会按照先后顺序被放进一个队列当中，最后由 EXEC 命令原子性(atomic)地执行。</td>
</tr>
<tr>
<td>EXEC</td>
<td>执行事务块内的所有命令</td>
<td>假如某个(或某些) key 正处于 WATCH 命令的监视之下，且事务块中有和这个(或这些) key 相关的命令，那么 EXEC 命令只在这个(或这些) key 没有被其他命令所改动的情况下执行并生效，否则该事务被打断(abort)。</td>
</tr>
<tr>
<td>DISCARD</td>
<td>取消事务，放弃执行事务块内的所有命令。</td>
<td>如果正在使用 WATCH 命令监视某个(或某些) key，那么取消所有监视，等同于执行命令 UNWATCH 。</td>
</tr>
<tr>
<td>WATCH key [key …]</td>
<td>监视一个(或多个) key</td>
<td>如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。watch是Redis事物乐观锁的实现。</td>
</tr>
<tr>
<td>UNWATCH</td>
<td>取消 WATCH 命令对所有 key 的监视</td>
<td>如果在执行 WATCH 命令之后， EXEC 命令或 DISCARD 命令先被执行了的话，那么就不需要再执行 UNWATCH 了。<br />因为 EXEC 命令会执行事务，因此 WATCH 命令的效果已经产生了；而 DISCARD 命令在取消事务的同时也会取消所有对 key 的监视，因此这两个命令执行之后，就没有必要执行 UNWATCH 了。</td>
</tr>
</tbody></table>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">WinKing</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://cheng_qiwei.gitee.io/blog/2021/06/07/Redis%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%91%BD%E4%BB%A4/">http://cheng_qiwei.gitee.io/blog/2021/06/07/Redis%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%91%BD%E4%BB%A4/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://cheng_qiwei.gitee.io/blog" target="_blank">WinKings Blogs</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/blog/tags/%E5%AE%89%E8%A3%85/">安装</a><a class="post-meta__tags" href="/blog/tags/Redis/">Redis</a><a class="post-meta__tags" href="/blog/tags/%E5%91%BD%E4%BB%A4/">命令</a></div><div class="post_share"><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=null" async="async"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/blog/2021/06/14/Redis%E7%9A%84%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8/"><img class="prev-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/blog/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Redis的进阶使用</div></div></a></div><div class="next-post pull-right"><a href="/blog/2021/06/01/MyCat/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/blog/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MyCat</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/blog/2021/03/15/Linux安装软件/" title="Linux安装软件"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-15</div><div class="title">Linux安装软件</div></div></a></div><div><a href="/blog/2021/06/01/MyCat/" title="MyCat"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-01</div><div class="title">MyCat</div></div></a></div><div><a href="/blog/2021/06/14/Redis的进阶使用/" title="Redis的进阶使用"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-14</div><div class="title">Redis的进阶使用</div></div></a></div><div><a href="/blog/2021/06/30/Redis集群和分区/" title="Redis集群与分区"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-30</div><div class="title">Redis集群与分区</div></div></a></div></div></div></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" src="/blog/img/touxiang.jpg" onerror="this.onerror=null;this.src='/blog/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">WinKing</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/blog/archives/"><div class="headline">文章</div><div class="length-num">25</div></a></div><div class="card-info-data-item is-center"><a href="/blog/tags/"><div class="headline">标签</div><div class="length-num">48</div></a></div><div class="card-info-data-item is-center"><a href="/blog/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://gitee.com/cheng_qiwei"><i class="fab fa-gitee"></i><span>Follow Me</span></a></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%91%BD%E4%BB%A4"><span class="toc-text">Redis介绍与命令</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81NoSQL%E7%AE%80%E4%BB%8B"><span class="toc-text">一、NoSQL简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFNoSQL"><span class="toc-text">1、什么是NoSQL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81NoSQL"><span class="toc-text">2、为什么需要NoSQL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%E3%80%81%E6%98%93%E6%89%A9%E5%B1%95"><span class="toc-text">2.1、易扩展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%E3%80%81%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F%E9%AB%98%E6%80%A7%E8%83%BD"><span class="toc-text">2.2、大数据量高性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3%E3%80%81%E5%A4%9A%E6%A0%B7%E7%81%B5%E6%B4%BB%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B"><span class="toc-text">2.3、多样灵活的数据模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9B%9B%E5%A4%A7%E5%88%86%E7%B1%BB"><span class="toc-text">3、NoSQL数据库的四大分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E3%80%81KV%E9%94%AE%E5%80%BC%E5%AF%B9"><span class="toc-text">3.1、KV键值对</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2%E3%80%81%E6%96%87%E6%A1%A3%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">3.2、文档型数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3%E3%80%81%E5%88%97%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">3.3、列存储数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4%E3%80%81%E5%9B%BE%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">3.4、图关系数据库</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Redis%E5%AE%89%E8%A3%85"><span class="toc-text">二、Redis安装</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81Redis%E5%AE%98%E6%96%B9%E5%9C%B0%E5%9D%80"><span class="toc-text">1、Redis官方地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E5%8C%85"><span class="toc-text">2、下载安装包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E5%AE%89%E8%A3%85Redis"><span class="toc-text">3、安装Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E3%80%81%E8%A7%A3%E5%8E%8BRedis"><span class="toc-text">3.1、解压Redis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2%E3%80%81%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85"><span class="toc-text">3.2、编译安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3%E3%80%81%E5%90%AF%E5%8A%A8Redis"><span class="toc-text">3.3、启动Redis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4%E3%80%81%E8%BF%9E%E6%8E%A5Redis"><span class="toc-text">3.4、连接Redis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5%E3%80%81%E5%85%B3%E9%97%ADRedis"><span class="toc-text">3.5、关闭Redis</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81Redis%E5%91%BD%E4%BB%A4"><span class="toc-text">三、Redis命令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E9%80%9A%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-text">1、通用命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81string%E5%91%BD%E4%BB%A4"><span class="toc-text">2、string命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%E3%80%81Redis%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E9%94%AE%E7%9A%84%E8%AE%BE%E7%BD%AE%E5%92%8C%E6%9F%A5%E8%AF%A2"><span class="toc-text">2.1、Redis字符串类型键的设置和查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%E3%80%81Redis%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E9%94%AE%E7%9A%84%E8%AE%A1%E6%95%B0%E6%93%8D%E4%BD%9C"><span class="toc-text">2.2、Redis字符串类型键的计数操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3%E3%80%81Redis%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E9%94%AE%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%93%8D%E4%BD%9C%EF%BC%88Bitmap%E4%BD%8D%E5%9B%BE%EF%BC%89"><span class="toc-text">2.3、Redis字符串类型键的二进制操作（Bitmap位图）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81Hash%E5%91%BD%E4%BB%A4"><span class="toc-text">3、Hash命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81List%E5%91%BD%E4%BB%A4"><span class="toc-text">4、List命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81set%E5%91%BD%E4%BB%A4"><span class="toc-text">5、set命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81Sorted-Set%E5%91%BD%E4%BB%A4%EF%BC%88ZSet%EF%BC%89"><span class="toc-text">6、Sorted Set命令（ZSet）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1%E3%80%81%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4"><span class="toc-text">6.1、基本命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2%E3%80%81%E5%9C%B0%E7%90%86%E7%A9%BA%E9%97%B4-geospatial"><span class="toc-text">6.2、地理空间(geospatial)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81Hyperloglog"><span class="toc-text">7、Hyperloglog</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81Transactions"><span class="toc-text">8、Transactions</span></a></li></ol></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/blog/2021/07/25/zookeeper%E4%BB%8B%E7%BB%8D/" title="zookeeper详解"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="zookeeper详解"/></a><div class="content"><a class="title" href="/blog/2021/07/25/zookeeper%E4%BB%8B%E7%BB%8D/" title="zookeeper详解">zookeeper详解</a><time datetime="2021-07-25T14:00:00.000Z" title="发表于 2021-07-25 22:00:00">2021-07-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2021/07/10/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E5%88%86%E5%8C%BA%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94Hash%E4%B8%8E%E4%B8%80%E8%87%B4%E6%80%A7Hash/" title="分布式缓存分区算法——Hash与一致性Hash"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="分布式缓存分区算法——Hash与一致性Hash"/></a><div class="content"><a class="title" href="/blog/2021/07/10/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E5%88%86%E5%8C%BA%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94Hash%E4%B8%8E%E4%B8%80%E8%87%B4%E6%80%A7Hash/" title="分布式缓存分区算法——Hash与一致性Hash">分布式缓存分区算法——Hash与一致性Hash</a><time datetime="2021-07-10T14:00:00.000Z" title="发表于 2021-07-10 22:00:00">2021-07-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2021/06/30/Redis%E9%9B%86%E7%BE%A4%E5%92%8C%E5%88%86%E5%8C%BA/" title="Redis集群与分区"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="Redis集群与分区"/></a><div class="content"><a class="title" href="/blog/2021/06/30/Redis%E9%9B%86%E7%BE%A4%E5%92%8C%E5%88%86%E5%8C%BA/" title="Redis集群与分区">Redis集群与分区</a><time datetime="2021-06-30T14:00:00.000Z" title="发表于 2021-06-30 22:00:00">2021-06-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2021/06/14/Redis%E7%9A%84%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8/" title="Redis的进阶使用"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="Redis的进阶使用"/></a><div class="content"><a class="title" href="/blog/2021/06/14/Redis%E7%9A%84%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8/" title="Redis的进阶使用">Redis的进阶使用</a><time datetime="2021-06-14T14:00:00.000Z" title="发表于 2021-06-14 22:00:00">2021-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2021/06/07/Redis%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%91%BD%E4%BB%A4/" title="Redis介绍与命令"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="Redis介绍与命令"/></a><div class="content"><a class="title" href="/blog/2021/06/07/Redis%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%91%BD%E4%BB%A4/" title="Redis介绍与命令">Redis介绍与命令</a><time datetime="2021-06-07T14:00:00.000Z" title="发表于 2021-06-07 22:00:00">2021-06-07</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By WinKing</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/blog/js/utils.js"></script><script src="/blog/js/main.js"></script><script src="/blog/js/tw_cn.js"></script><script src="/blog/js/search/local-search.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script></div></body></html>