<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Redis集群与分区 | WinKings Blogs</title><meta name="keywords" content="主从复制,Redis,哨兵,分区,集群"><meta name="author" content="WinKing"><meta name="copyright" content="WinKing"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="Redis集群与分区一、为什么需要引入Redis集群与分区&amp;emsp;&amp;emsp;我们之前讲了很多Redis的内容，但是都是从单体的维度上讲的，从本篇开始，我们开始了解Redis集群以及相关的一些内容。那么首先有一个问题：Redis单体的QPS就已经非常高了，那为什么还需要集群化部署呢？ &amp;emsp;&amp;emsp;a、集群化部署是出于安全性考虑，如果仅仅存在单个Redis服务，那么当Redis服务发">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis集群与分区">
<meta property="og:url" content="http://cheng_qiwei.gitee.io/blog/2021/06/30/Redis%E9%9B%86%E7%BE%A4%E5%92%8C%E5%88%86%E5%8C%BA/index.html">
<meta property="og:site_name" content="WinKings Blogs">
<meta property="og:description" content="Redis集群与分区一、为什么需要引入Redis集群与分区&amp;emsp;&amp;emsp;我们之前讲了很多Redis的内容，但是都是从单体的维度上讲的，从本篇开始，我们开始了解Redis集群以及相关的一些内容。那么首先有一个问题：Redis单体的QPS就已经非常高了，那为什么还需要集群化部署呢？ &amp;emsp;&amp;emsp;a、集群化部署是出于安全性考虑，如果仅仅存在单个Redis服务，那么当Redis服务发">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2021-06-30T14:00:00.000Z">
<meta property="article:modified_time" content="2021-07-21T13:42:33.833Z">
<meta property="article:author" content="WinKing">
<meta property="article:tag" content="主从复制">
<meta property="article:tag" content="Redis">
<meta property="article:tag" content="哨兵">
<meta property="article:tag" content="分区">
<meta property="article:tag" content="集群">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/blog/img/favicon.png"><link rel="canonical" href="http://cheng_qiwei.gitee.io/blog/2021/06/30/Redis%E9%9B%86%E7%BE%A4%E5%92%8C%E5%88%86%E5%8C%BA/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/blog/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/blog/WinKings%20Blogs" media="print" onload="this.media='all'"><script>var GLOBAL_CONFIG = { 
  root: '/blog/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}

// https://stackoverflow.com/questions/16839698/jquery-getscript-alternative-in-native-javascript
const getScript = url => new Promise((resolve, reject) => {
  const script = document.createElement('script')
  script.src = url
  script.async = true
  script.onerror = reject
  script.onload = script.onreadystatechange = function() {
    const loadState = this.readyState
    if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
    script.onload = script.onreadystatechange = null
    resolve()
  }
  document.head.appendChild(script)
})</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-07-21 21:42:33'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/blog/img/touxiang.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/blog/archives/"><div class="headline">文章</div><div class="length-num">25</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/blog/tags/"><div class="headline">标签</div><div class="length-num">48</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/blog/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/blog/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/blog/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/blog/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/blog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/blog/">WinKings Blogs</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/blog/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/blog/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/blog/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/blog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Redis集群与分区</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-06-30T14:00:00.000Z" title="发表于 2021-06-30 22:00:00">2021-06-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-07-21T13:42:33.833Z" title="更新于 2021-07-21 21:42:33">2021-07-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/blog/categories/Redis/">Redis</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Redis集群与分区"><a href="#Redis集群与分区" class="headerlink" title="Redis集群与分区"></a>Redis集群与分区</h1><h1 id="一、为什么需要引入Redis集群与分区"><a href="#一、为什么需要引入Redis集群与分区" class="headerlink" title="一、为什么需要引入Redis集群与分区"></a>一、为什么需要引入Redis集群与分区</h1><p>&emsp;&emsp;我们之前讲了很多Redis的内容，但是都是从单体的维度上讲的，从本篇开始，我们开始了解Redis集群以及相关的一些内容。那么首先有一个问题：Redis单体的QPS就已经非常高了，那为什么还需要集群化部署呢？</p>
<p>&emsp;&emsp;a、集群化部署是出于安全性考虑，如果仅仅存在单个Redis服务，那么当Redis服务发生宕机的时候，那么所有客户端直接无法访问，对业务会造成很大影响。同时，如果硬件方面发生损坏，那么数据直接无法恢复，会对系统造成灾难性的损伤。</p>
<p>&emsp;&emsp;b、虽然Redis单体的QPS就已经非常高，但是如果遇到高并发甚至超高并发的情况下，性能还是会受到影响。此时，多个Redis服务就能有效缓解单体Redis的压力。</p>
<p>&emsp;&emsp;c、此外出于存储的考虑，由于 Redis 所有的数据都放在内存中，如果数据量大，很容易受到硬件的限制。升级硬件收效和成本比太低，所以我们需要有一种横向扩展的方法，使用分片技术，把数据分配到一个个集群Redis组中。</p>
<h1 id="二、Redis的主从复制"><a href="#二、Redis的主从复制" class="headerlink" title="二、Redis的主从复制"></a>二、Redis的主从复制</h1><p>&emsp;&emsp;主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)。数据的复制是单向的，只能由主节点到从节点。主节点负责写操作，从节点负责读操作。主从复制把数据复制多个副本部署到其他节点上，从而实现Redis的高可用性，实现对数据的冗余备份，保证数据和服务的高度可靠性。</p>
<h2 id="1、主从复制的优缺点"><a href="#1、主从复制的优缺点" class="headerlink" title="1、主从复制的优缺点"></a>1、主从复制的优缺点</h2><h3 id="1-1、优点"><a href="#1-1、优点" class="headerlink" title="1.1、优点"></a>1.1、优点</h3><blockquote>
<ul>
<li>避免Redis单点故障；</li>
<li>构建读写分离架构，满足读多写少的应用场景。</li>
</ul>
</blockquote>
<h3 id="1-2、缺点"><a href="#1-2、缺点" class="headerlink" title="1.2、缺点"></a>1.2、缺点</h3><blockquote>
<ul>
<li>RDB文件过大时，同步耗时；</li>
<li>在一主一从或者一主多从情况下，如果主节点挂了，对外提供的写服务就是不可用了（从节点仍然可以对外提供读服务），单点问题没有解决，需要手动进行主从的切换才行，但是这样比较费事费力，还会导致服务一段时间不可用。所以可以使用哨兵模式来实现自动的主从切换和故障转移。</li>
</ul>
</blockquote>
<h2 id="2、主从复制相关概念"><a href="#2、主从复制相关概念" class="headerlink" title="2、主从复制相关概念"></a>2、主从复制相关概念</h2><blockquote>
<ol>
<li>每个Redis单体默认都是一个master，一个master订阅了其他master就会转换为slave，一个master可以拥有多个slave；</li>
<li>master的复制是<strong>异步非阻塞</strong>的，一个slave可以接受另外的slave的连接，组成主从从的形态；</li>
<li>客户端可以使用 wait 命令请求同步复制某些特定数据；</li>
<li>正常连接情况下，master通过命令流来保持对slave的数据更新；</li>
<li>当master与slave之间得到连接断开，slave在尝试与master重连后，会尝试获取与master断开期间丢失的命令流；</li>
<li>在断开期间的数据无法重新同步时，slave会请求全量更新，master将以rdb快照方式将全量数据推送给slave，之后再进行增量更新。</li>
</ol>
</blockquote>
<h2 id="3、主从复制原理"><a href="#3、主从复制原理" class="headerlink" title="3、主从复制原理"></a>3、主从复制原理</h2><p>&emsp;&emsp;在slave节点第一次与master连接时和断线重连时（ master 判断 runid 是否一致）会执行全量复制，此时master节点通过bgsave命令在本地生成一个RDB数据快照文件，然后将RDB文件通过Socket连接传送给从节点，然后从节点先清空自身数据，然后使用接收到的RDB文件加载数据。</p>
<p>&emsp;&emsp;而对于其他时候，slave节点会采取一种增量复制的方式进行主从复制。每个master都有一个replicationId（runid）用来表示与slave处于同一个主从复制中；同时存在一个偏移量，用来记录上次发送给slave的数据，每次复制数据后该偏移量都会增加，即使没有slave链接master ，它的offset也会增加。一对Replication ID, offset表示一个版本的数据。</p>
<p><img src="http://cheng_qiwei.gitee.io/blog/img/202009151648211.png" alt="202009151648211"></p>
<blockquote>
<p>主从复制的详细流程（了解）:</p>
<ol>
<li><p>从节点发送指令psync ? -1 psync runid offset找对应的runid的节点索取数据，但是这里有一个问题，当从节点第一次连接的时候根本就不知道主节点的runid 和offset 。所以第一次发送的指令是psync ？-1，意思就是主节点的数据需要全部同步过来。</p>
</li>
<li><p>主节点开始执行bgsave生成RDB文件，记录当前的复制偏移量offset。</p>
</li>
<li><p>主节点把自己的runid和offset通过+FULLRESYNC runid offset指令发送给从节点，然后通过socket发送RDB文件也发送给从节点。在这个阶段内可能主节点会收到客户端的指令，offset发生了变化。</p>
</li>
<li><p>从节点接收到主节点的runid和offset并将其保存下来，然后清空数据库当前所有数据，通过socket接收RDB文件，开始恢复RDB数据（全量复制）。</p>
</li>
<li><p>在全量复制后，从节点已经获取到了主节点的runid和offset，开始发送指令psync runid offset。</p>
</li>
<li><p>主节点接收指令，判断runid是否匹配，同时判断offset是否在复制缓冲区中。</p>
</li>
<li><p>主节点判断runid和offset，若有一个不满足，就会在返回到步骤2继续执行全量复制。这里runid不匹配的原因可能是从节点意外重启，offset（偏移量）不匹配的原因是复制缓冲区溢出了。如果runid或offset校验通过，从节点的offset和主节点的offset相同时则忽略，如果从节点的offset与主节点的offset不相同，则主节点会发送+CONTINUE offset（这个offset为主节点的）命令，通过socket发送复制缓冲区中以从节点offset开始到主节点offset结束的操作（实际上就是从节点与主节点相比少执行的操作）。</p>
</li>
<li><p>从节点收到主节点发送的offset并且通过socket接收到信息后，执行bgrewriteaof，恢复数据。</p>
</li>
</ol>
<p>   参考【<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43907422/article/details/105835347">链接</a>】</p>
</blockquote>
<h2 id="4、主从复制的操作流程"><a href="#4、主从复制的操作流程" class="headerlink" title="4、主从复制的操作流程"></a>4、主从复制的操作流程</h2><h3 id="4-1、准备操作"><a href="#4-1、准备操作" class="headerlink" title="4.1、准备操作"></a>4.1、准备操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建redis-cluster文件夹，用来存放集群测试的配置文件</span></span><br><span class="line">mkdir redis-cluster &amp;&amp; cp ./redis.conf ./redis-cluster/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改配置文件名称</span></span><br><span class="line">mv redis.conf redis_6379.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改配置，这里修改结束后以同样的方式拷贝6380和6381的配置文件，并修改端口和pid</span></span><br><span class="line">vim redis_6379.conf</span><br><span class="line">------------------ redis_6379.conf 开始---------------------</span><br><span class="line"><span class="comment"># Redis使用控制台模式（方便观察日志）</span></span><br><span class="line">daemonize no</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭保护模式</span></span><br><span class="line">protected-mode no</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注释以下内容开启远程访问</span></span><br><span class="line"><span class="comment"># bind 127.0.0.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改启动端口为6379</span></span><br><span class="line">port 6379</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改pidfile指向路径</span></span><br><span class="line">pidfile /opt/redis/6379/redis_6379.pid</span><br><span class="line">------------------ redis_6379.conf 结束---------------------</span><br></pre></td></tr></table></figure>

<p>三个配置文件修改完成后如图：</p>
<p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210713164341234.png" alt="image-20210713164341234"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-server ./redis-cluster/redis_6379.conf</span><br><span class="line">redis-server ./redis-cluster/redis_6380.conf</span><br><span class="line">redis-server ./redis-cluster/redis_6381.conf</span><br></pre></td></tr></table></figure>

<p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210713165032921.png" alt="image-20210713165032921"></p>
<h3 id="4-2、执行主从复制"><a href="#4-2、执行主从复制" class="headerlink" title="4.2、执行主从复制"></a>4.2、执行主从复制</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 查看当前主从状态，可以连接redis-cli，执行命令</span></span><br><span class="line">info replication</span><br></pre></td></tr></table></figure>

<p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210713165402905.png" alt="image-20210713165402905"></p>
<p>我们会发现，当前我们是主节点，从节点的个数为0。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从机执行连接主机命令（5.0之前命令为 slaveof &lt;host&gt; &lt;port&gt;）</span></span><br><span class="line">replicaof &lt;host&gt; &lt;port&gt;</span><br></pre></td></tr></table></figure>

<p>这里我们使用6380和6381连接6379为主机，此时查看主机和从机的效果如下：</p>
<table>
<thead>
<tr>
<th align="center">ip</th>
<th align="center">节点角色/端口</th>
</tr>
</thead>
<tbody><tr>
<td align="center">127.0.0.1</td>
<td align="center">master/6379</td>
</tr>
<tr>
<td align="center">127.0.0.1</td>
<td align="center">salve/6380</td>
</tr>
<tr>
<td align="center">127.0.0.1</td>
<td align="center">slave/6381</td>
</tr>
</tbody></table>
<p>主机效果：</p>
<p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210713170319198.png" alt="image-20210713170319198"></p>
<p>从机效果：</p>
<p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210713170412376.png" alt="image-20210713170412376"></p>
<p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210713170612788.png" alt="image-20210713170612788"></p>
<p>&emsp;&emsp;此时，我们在主机添加值，在从机也可以获取到，而如果我们在从机上面添加或修改值，则会返回异常说明该服务是从机，仅限于读。</p>
<p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210713172028816.png" alt="image-20210713172028816"></p>
<h3 id="4-3、slave升级为master"><a href="#4-3、slave升级为master" class="headerlink" title="4.3、slave升级为master"></a>4.3、slave升级为master</h3><p>&emsp;&emsp;如果我们的主机发生宕机，那么会发生上面情况？我们来试一下，首先，我们关闭主机，则从机会连接master失败。此时我们查看一下从机的状态和操作。发现此时从机中对主机的状态标识DOWN，但是，我们依然无法对从机进行写操作，但是读操作正常。那么如果我们希望从机能够继续服务，那么此时我们就需要将其中一台从机切换为主机，并让另一台从机去跟随它。</p>
<p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210713172958219.png" alt="image-20210713172958219"></p>
<p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210713173142785.png" alt="image-20210713173142785"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换从机为主机的命令</span></span><br><span class="line">replicaof no one</span><br></pre></td></tr></table></figure>

<p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210713173555329.png" alt="image-20210713173555329"></p>
<p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210713173630966.png" alt="image-20210713173630966"></p>
<p><strong>附：主从复制的一些相关配置</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># slave在首次接收master数据时，可以在slave中配置同步期间是否接收旧数据的访问，在首次同步之后，旧数据会被删除，然后再主线程加载新数据，此时slave会阻塞</span></span><br><span class="line">replica-serve-stale-data yes  </span><br><span class="line"></span><br><span class="line"><span class="comment">#从节点是否开启只读模式</span></span><br><span class="line">replica-read-only yes </span><br><span class="line"></span><br><span class="line"><span class="comment">#是否采用无磁盘模式传输，no表示走磁盘，yes走网络传输</span></span><br><span class="line">repl-diskless-sync no </span><br><span class="line"></span><br><span class="line"><span class="comment">#增量复制，当redis挂掉之后又恢复，主节点可以增量传输数据过来，但是增量的数据与当前的数据存在偏差，从节点可以通过传送offset从主节点再次拉回数据，此配置大小会关系到redis内存维护的队列大小，此操作的成功与否，数据量大于这个值会造成溢出</span></span><br><span class="line"><span class="comment"># repl-backlog-size 1mb </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果至少有 3 个 slave ，并且滞后小于 10 秒，则写入将被接受,如果条件不满足master的写操作将被拒绝。</span></span><br><span class="line"><span class="comment"># min-replicas-to-write 3</span></span><br><span class="line"><span class="comment"># min-replicas-max-lag 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果master节点设置了密码，需要在此处进行配置对应表的访问密码</span></span><br><span class="line"><span class="comment"># masterauth &lt;master-password&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置追随的master节点</span></span><br><span class="line"><span class="comment"># replicaof &lt;masterip&gt; &lt;masterport&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-4、总结"><a href="#4-4、总结" class="headerlink" title="4.4、总结"></a>4.4、总结</h3><p><strong>4.4.1、Redis配置主从复制的方式</strong></p>
<blockquote>
<ul>
<li><p>在进入6380、6381客户端，使用<code>replicaof host port</code>命令（5.0之前命令为<code>slaveof host port</code>），让从节点追随主节点；</p>
</li>
<li><p>在启动服务端时，使用<code>redis-server ./6380.conf --replicaof host port</code>命令，让从节点追随主节点；</p>
</li>
<li><p>在配置文件指定  replicaof <masterip> <masterport>。</p>
</li>
</ul>
</blockquote>
<p><strong>4.4.2、从节点追随主节点之后，旧数据会被删除，同时非阻塞方式同步主节点数据；</strong></p>
<p><strong>4.4.3、从节点只能读，不能写（可通过修改配置改变）；</strong></p>
<p><strong>4.4.4、主节点出现故障时，需要人工维护升级新的主节点。</strong></p>
<h1 id="三、哨兵模式"><a href="#三、哨兵模式" class="headerlink" title="三、哨兵模式"></a>三、哨兵模式</h1><p>&emsp;&emsp;我们上面讲到，虽然主从复制能够帮助我们解决单点故障和读写分离的问题。但与此同时，他也存在一个明显的问题，当主节点发生故障时，需要人工维护升级新的主节点才能恢复写的操作。这在正式环境下是不太可取的，如果需要等待人工维护的时间，以及需要维护的节点数量，都可能会导致服务的不可用。所以此时需要有一个服务，来帮我们监控主从节点的状态，并及时切换异常的节点，那么哨兵模式诞生了。</p>
<h2 id="1、为什么需要哨兵模式"><a href="#1、为什么需要哨兵模式" class="headerlink" title="1、为什么需要哨兵模式"></a>1、为什么需要哨兵模式</h2><blockquote>
<p>哨兵(Sentinel)主要是为了解决在主从复制架构中出现宕机的情况,主要分为两种情况：</p>
<p>1、Redis Slave宕机：</p>
<ul>
<li>这个相对而言比较简单，在Redis中从库重新启动后会自动加入到主从架构中,自动完成同步数据；</li>
<li>在Redis2.8版本后，主从断线后恢复 的情况下实现增量复制。 </li>
</ul>
<p>2、Redis Master宕机： </p>
<ul>
<li>第一步,在从数据库中执行SLAVEOF NO ONE命令，断开主从关系并且提升为主库继续服务；</li>
<li>第二步,将主库重新启动后，执行SLAVEOF命令,将其设置为其他库的从库,这时数据就能更新回来 。</li>
</ul>
<p>由于这个手动完成恢复的过程其实是比较麻烦的并且容易出错,所以Redis提供的哨兵(sentinel)的功能来解决。</p>
</blockquote>
<h2 id="2、什么是Redis-哨兵模式"><a href="#2、什么是Redis-哨兵模式" class="headerlink" title="2、什么是Redis 哨兵模式"></a>2、什么是Redis 哨兵模式</h2><p>&emsp;&emsp;Redis哨兵模式是用于管理Redis集群，它<strong>本质上也是Redis，一个特殊的Redis</strong>。它主要执行以下三个任务：</p>
<blockquote>
<ol>
<li>监控(Monitoring):Sentinel会不断地检查你的主服务器和从服务器是否运作正常；</li>
<li>提醒(Notification):当被监控的某个Redis服务器出现问题时,Sentinel可以通过API向管理员或者其他应用程序发送通知；</li>
<li>自动故障迁移(Automatic failover):当一个主服务器不能正常工作时,Sentinel 会开始一次自动故障迁移操作,它会将失效的主服务器的其中一个从服务器升级为新的主服务器,并让失效主服务器的其他从服务器改为复制新的主服务器;当客户端试图连接失效的主服务器时,集群也会向客户端返回新主服务器的地址,使得集群可以使用新主服务器代替失效服务器。</li>
</ol>
</blockquote>
<h2 id="3、Sentinel集群与相互发现"><a href="#3、Sentinel集群与相互发现" class="headerlink" title="3、Sentinel集群与相互发现"></a>3、Sentinel集群与相互发现</h2><p>&emsp;&emsp;我们在日常使用中，为了实现Sentinel的高可用，一般情况下也会部署Sentinel集群，如下图。那么Sentinel之间是如何相互发现呢？</p>
<p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210714113733821.png" alt="image-20210714113733821"></p>
<blockquote>
<ul>
<li>每个Sentinel会以每两秒一次的频率，通过发布与订阅功能，向被它监视的所有master和slave的 sentinel:hello 频道发送一条信息。信息中包含了该Sentinel的IP 地址、端口号和运行ID （runid）。</li>
<li>每个Sentinel都订阅了被它监视的所有master和slave的sentinel:hello 频道,查找之前未出现过的sentinel（looking for unknown sentinels）。当一个Sentinel 发现一个新的Sentinel时，它会将新的Sentinel添加到一个列表中，这个列表保存了Sentinel已知的，监视同一个主服务器的所有其他Sentinel。</li>
<li>Sentinel 发送的信息中还包括完整的主服务器当前配置（configuration）。 如果一个 Sentinel 包含的主服务器配置比另一个 Sentinel 发送的配置要旧， 那么这个 Sentinel 会立即升级到新配置上。</li>
<li>将一个新Sentinel添加到监视主服务器的列表上面之前，Sentinel会先检查列表中是否已经包含了和要添加的Sentinel拥有相同运行ID或者相同地址（包括IP地址和端口号）的 Sentinel ，如果是的话，Sentinel会先移除列表中已有的那些拥有相同运行ID或者相同地址的Sentinel， 然后再添加新Sentinel。</li>
</ul>
</blockquote>
<h2 id="4、Sentinel对master的故障判定与master的选举"><a href="#4、Sentinel对master的故障判定与master的选举" class="headerlink" title="4、Sentinel对master的故障判定与master的选举"></a>4、Sentinel对master的故障判定与master的选举</h2><blockquote>
<p><strong>故障判定：</strong></p>
<p>&emsp;&emsp;Sentinel会以每秒钟一次的频率向它所知的master、slave以及其他 Sentinel 实例发送一个 PING 命令,如果距离最后一次有效回复 PING 命令的时间超过 <code>down-after-milliseconds</code> 选项所指定的值，那么这个实例会被 Sentinel 标记为主观下线。一个有效回复可以是：+PONG 、-LOADING 或者 -MASTERDOWN ，其它回复或者没有回复都算是无效回复。</p>
<p>&emsp;&emsp;当master标记为ODOWN(主观下线)后，会通过向另一个 Sentinel 发送 SENTINEL is-master-down-by-addr 命令来询问对方是否认为给定的服务器已下线。此时会有以下两种情况：</p>
<ul>
<li>当有足够数量的 Sentinel（至少要达到配置文件指定的数量quorum）在指定的时间范围内同意这一判断， 那么这个主服务器被标记为客观下线。</li>
<li>当没有足够数量的 Sentinel 同意主服务器已经下线， 主服务器的客观下线状态就会被移除。 当主服务器重新向 Sentinel 的 PING 命令返回有效回复时， 主服务器的主观下线状态就会被移除。</li>
</ul>
<p>&emsp;&emsp;在一般情况下， 每个 Sentinel 会以每 10 秒一次的频率向它已知的所有master和slave发送 INFO 命令。 当一个master被 Sentinel 标记为客观下线时， Sentinel 向下线master的所有slave发送 INFO 命令的频率会从 10 秒一次改为每秒一次。</p>
</blockquote>
<blockquote>
<p><strong>Master的选举：</strong></p>
<ol>
<li><p>筛选合适的从节点；</p>
<p>● 被标记为主观下线、已断线、或者最后一次回复 PING 命令的时间大于五秒钟的从服务器都会被淘汰；</p>
<p>● 与失效主服务器连接断开的时长超过 down-after-milliseconds 选项指定的时长十倍的从服务器都会被淘汰。</p>
</li>
<li><p>从筛选合格的从节点中选出复制偏移量（replication offset）最大的那个从服务器作为新的主服务器；</p>
</li>
<li><p>如果复制偏移量不可用， 或者从服务器的复制偏移量相同， 那么带有最小运行 ID 的那个从服务器成为新的主服务器。</p>
</li>
</ol>
</blockquote>
<h2 id="5、Sentinel哨兵模式的操作流程"><a href="#5、Sentinel哨兵模式的操作流程" class="headerlink" title="5、Sentinel哨兵模式的操作流程"></a>5、Sentinel哨兵模式的操作流程</h2><h3 id="5-1、配置Sentinel相关配置文件"><a href="#5-1、配置Sentinel相关配置文件" class="headerlink" title="5.1、配置Sentinel相关配置文件"></a>5.1、配置Sentinel相关配置文件</h3><p>&emsp;&emsp;在redis安装包下有一个<code>sentinel.conf</code>文件用来配置，可以根据该配置文件来配置Redis-Sentinel。以下截取几个重要的配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加守护进程模式(后台启动)</span></span><br><span class="line">daemonize yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加指明日志文件名</span></span><br><span class="line">logfile <span class="string">&quot;/usr/local/bin/redis-cluster/26379/sentinel_26379.log&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sentinel的pid文件</span></span><br><span class="line">pidfile /var/run/redis-sentinel-26379.pid</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改工作目录</span></span><br><span class="line">dir <span class="string">&quot;/usr/local/bin/redis-cluster/26379&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改启动端口</span></span><br><span class="line">port 26379</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭保护模式</span></span><br><span class="line">protected-mode no</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改sentinel需要监控的主机</span></span><br><span class="line"><span class="comment">#                监控主机的名称(自定义)  监控主机IP 监控主机端口  投票最低通过票数</span></span><br><span class="line"><span class="comment">#sentinel monitor &lt;master-name&gt;      &lt;host&gt;    &lt;port&gt;     &lt;number&gt;</span></span><br><span class="line">sentinel monitor  myMaster           127.0.0.1 6379        2</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果需要监控监控的master设置了密码，需要在此处设置</span></span><br><span class="line"><span class="comment">#sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span></span><br><span class="line">sentinel auth-pass myMaster 123456</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;本次我们创建三台sentinel哨兵来进行测试，所以需要配置三份文件。ip和端口配置如下：</p>
<table>
<thead>
<tr>
<th align="center">ip</th>
<th align="center">端口</th>
</tr>
</thead>
<tbody><tr>
<td align="center">127.0.0.1</td>
<td align="center">26379</td>
</tr>
<tr>
<td align="center">127.0.0.1</td>
<td align="center">26380</td>
</tr>
<tr>
<td align="center">127.0.0.1</td>
<td align="center">26381</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在redis-cluster创建文件夹并创建sentinel配置文件</span></span><br><span class="line">mkdir 26379 &amp;&amp; vim sentinel_26379.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加配置，并以相同的操作创建另外两台sentinel，这里为了展示日志，所以暂时注释掉守护进程和日志的配置</span></span><br><span class="line"><span class="comment"># 添加守护进程模式(后台启动)</span></span><br><span class="line"><span class="comment">#daemonize yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加指明日志文件名</span></span><br><span class="line"><span class="comment">#logfile &quot;/usr/local/bin/redis-cluster/26379/sentinel_26379.log&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sentinel的pid文件</span></span><br><span class="line">pidfile /var/run/redis-sentinel-26379.pid</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改工作目录</span></span><br><span class="line">dir <span class="string">&quot;/usr/local/bin/redis-cluster/26379&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改启动端口</span></span><br><span class="line">port 26379</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭保护模式</span></span><br><span class="line">protected-mode no</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改sentinel需要监控的主机</span></span><br><span class="line"><span class="comment">#                监控主机的名称(自定义)  监控主机IP 监控主机端口  投票最低通过票数</span></span><br><span class="line"><span class="comment">#sentinel monitor &lt;master-name&gt;      &lt;host&gt;    &lt;port&gt;     &lt;number&gt;</span></span><br><span class="line">sentinel monitor myMaster 127.0.0.1 6379 2</span><br></pre></td></tr></table></figure>

<p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210714150026381.png" alt="image-20210714150026381"></p>
<h3 id="5-2、启动Redis-Master和Slave"><a href="#5-2、启动Redis-Master和Slave" class="headerlink" title="5.2、启动Redis-Master和Slave"></a>5.2、启动Redis-Master和Slave</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动主机Master</span></span><br><span class="line">redis-server ./redis-cluster/redis_6379.conf</span><br><span class="line"><span class="comment"># 启动主机Slave</span></span><br><span class="line">redis-server ./redis-cluster/redis_6380.conf --replicaof 127.0.0.1 6379</span><br><span class="line">redis-server ./redis-cluster/redis_6381.conf --replicaof 127.0.0.1 6379</span><br></pre></td></tr></table></figure>

<h3 id="5-3、启动Redis-Sentinel集群"><a href="#5-3、启动Redis-Sentinel集群" class="headerlink" title="5.3、启动Redis-Sentinel集群"></a>5.3、启动Redis-Sentinel集群</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动方式一，使用Redis提供的redis-sentinel启动</span></span><br><span class="line">redis-sentinel ./redis-cluster/26379/sentinel_26379.conf</span><br><span class="line">redis-sentinel ./redis-cluster/26380/sentinel_26380.conf</span><br><span class="line">redis-sentinel ./redis-cluster/26381/sentinel_26381.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动方式二，使用Redis提供的redis-server启动（上面说过哨兵其实也是一种特殊的Redis）</span></span><br><span class="line">redis-server ./redis-cluster/26379/sentinel_26379.conf --sentinel</span><br><span class="line">redis-server ./redis-cluster/26380/sentinel_26380.conf --sentinel</span><br><span class="line">redis-server ./redis-cluster/26381/sentinel_26381.conf --sentinel</span><br></pre></td></tr></table></figure>

<p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210714155040815.png" alt="image-20210714155040815"></p>
<p>&emsp;&emsp;启动成功后，我们可以从日志中发现某一台哨兵会同时检测Master、Master对应的Slave和同时监控这个Master的其他哨兵。</p>
<h2 id="6、测试重新选举Master"><a href="#6、测试重新选举Master" class="headerlink" title="6、测试重新选举Master"></a>6、测试重新选举Master</h2><p>&emsp;&emsp;上面操作完成后，我们搭建的Sentinel集群就已经完成，此时我们来测试一下Master宕机的情况，看看Sentinel集群有什么操作。</p>
<p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210714160208921.png" alt="image-20210714160208921"></p>
<p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210714160352435.png" alt="image-20210714160352435"></p>
<p>&emsp;&emsp;我们发现，当主机宕机之后，Sentinel重新投票，选举了6381作为新的Master，并将6380和6379设置为6381的Slave。</p>
<h2 id="7、问题"><a href="#7、问题" class="headerlink" title="7、问题"></a>7、问题</h2><p>&emsp;&emsp;<strong>Master节点存在已经过期的key，复制到了slave，那当Master的“访问过期”和“定期过期”机制没有被触发时，该key没有被删除，客户端链接Slave查询该key时出现什么情况？</strong></p>
<p>&emsp;&emsp;答：Slave不会过期key，只会等待Master过期key。如果Master过期了一个key，或者通过LRU淘汰了一个key，那么会模拟一条del命令发送给Slave。</p>
<h1 id="四、Redis的分区"><a href="#四、Redis的分区" class="headerlink" title="四、Redis的分区"></a>四、Redis的分区</h1><p>&emsp;&emsp;分区是分割数据到多个 Redis 实例的处理过程，因此每个实例只保存key的一个子集。</p>
<h2 id="1、Redis分区的优点与缺点"><a href="#1、Redis分区的优点与缺点" class="headerlink" title="1、Redis分区的优点与缺点"></a>1、Redis分区的优点与缺点</h2><h3 id="1-1、优点-1"><a href="#1-1、优点-1" class="headerlink" title="1.1、优点"></a>1.1、优点</h3><p>&emsp;&emsp;上面我们讲主从复制，它解决的是Redis单体服务的安全性，而对于分区，他解决的内容有：</p>
<blockquote>
<ol>
<li>性能的提升，单机Redis的网络I/O能力和计算资源是有限的，将请求分散到多台机器，充分利用多台机器的计算能力可网络带宽，有助于提高Redis总体的服务能力。</li>
<li>存储的横向扩展，即使Redis的服务能力能够满足应用需求，但是随着存储数据的增加，单台机器受限于机器本身的存储容量，将数据分散到多台机器上存储使得Redis服务可以横向扩展。</li>
</ol>
</blockquote>
<h3 id="1-2、缺点-1"><a href="#1-2、缺点-1" class="headerlink" title="1.2、缺点"></a>1.2、缺点</h3><blockquote>
<ol>
<li>由于多个key不在统一的分区，所以无法使用聚合和事务操作；</li>
<li>动态扩容和收缩需要对数据进行再平衡（可以使用预分片解决）。</li>
</ol>
</blockquote>
<h2 id="2、Redis分区的相关概念"><a href="#2、Redis分区的相关概念" class="headerlink" title="2、Redis分区的相关概念"></a>2、Redis分区的相关概念</h2><h3 id="2-1、三种分区方案"><a href="#2-1、三种分区方案" class="headerlink" title="2.1、三种分区方案"></a>2.1、三种分区方案</h3><p>分区可以在程序的不同层次实现，主要的实现方案有以下三个：</p>
<h4 id="2-1-1、客户端分区"><a href="#2-1-1、客户端分区" class="headerlink" title="2.1.1、客户端分区"></a>2.1.1、客户端分区</h4><p>&emsp;&emsp;客户端分区就是在客户端根据一定算法或逻辑决定数据会被存储到哪个Redis节点或从哪个Redis节点读取。由客户端自己实现逻辑。</p>
<h4 id="2-1-2、代理分区"><a href="#2-1-2、代理分区" class="headerlink" title="2.1.2、代理分区"></a>2.1.2、代理分区</h4><p>&emsp;&emsp;客户端不需要理会如何进行分区，而是将请求发送给代理，由代理决定去哪个节点写数据或者读数据。代理根据分区规则决定请求哪些Redis实例，然后根据Redis的响应结果返回给客户端。</p>
<p>&emsp;&emsp;Redis的代理实现有 <strong>twemproxy、predixy 等。</strong></p>
<h4 id="2-1-3、查询路由-Query-routing"><a href="#2-1-3、查询路由-Query-routing" class="headerlink" title="2.1.3、查询路由(Query routing)"></a>2.1.3、查询路由(Query routing)</h4><p>&emsp;&emsp;查询路由是客户端随机地请求任意一个Redis实例，然后由Redis将请求转发给正确的Redis节点。<strong>Redis Cluster</strong>实现了一种混合形式的查询路由，但并不是直接将请求从一个Redis节点转发到另一个Redis节点，而是在客户端的帮助下直接<em>redirected</em>到正确的Redis节点。</p>
<h3 id="2-2、预分区"><a href="#2-2、预分区" class="headerlink" title="2.2、预分区"></a>2.2、预分区</h3><p>&emsp;&emsp;在正常运营环境中，一般所存储的数据会逐渐增加，可能今天只要10个Redis实例就能应付，但是到了一年以后就需要50个Redis实例才能支撑，因此，Redis的扩容是经常用到的功能，在Redis的分布式部署中，预分区技术是非常好用的方法之一。</p>
<p>&emsp;&emsp;预分区技术是指在开始时就启动足够多的Redis实例（例如32或64个，估计一下够以后扩展用就行了），等到后续需要扩容的时候，只需要将其中一部分的Redis实例转移到新增加的机子上即可，在Redis实例迁移过程中使用Redis的复制功能可以最大限度的降低Redis的停工时间甚至可以做到没有停工时间。</p>
<blockquote>
<p>预分片的操作流程：</p>
<ol>
<li>新的服务器启动新的Redis实例；</li>
<li>配置为需要迁移的旧Redis的slave（此操作可以同步数据）；</li>
<li>更新分片映射的旧实例ip为新实例ip；</li>
<li>客户端连接新的Redis实例执行SLAVEOF NO ONE命令，将新实例升级为master；</li>
<li>停止旧的Redis实例。</li>
</ol>
</blockquote>
<h2 id="3、数据分治"><a href="#3、数据分治" class="headerlink" title="3、数据分治"></a>3、数据分治</h2><p>&emsp;&emsp;数据分治既可以在客户端下手，也可以在Redis下手，下面将介绍几种做法：</p>
<h3 id="3-1、Client端处理"><a href="#3-1、Client端处理" class="headerlink" title="3.1、Client端处理"></a>3.1、Client端处理</h3><h4 id="3-1-1、逻辑处理"><a href="#3-1-1、逻辑处理" class="headerlink" title="3.1.1、逻辑处理"></a>3.1.1、逻辑处理</h4><p>&emsp;&emsp;我们可以根据我们的业务逻辑，将不同逻辑的数据存储到不同的Redis实例中。但由于业务的复杂性，在很多场景下并不能简单的根据逻辑进行拆分。所以这种方案对数据特征有很大的要求，限制性较大。</p>
<p><img src="http://cheng_qiwei.gitee.io/blog/img/2020100319465922.jpg" alt="2020100319465922"></p>
<h4 id="3-1-2、Hash算法与一致性Hash"><a href="#3-1-2、Hash算法与一致性Hash" class="headerlink" title="3.1.2、Hash算法与一致性Hash"></a>3.1.2、Hash算法与一致性Hash</h4><p>&emsp;&emsp;如果数据不可以简单的根据逻辑拆分，我们可以使用各种<strong>映射算法</strong>，让数据按照一定的规则映射、保存在不同的 Redis 服务实例上。映射算法中我们最常用的就是 Hash 算法。但是，Hash算法有一个天生的缺陷，如果增加或减少机器，由于取模改变导致所有的数据会发生偏移，导致大部分数据都会查询不到，如果出现高并发，则会发生缓存雪崩的情况。所以此时就需要引入一致性Hash，一致性Hash会将数据和机器映射到一个Hash环中，通过数据在Hash环中顺时针寻找最近的节点获取存储的物理节点，这样做就不用担心增加或减少节点导致的数据雪崩情况。Hash算法和一致性Hash具体内容查看【<a href="http://cheng_qiwei.gitee.io/blog/2021/07/10/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E5%88%86%E5%8C%BA%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94Hash%E4%B8%8E%E4%B8%80%E8%87%B4%E6%80%A7Hash/">链接</a>】。</p>
<p><img src="http://cheng_qiwei.gitee.io/blog/img/20201003194726380.jpg" alt="在这里插入图片描述"></p>
<p><img src="http://cheng_qiwei.gitee.io/blog/img/20201003194811710.jpg" alt="在这里插入图片描述"></p>
<h3 id="3-2、Server端处理"><a href="#3-2、Server端处理" class="headerlink" title="3.2、Server端处理"></a>3.2、Server端处理</h3><p>&emsp;&emsp;我们上面讲到的几种操作，都是直接通过客户端的逻辑代码实现，那么，此时就会出现下面的问题：如图，我们的客户端服务一般都不会只有一个，可能会有多个，而且每个客户端根据实际情况可能还会出现集群，那么就会有大量的客户端与Redis实例进行连接，此时server端就需要处理大量的socket请求，造成server端的压力。所以此时我们可以考虑<strong>引入代理</strong>来解决这个问题。</p>
<p><img src="http://cheng_qiwei.gitee.io/blog/img/20201003194906655.jpg" alt="在这里插入图片描述"></p>
<h4 id="3-2-1、代理与负载均衡"><a href="#3-2-1、代理与负载均衡" class="headerlink" title="3.2.1、代理与负载均衡"></a>3.2.1、代理与负载均衡</h4><p>&emsp;&emsp;既然由server端直接处理连接时压力过大，那么我们就可以考虑引入代理端来处理。server端代理层能够保证 server 端压力不要过大，此时需要关注的点就是代理层如何保证高性能，以及保证可用性，那我们就可以引入负载均衡来保证高性能，并使用主备关系来保证可用性。</p>
<p><img src="http://cheng_qiwei.gitee.io/blog/img/20201003194921341.jpg" alt="在这里插入图片描述"></p>
<p><img src="http://cheng_qiwei.gitee.io/blog/img/202010031949420.jpg" alt="在这里插入图片描述"></p>
<h3 id="3-3、哈希槽"><a href="#3-3、哈希槽" class="headerlink" title="3.3、哈希槽"></a>3.3、哈希槽</h3><p>&emsp;&emsp;对于以上的所有方案，Redis都是适合当作缓存来用，而不能当作数据库使用。这是因为这些方式对于数据分布、节点位置的控制并不是很友好。为了将 Redis用作分布式数据库，所以就需要使用我们上面说的预分区。而Redis集群（cluster）使用哈希槽（slot），就能够解决数据分布和节点控制的问题。</p>
<p>&emsp;&emsp;其实哈希槽的本质和一致性哈希算法非常相似，不同点就是对于哈希空间的定义。一致性哈希的空间是一个圆环，节点分布是基于圆环的，无法很好的控制数据分布。而 Redis cluster 的槽位空间是自定义分配的，类似于 windows 盘分区的概念。这种分区是可以自定义大小，自定义位置的。</p>
<p>&emsp;&emsp;Redis cluster 包含了<strong>16384个哈希槽</strong>，每个 key 通过计算后都会落在具体一个槽位上，而这个槽位是属于哪个存储节点的，则由用户自己定义分配。如果机器硬盘小的，可以分配少一点槽位，硬盘大的可以分配多一点。如果节点硬盘都差不多则可以平均分配。<strong>所以哈希槽这种概念很好地解决了一致性哈希的弊端</strong>。</p>
<p><strong>&emsp;&emsp;每当有新节点加入时，它不再需要像一致性Hash算法那样把每个 key 取出来重新计算 Hash 值，只需要从旧节点中将新节点应该缓存的槽位数据拷贝到新节点中即可。</strong></p>
<p>&emsp;&emsp;而在容错性和扩展性上，表象与一致性哈希一样，都是对受影响的数据进行转移。而哈希槽本质上是对槽位的转移，把故障节点负责的槽位转移到其他正常的节点上。扩展节点也是一样，把其他节点上的槽位转移到新的节点上。</p>
<p>&emsp;&emsp;而对于<strong>弊端是聚合操作很难实现，并且不支持跨机器事务</strong>，但是提供了Hash Tag让用户控制需要计算的Key都集中在一个Redis中。</p>
<p><img src="http://cheng_qiwei.gitee.io/blog/img/20201003195043513.jpg" alt="在这里插入图片描述"></p>
<h2 id="4、分区的实现方式"><a href="#4、分区的实现方式" class="headerlink" title="4、分区的实现方式"></a>4、分区的实现方式</h2><h3 id="4-1、代理分区——TwemProxy"><a href="#4-1、代理分区——TwemProxy" class="headerlink" title="4.1、代理分区——TwemProxy"></a>4.1、代理分区——TwemProxy</h3><blockquote>
<p>TwemProxy官方地址： <a target="_blank" rel="noopener" href="https://github.com/twitter/twemproxy">https://github.com/twitter/twemproxy</a></p>
</blockquote>
<h4 id="4-1-1、安装"><a href="#4-1-1、安装" class="headerlink" title="4.1.1、安装"></a>4.1.1、安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载安装包</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/twitter/twemproxy.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成configure文件</span></span><br><span class="line"><span class="built_in">cd</span> twemproxy &amp;&amp; autoreconf -fvi</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装或更新插件(centOS7自带有，可忽略)</span></span><br><span class="line">yum install automake libtool -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">./configure --enable-debug=full &amp;&amp; make</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;到上面为止，我们的安装已经结束。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面的操作是为了之后可以使用service twemproxy start/stop等命令操作</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/twemproxy/scripts &amp;&amp; cp nutcracker.init /etc/init.d/twemproxy</span><br><span class="line"><span class="built_in">cd</span> /etc/init.d/ &amp;&amp; chmod +x twemproxy</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据脚本准备对应配置文件 OPTIONS=&quot;-d -c /etc/nutcracker/nutcracker.yml&quot;</span></span><br><span class="line">mkdir /etc/nutcracker &amp;&amp; cp /usr/<span class="built_in">local</span>/twemproxy/conf/* /etc/nutcracker/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置操作系统任意地方可以使用nutcracker命令。</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/twemproxy/src &amp;&amp; cp nutcracker /usr/bin</span><br></pre></td></tr></table></figure>

<h4 id="4-1-2、配置TwemProxy"><a href="#4-1-2、配置TwemProxy" class="headerlink" title="4.1.2、配置TwemProxy"></a>4.1.2、配置TwemProxy</h4><p>&emsp;&emsp;配·置<code>nutcracker.yml</code>文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 复制配置文件</span></span><br><span class="line"><span class="built_in">cd</span> /etc/nutcracker/ &amp;&amp; cp nutcracker.yml nutcracker.yml.bak</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改配置</span></span><br><span class="line">vim nutcracker.yml</span><br><span class="line"></span><br><span class="line">alpha:</span><br><span class="line">  listen: 127.0.0.1:22121</span><br><span class="line">  Hash: fnv1a_64</span><br><span class="line">  distribution: ketama</span><br><span class="line">  auto_eject_hosts: <span class="literal">true</span></span><br><span class="line">  redis: <span class="literal">true</span></span><br><span class="line">  server_retry_timeout: 2000</span><br><span class="line">  server_failure_limit: 1</span><br><span class="line">  servers:</span><br><span class="line">   - 127.0.0.1:6379:1 <span class="comment">#1指的是权重</span></span><br><span class="line">   - 127.0.0.1:9380:1</span><br><span class="line">   - 127.0.0.1:9381:1</span><br></pre></td></tr></table></figure>

<h4 id="4-1-3、使用TwemProxy"><a href="#4-1-3、使用TwemProxy" class="headerlink" title="4.1.3、使用TwemProxy"></a>4.1.3、使用TwemProxy</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先启动Redis实例</span></span><br><span class="line"><span class="comment"># 启动 TwemProxy</span></span><br><span class="line">service twemproxy start</span><br></pre></td></tr></table></figure>

<p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210718163444299.png" alt="image-20210718163444299"></p>
<h4 id="4-1-4、通过代理TwemProxy连接Redis"><a href="#4-1-4、通过代理TwemProxy连接Redis" class="headerlink" title="4.1.4、通过代理TwemProxy连接Redis"></a>4.1.4、通过代理TwemProxy连接Redis</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#数据分区，不支持keys、watch、MULTI等命令</span></span><br><span class="line">redis-cli -p 22121</span><br></pre></td></tr></table></figure>

<p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210718163919115.png" alt="image-20210718163919115"></p>
<h3 id="4-2、代理分区——Predixy"><a href="#4-2、代理分区——Predixy" class="headerlink" title="4.2、代理分区——Predixy"></a>4.2、代理分区——Predixy</h3><blockquote>
<p>中文文档：<a target="_blank" rel="noopener" href="https://github.com/joyieldInc/predixy/blob/master/README_CN.md">https://github.com/joyieldInc/predixy/blob/master/README_CN.md</a></p>
</blockquote>
<h4 id="4-2-1、安装Predixy"><a href="#4-2-1、安装Predixy" class="headerlink" title="4.2.1、安装Predixy"></a>4.2.1、安装Predixy</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载安装包</span></span><br><span class="line">wget https://github.com/joyieldInc/predixy/releases/download/1.0.5/predixy-1.0.5-bin-amd64-linux.tar.gz</span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar xf predixy-1.0.5-bin-amd64-linux.tar.gz -C /usr/<span class="built_in">local</span></span><br></pre></td></tr></table></figure>

<h4 id="4-2-2、配置Predixy"><a href="#4-2-2、配置Predixy" class="headerlink" title="4.2.2、配置Predixy"></a>4.2.2、配置Predixy</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改配置文件</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/predixy-1.0.5/conf &amp;&amp; vim predixy.conf </span><br><span class="line">--------------------------------------- predixy.conf开始 ----------------------------------------------------</span><br><span class="line"><span class="comment">################################### GENERAL ####################################</span></span><br><span class="line"><span class="comment"># 开放predixy绑定的ip端口</span></span><br><span class="line">Bind 127.0.0.1:7617</span><br><span class="line"><span class="comment"># Bind 0.0.0.0:7617</span></span><br><span class="line"><span class="comment"># Bind /tmp/predixy</span></span><br><span class="line"><span class="comment">################################### SERVERS，这里几种配置只开启一种 ####################</span></span><br><span class="line"><span class="comment"># Include cluster.conf</span></span><br><span class="line"><span class="comment">#加载sentinel相关配置</span></span><br><span class="line">Include sentinel.conf</span><br><span class="line"><span class="comment"># Include try.conf</span></span><br><span class="line">--------------------------------------- predixy.conf结束 ----------------------------------------------------</span><br><span class="line"><span class="comment"># 修改predixy的sentinel配置</span></span><br><span class="line">vim sentinel.conf</span><br><span class="line">--------------------------------------- sentinel.conf开始 ---------------------------------------------------</span><br><span class="line">SentinelServerPool &#123;</span><br><span class="line">    Databases 16</span><br><span class="line">    Hash crc16</span><br><span class="line">    HashTag <span class="string">&quot;&#123;&#125;&quot;</span></span><br><span class="line">    Distribution modula</span><br><span class="line">    MasterReadPriority 60</span><br><span class="line">    StaticSlaveReadPriority 50</span><br><span class="line">    DynamicSlaveReadPriority 50</span><br><span class="line">    RefreshInterval 1</span><br><span class="line">    ServerTimeout 1</span><br><span class="line">    ServerFailureLimit 10</span><br><span class="line">    ServerRetryTimeout 1</span><br><span class="line">    KeepAlive 120</span><br><span class="line">    Sentinels &#123;</span><br><span class="line">        + 127.0.0.1:26379  <span class="comment">#配置哨兵节点</span></span><br><span class="line">        + 127.0.0.1:26380  <span class="comment">#配置哨兵节点</span></span><br><span class="line">        + 127.0.0.1:26381  <span class="comment">#配置哨兵节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    Group mySentinel001 &#123; <span class="comment">#配置redis主从分组名</span></span><br><span class="line">    &#125;</span><br><span class="line">    Group mySentinel002 &#123; <span class="comment">#配置redis主从分组名</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------- sentinel.conf结束 ---------------------------------------------------</span><br></pre></td></tr></table></figure>

<h4 id="4-2-3、配置sentinel"><a href="#4-2-3、配置sentinel" class="headerlink" title="4.2.3、配置sentinel"></a>4.2.3、配置sentinel</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">--------------------------------- sentinel_26379.conf配置 ---------------------------------------------------</span><br><span class="line">port 26379</span><br><span class="line">sentinel monitor mySentinel001 127.0.0.1 36379 2</span><br><span class="line">sentinel monitor mySentinel002 127.0.0.1 46379 2</span><br><span class="line">daemonize yes</span><br><span class="line">--------------------------------- sentinel_26380.conf配置 ---------------------------------------------------</span><br><span class="line">port 26380</span><br><span class="line">sentinel monitor mySentinel001 127.0.0.1 36379 2</span><br><span class="line">sentinel monitor mySentinel002 127.0.0.1 46379 2</span><br><span class="line">daemonize yes</span><br><span class="line">--------------------------------- sentinel_26381.conf配置 ---------------------------------------------------</span><br><span class="line">port 26381</span><br><span class="line">sentinel monitor mySentinel001 127.0.0.1 36379 2</span><br><span class="line">sentinel monitor mySentinel002 127.0.0.1 46379 2</span><br><span class="line">daemonize yes</span><br></pre></td></tr></table></figure>

<p><strong>启动sentinel</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-server sentinel_26379.conf --sentinel</span><br><span class="line">redis-server sentinel_26380.conf --sentinel</span><br><span class="line">redis-server sentinel_26381.conf --sentinel</span><br></pre></td></tr></table></figure>

<h4 id="4-2-4、启动Redis主从"><a href="#4-2-4、启动Redis主从" class="headerlink" title="4.2.4、启动Redis主从"></a>4.2.4、启动Redis主从</h4><table>
<thead>
<tr>
<th align="center">主机 IP:端口</th>
<th align="center">从机 IP:端口</th>
</tr>
</thead>
<tbody><tr>
<td align="center">127.0.0.1:36379</td>
<td align="center">127.0.0.1:46380</td>
</tr>
<tr>
<td align="center">127.0.0.1:46379</td>
<td align="center">127.0.0.1:46380</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/<span class="built_in">local</span>/bin/redis-cluster/36379 &amp;&amp; <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/bin/redis-cluster/36379 &amp;&amp; redis-server --port 36379</span><br><span class="line">mkdir /usr/<span class="built_in">local</span>/bin/redis-cluster/36380 &amp;&amp; <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/bin/redis-cluster/36380 &amp;&amp; redis-server --port 36380 --replicaof 127.0.0.1 36379</span><br><span class="line">mkdir /usr/<span class="built_in">local</span>/bin/redis-cluster/46379 &amp;&amp; <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/bin/redis-cluster/46379 &amp;&amp; redis-server --port 46379</span><br><span class="line">mkdir /usr/<span class="built_in">local</span>/bin/redis-cluster/46380 &amp;&amp; <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/bin/redis-cluster/46380 &amp;&amp; redis-server --port 46380 --replicaof 127.0.0.1 46379</span><br></pre></td></tr></table></figure>

<p><strong>查看redis和sentinel状态<code>ps -ef|grep redis</code></strong></p>
<p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210718224719609.png" alt="image-20210718224719609"></p>
<h4 id="4-2-5、启动Predixy"><a href="#4-2-5、启动Predixy" class="headerlink" title="4.2.5、启动Predixy"></a>4.2.5、启动Predixy</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;predixy-1.0.5&#x2F;bin &amp;&amp; .&#x2F;predixy ..&#x2F;conf&#x2F;predixy.conf</span><br></pre></td></tr></table></figure>

<p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210718225448705.png" alt="image-20210718225448705"></p>
<h4 id="4-2-6、连接测试Predixy"><a href="#4-2-6、连接测试Predixy" class="headerlink" title="4.2.6、连接测试Predixy"></a>4.2.6、连接测试Predixy</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 7617</span><br></pre></td></tr></table></figure>

<p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210718230109921.png" alt="image-20210718230109921"></p>
<h3 id="4-3、查询路由分区——Redis-Cluster（理论）"><a href="#4-3、查询路由分区——Redis-Cluster（理论）" class="headerlink" title="4.3、查询路由分区——Redis-Cluster（理论）"></a>4.3、查询路由分区——Redis-Cluster（理论）</h3><blockquote>
<p>无需<code>proxy</code>代理，客户端直接与<code>redis</code>集群的每个节点连接，根据同样的<code>Hash</code>算法计算出<code>key</code>对应的<code>slot</code>，然后直接在<code>slot</code>对应的<code>redis</code>节点上执行命令。</p>
<p>在<code>redis</code>看来，响应时间是最苛刻的条件，增加一层带来的开销是<code>redis</code>不能接受的。因此，<code>redis</code>实现了客户端对节点的直接访问，<strong>为了去中心化，节点之间通过<code>gossip</code>协议交换互相的状态，以及探测新加入的节点信息</strong>。<code>redis</code>集群支持动态加入节点，动态迁移<code>slot</code>，以及自动故障转移。</p>
</blockquote>
<h4 id="4-3-1、slot分配"><a href="#4-3-1、slot分配" class="headerlink" title="4.3.1、slot分配"></a>4.3.1、slot分配</h4><p>&emsp;&emsp;<strong>Redis集群模式使用公式 <code>CRC16(key) % 16384</code> 来计算键<code>key</code>属于哪个槽， 其中 <code>CRC16(key)</code> 语句用于计算键 <code>key</code> 的 <code>CRC16</code> 校验和 。集群中的每个节点负责处理一部分哈希槽。</strong></p>
<p><a target="_blank" rel="noopener" href="https://yrlzero.gitee.io/images/linux/redis/redis-28.png"><img src="http://cheng_qiwei.gitee.io/blog/img/redis-28.png" alt="img"></a></p>
<blockquote>
<p>这里简单举个例子， 一个集群可以有三个节点， 其中：</p>
<ol>
<li>节点 A 负责处理 0 号至 5500 号哈希槽。</li>
<li>节点 B 负责处理 5501 号至 11000 号哈希槽。</li>
<li>节点 C 负责处理 11001 号至 16383 号哈希槽。</li>
</ol>
<p>&emsp;&emsp;此时 <code>Redis Client</code> 需要根据一个<code>Key</code>获取对应的 <code>Value</code> 的数据，首先通过 <code>CRC16(key)%16384</code> 计算出 Slot 的值，假设计算的结果是 5000，将这个数据传送给 <code>Redis Cluster</code>，集群接收到以后会到一个对照表中查找这个 <code>Slot=5000</code> 属于那个缓存节点。发现属于“节点 A ”负责，于是顺着红线的方向调用节点 A中存放的 <code>Key-Value</code> 的内容并且返回给 <code>Redis Client</code>。而这种将哈希槽分布到不同节点的做法使得用户可以很容易地向集群中添加或者删除节点。 比如说：</p>
<ul>
<li>如果用户将新节点 D 添加到集群中， 那么集群只需要将节点 A 、B 、 C 中的某些槽移动到节点 D 就可以了。</li>
<li>如果用户要从集群中移除节点 A ， 那么集群只需要将节点 A 中的所有哈希槽移动到节点 B 和节点 C ， 然后再移除空白（不包含任何哈希槽）的节点 A 就可以了。</li>
</ul>
</blockquote>
<p>&emsp;&emsp;<strong>因为将一个哈希槽从一个节点移动到另一个节点不会造成节点阻塞，且成本很低， 所以无论是添加新节点还是移除已存在节点， 又或者改变某个节点包含的哈希槽数量， 都不会造成集群下线</strong>。</p>
<h4 id="4-3-2、数据结构"><a href="#4-3-2、数据结构" class="headerlink" title="4.3.2、数据结构"></a>4.3.2、数据结构</h4><p>&emsp;&emsp;<code>Redis Cluster</code>中的每个节点都保存了集群的配置信息，并且存储在<code>clusterState</code>中，结构如下：</p>
<p><a target="_blank" rel="noopener" href="https://yrlzero.gitee.io/images/linux/redis/redis-30.png"><img src="https://yrlzero.gitee.io/images/linux/redis/redis-30.png" alt="img"></a></p>
<p>上图的各个变量语义如下:</p>
<ul>
<li><code>clusterState</code> 记录了从集群中某个节点视角，来看集群配置状态；</li>
<li><code>currentEpoch</code> 表示整个集群中最大的版本号，集群信息每变更一次，改版本号都会自增。</li>
<li><code>nodes</code> 是一个列表，包含了本节点所感知的，集群所有节点的信息（<code>clusterNode</code>），也包含自身的信息。</li>
<li><code>clusterNode</code> 记录了每个节点的信息，其中包含了节点本身的版本 <code>Epoch</code>；自身的信息描述：节点对应的数据分片范围（<code>slot</code>）、为<code>master</code>时的<code>slave</code>列表、为<code>slave</code>时的<code>master</code>等。</li>
</ul>
<p>**每个节点包含一个全局唯一的<code>NodeId</code>**。</p>
<p>&emsp;&emsp;当集群的数据分片信息发生变更（数据在节点间迁移时），<code>Redis Cluster</code>仍然保持对外服务。</p>
<p>当集群中某个master出现宕机时，<code>Redis Cluster</code> 会自动发现，并触发故障转移的操作。会将<code>master</code>的某个<code>slave</code>晋升为新的 <code>master</code>。</p>
<p>&emsp;&emsp;由此可见，每个节点都保存着<code>Node</code>视角的集群结构。它描述了数据的分片方式，节点主备关系，并通过<code>Epoch</code>作为版本号实现集群结构信息的一致性，同时也控制着数据迁移和故障转移的过程。</p>
<h4 id="4-3-3、节点通信"><a href="#4-3-3、节点通信" class="headerlink" title="4.3.3、节点通信"></a>4.3.3、节点通信</h4><p>&emsp;&emsp;在<code>Redis Cluster</code>中，这个配置信息交互通过<code>Redis Cluster Bus</code>来完成（<code>独立端口</code>）。<code>Redis Cluster Bus</code>上交互的信息结构如下：</p>
<p><img src="https://yrlzero.gitee.io/images/linux/redis/redis-31.png" alt="img"></p>
<p>&emsp;&emsp;<code>clusterMsg</code> 中的<code>type</code>指明了消息的类型，配置信息的一致性主要依靠<code>PING/PONG</code>。每个节点向其他节点频繁的周期性的发送<code>PING/PONG</code>消息。对于消息体中的<code>Gossip</code>部分，包含了<code>sender/receiver</code> 所感知的其他节点信息，接受者根据这些<code>Gossip</code> 跟新对集群的认识。</p>
<p>&emsp;&emsp;对于大规模的集群，如果每次<code>PING/PONG</code> 都携带着所有节点的信息，则网络开销会很大。此时<code>Redis Cluster</code> 在每次<code>PING/PONG</code>，只包含了随机的一部分节点信息。由于交互比较频繁，短时间的几次交互之后，集群的状态也会达成一致。</p>
<h4 id="4-3-4、一致性"><a href="#4-3-4、一致性" class="headerlink" title="4.3.4、一致性"></a>4.3.4、一致性</h4><p>&emsp;&emsp;当<code>Cluster</code> 结构不发生变化时，各个节点通过<code>gossip</code> 协议在几轮交互之后，便可以得知<code>Cluster</code>的结构信息，达到一致性的状态。但是当集群结构发生变化时（故障转移/分片迁移等），优先得知变更的节点通过Epoch变量，将自己的最新信息扩散到<code>Cluster</code>，并最终达到一致。</p>
<p>&emsp;&emsp;<code>clusterNode</code> 的<code>Epoch</code>描述的单个节点的信息版本；<br>&emsp;&emsp;<code>clusterState</code> 的<code>currentEpoch</code> 描述的是集群信息的版本，它可以辅助<code>Epoch</code> 的自增生成。因为<code>currentEpoch</code> 是维护在每个节点上的，在集群结构发生变更时，<code>Cluster</code> 在一定的时间窗口控制更新规则，来保证每个节点的<code>currentEpoch</code>都是最新的。<br>&emsp;&emsp;Cluster更新规则如下：当某个节点率先知道了变更时，将自身的<code>currentEpoch</code> 自增，并使之成为集群中的最大值。再用自增后的<code>currentEpoch</code> 作为新的<code>Epoch</code> 版本；</p>
<ul>
<li>当某个节点收到了比自己大的<code>currentEpoch</code>时，更新自己的<code>currentEpoch</code>；</li>
<li>当收到的<code>Redis Cluster Bus</code> 消息中的某个节点的<code>Epoch</code> &gt; 自身的时，将更新自身的内容；</li>
<li>当<code>Redis Cluster Bus</code> 消息中，包含了自己没有的节点时，将其加入到自身的配置中。</li>
</ul>
<p>&emsp;&emsp;上述的规则保证了信息的更新都是单向的，最终朝着<code>Epoch</code>更大的信息收敛。同时<code>Epoch</code>也随着<code>currentEpoch</code>的增加而增加，最终将各节点信息趋于稳定。</p>
<p>&emsp;&emsp;为了使得集群在一部分节点下线或者无法与集群的大多数（<code>majority</code>）节点进行通讯的情况下， 仍然可以正常运作， <code>Redis</code> 集群对节点使用了主从复制功能： 集群中的每个节点都有 1 个至 N 个复制品（<code>replica</code>）， 其中一个复制品为主节点（<code>master</code>）， 而其余的 N-1 个复制品为从节点（<code>slave</code>）。</p>
<p><strong>集群间节点支持主从关系</strong>，复制的逻辑基本复用了单机版的实现。不过还是有些地方需要注意。</p>
<ul>
<li>首先集群间节点建立主从关系不再使用原有的<code>SLAVEOF</code>命令和<code>SLAVEOF</code>配置，而是通过<code>cluster replicate</code>命令，这保证了主从节点需要先完成握手，才能建立主从关系。</li>
<li>集群是不能组成链式主从关系的，也就是说从节点不能有自己的从节点。不过对于集群外的没开启集群功能的节点，<code>redis</code>并不干预这些节点去复制集群内的节点，但是在集群故障转移时，这些集群外的节点，集群不会处理。</li>
<li>集群内节点想要复制另一个节点，需要保证本节点不再负责任何<code>slot</code>，不然<code>redis</code>也是不允许的。</li>
<li>集群内的从节点在与其他节点通信的时候，传递的消息中数据分布表和<code>epoch</code>是<code>master</code>的值。</li>
</ul>
<p><strong>集群主节点出现故障，发生故障转移，其他主节点会把故障主节点的从节点自动提为主节点，原来的主节点恢复后，自动成为新主节点的从节点</strong>。</p>
<p>&emsp;&emsp;这里先说明，把一个<code>master</code>和它的全部<code>slave</code>描述为一个<code>group</code>，故障转移是以<code>group</code>为单位的，集群故障转移的方式跟sentinel的实现很类似。</p>
<p><img src="http://cheng_qiwei.gitee.io/blog/img/redis-32.png" alt="img"></p>
<h4 id="4-3-5、均衡集群"><a href="#4-3-5、均衡集群" class="headerlink" title="4.3.5、均衡集群"></a>4.3.5、均衡集群</h4><p>&emsp;&emsp;在集群运行过程中，有的<code>master</code>的<code>slave</code>宕机，导致了该<code>master</code>成为孤儿<code>master</code>（<code>orphaned masters</code>），而有的<code>master</code>有很多<code>slave</code>。（此处孤儿<code>master</code>的定义是那些本来有<code>slave</code>，但是全部离线的<code>master</code>，对于那些原来就没有<code>slave</code>的<code>master</code>不能认为是孤儿<code>master</code>。）</p>
<p>&emsp;&emsp;<code>redis</code>集群支持均衡<code>slave</code>功能，官方称为<code>Replica migration</code>，而我觉得均衡集群的<code>slave</code>更好理解该概念。集群能把某个<code>slave</code>较多的<code>group</code>上的<code>slave</code>迁移到那些孤儿<code>master</code>上，该功能通过<code>cluster-migration-barrier</code>参数配置，默认为1。<code>slave</code>在每次定时任务都会检查是否需要迁移<code>slave</code>，即把自己变成孤儿<code>master</code>的<code>slave</code>。 满足以下条件，<code>slave</code>就会成为孤儿<code>master</code>的<code>slave</code>：</p>
<ul>
<li>自己所在的<code>group</code>是<code>slave</code>最多的<code>group</code>；</li>
<li>目前存在孤儿<code>master</code>；</li>
<li>自己所在的<code>group</code>的<code>slave</code>数目至少超过2个，只有自己一个的话迁移到其他<code>group</code>，自己原来的<code>group</code>的<code>master</code>又成了孤儿<code>master</code>；</li>
<li>自己所在的<code>group</code>的<code>slave</code>数量大于<code>cluster-migration-barrier</code>配置；</li>
<li>与<code>group</code>内的其他<code>slave</code>基于<code>memcmp</code>比较<code>node id</code>，自己的<code>node id</code>最小。这个可以防止多个<code>slave</code>并发复制孤儿<code>master</code>，从而原来的<code>group</code>失去过多的<code>slave</code>。</li>
</ul>
<blockquote>
<ul>
<li>优势</li>
</ul>
<ol>
<li>去中心化，集群最大可增加1000个节点，性能随节点增加而线性扩展。</li>
<li>解耦 <strong>数据</strong> 和 <strong>节点</strong> 之间的关系，简化了节点 <strong>扩容</strong> 和 <strong>收缩</strong> 难度。</li>
<li><strong>节点自身</strong> 维护槽的 <strong>映射关系</strong>，不需要 <strong>客户端</strong> 或者 <strong>代理服务</strong> 维护 <strong>槽分区元数据</strong>。</li>
</ol>
<ul>
<li>劣势</li>
</ul>
<ol>
<li><code>key</code> <strong>批量操作</strong> 支持有限。类似 <code>mset</code>、<code>mget</code> 操作，目前只支持对具有相同 <code>slot</code> 值的<code>key</code> 执行 <strong>批量操作</strong>。对于 <strong>映射为不同</strong> <code>slot</code> 值的<code>key</code> 由于执行 <code>mget</code>、<code>mget</code> 等操作可能存在于多个节点上，因此不被支持。</li>
<li>只支持 <strong>多</strong> <code>key</code> 在 <strong>同一节点上</strong> 的 <strong>事务操作</strong>，当多个 <code>key</code> 分布在 <strong>不同</strong> 的节点上时 <strong>无法</strong> 使用事务功能。</li>
<li><code>key</code> 作为 <strong>数据分区</strong> 的最小粒度，不能将一个 <strong>大的键值</strong> 对象如 <code>Hash</code>、<code>list</code> 等映射到 <strong>不同的节点</strong>。</li>
<li>不支持<strong>多数据库空间</strong>，<strong>单机</strong>下的<code>Redis</code>可以支持 16 个数据库（db0 ~ db15），<strong>集群模式</strong>下只能使用<strong>一个</strong> 数据库空间，即 db0。</li>
<li><strong>复制结构</strong> 只支持一层，<strong>从节点</strong> 只能复制 <strong>主节点</strong>，不支持 <strong>嵌套树状复制</strong> 结构。</li>
</ol>
</blockquote>
<h3 id="4-4、查询路由分区——Redis-Cluster（操作）"><a href="#4-4、查询路由分区——Redis-Cluster（操作）" class="headerlink" title="4.4、查询路由分区——Redis-Cluster（操作）"></a>4.4、查询路由分区——Redis-Cluster（操作）</h3><p>&emsp;&emsp;操作Redis-Cluster有两种方式，一种是脚本启动（由Redis-Cluster创建实例），一种是手动启动（自行创建实例）。</p>
<ul>
<li><strong>脚本启动</strong></li>
</ul>
<h4 id="4-4-1、配置脚本"><a href="#4-4-1、配置脚本" class="headerlink" title="4.4.1、配置脚本"></a>4.4.1、配置脚本</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/redis-6.0.9/utils/create-cluster &amp;&amp; vim create-cluster</span><br><span class="line"></span><br><span class="line"><span class="comment"># Settings</span></span><br><span class="line">BIN_PATH=<span class="string">&quot;../../src/&quot;</span></span><br><span class="line">CLUSTER_HOST=127.0.0.1</span><br><span class="line">PORT=30000</span><br><span class="line">TIMEOUT=2000</span><br><span class="line">NODES=6 <span class="comment">#总的节点数量</span></span><br><span class="line">REPLICAS=1 <span class="comment">#每个master对应的slave数量</span></span><br><span class="line">PROTECTED_MODE=yes</span><br><span class="line">ADDITIONAL_OPTIONS=<span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这里总的节点数为6个，每个主节点对应一个从节点，可自行配置。</p>
<h4 id="4-4-2、启动集群实例"><a href="#4-4-2、启动集群实例" class="headerlink" title="4.4.2、启动集群实例"></a>4.4.2、启动集群实例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./create-cluster start</span><br></pre></td></tr></table></figure>

<p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210719135126262.png" alt="image-20210719135126262"></p>
<h4 id="4-4-3、脚本自动分配slot（Hash槽位）"><a href="#4-4-3、脚本自动分配slot（Hash槽位）" class="headerlink" title="4.4.3、脚本自动分配slot（Hash槽位）"></a>4.4.3、脚本自动分配slot（Hash槽位）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./create-cluster create</span><br></pre></td></tr></table></figure>

<p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210719135644846.png" alt="image-20210719135644846"></p>
<h4 id="4-4-4、客户端连接集群"><a href="#4-4-4、客户端连接集群" class="headerlink" title="4.4.4、客户端连接集群"></a>4.4.4、客户端连接集群</h4><ul>
<li><strong>普通模式连接集群节点</strong></li>
</ul>
<p>&emsp;&emsp;在普通模式连接时，如果key分配的slot不在当前连接的redis server时，服务端返回错误提示，让客户端自己进行跳转 <code>(error) MOVED 12706 ip:port</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 30001</span><br></pre></td></tr></table></figure>

<p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210719140247198.png" alt="image-20210719140247198"></p>
<ul>
<li><strong>集群模式连接集群节点</strong></li>
</ul>
<p>&emsp;&emsp;在集群模式连接时，如果key分配的slot不在当前连接的redis server时，集群模式客户端会帮助我们进行重定向跳转 <code>Redirected to slot [12706] located at ip:port</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -c -p 30001</span><br></pre></td></tr></table></figure>

<p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210719140511550.png" alt="image-20210719140511550"></p>
<h4 id="4-4-5、注意事项"><a href="#4-4-5、注意事项" class="headerlink" title="4.4.5、注意事项"></a>4.4.5、注意事项</h4><p>&emsp;&emsp;不管是<code>普通客户端模式</code>还是<code>集群客户端模式</code>去连接服务，如果key不在一个slot仍无法使用事务等指令。解决同类业务数据不在同个 redis哈希槽的问题，在key上加上{tag}来标识某个key，会计算第一次出现’{‘到第一次出现’}’之间的subString内容的Hash值，如果该内容为空，则计算整个key;这种方式是解决分区key不同分区的通用解决方案。</p>
<h4 id="4-4-6、停止与还原"><a href="#4-4-6、停止与还原" class="headerlink" title="4.4.6、停止与还原"></a>4.4.6、停止与还原</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 停止所有正在运行的redis-cluster实例 </span></span><br><span class="line">./create-cluster stop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除配置、日志、持久化文件 </span></span><br><span class="line">./create-cluster clean</span><br></pre></td></tr></table></figure>

<p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210719140900210.png" alt="image-20210719140900210"></p>
<ul>
<li><strong>手动启动</strong></li>
</ul>
<h4 id="4-4-7、修改Redis启动配置文件"><a href="#4-4-7、修改Redis启动配置文件" class="headerlink" title="4.4.7、修改Redis启动配置文件"></a>4.4.7、修改Redis启动配置文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/<span class="built_in">local</span>/bin/redis.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">################################ REDIS CLUSTER  ###############################</span></span><br><span class="line"><span class="comment">#redis.conf相关集群配置</span></span><br><span class="line"><span class="comment">#配置为cluster模式</span></span><br><span class="line">cluster-enabled yes</span><br><span class="line"></span><br><span class="line"><span class="comment">#集群节点配置信息，包括nodeid，集群信息。此文件非常关键，要确保故障转移或者重启的时候此文件还在，所以如果在docker环境下要外挂到外部存储</span></span><br><span class="line">cluster-config-file nodes-6379.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">#节点连接超时，如果集群规模小，都在同一个网络环境下，可以配置的短些，更快的做故障转移</span></span><br><span class="line">cluster-node-timeout 2000</span><br><span class="line"></span><br><span class="line"><span class="comment">#慢查询日志，用于性能分析，生产环境可设置为1000（毫秒）</span></span><br><span class="line">slowlog-log-slower-than 1000</span><br><span class="line"></span><br><span class="line"><span class="comment">#保存慢查询的队列长度 ，设置为1000</span></span><br><span class="line">slowlog-max-len 1000</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置为0，默认为10如果master slave都挂掉，slave跟master失联又超过这个数值*timeout的数值，就不会发起选举了。</span></span><br><span class="line"><span class="comment">#如果设置为0，就是永远都会尝试发起选举，尝试从slave变为mater</span></span><br><span class="line">cluster-slave-validity-factor 10</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置为no，默认为yes，故障发现到自动完成转移期间整个集群是不可用状态，对于大多数业务无法容忍这种情况</span></span><br><span class="line"><span class="comment">#因此要设置为no，当主节点故障时只影 响它负责槽的相关命令执行，不会影响其他主节点的可用性</span></span><br><span class="line">cluster-require-full-coverage yes</span><br></pre></td></tr></table></figure>

<p><strong>其他实例配置：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">################################ REDIS CLUSTER  ###############################</span></span><br><span class="line">cluster-enabled yes</span><br><span class="line"></span><br><span class="line">cluster-config-file nodes-6380.conf <span class="comment">#注意区分各个节点</span></span><br></pre></td></tr></table></figure>



<h4 id="4-4-8、启动并手动分配slot（Hash槽）"><a href="#4-4-8、启动并手动分配slot（Hash槽）" class="headerlink" title="4.4.8、启动并手动分配slot（Hash槽）"></a>4.4.8、启动并手动分配slot（Hash槽）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动redis实例（启动cluster【6379】和其他各个要接入的节点【6380~6383】）</span></span><br><span class="line">redis-server  ./redis.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动分配slot（Hash槽）</span></span><br><span class="line">redis-cli --cluster create 127.0.0.1:6380 127.0.0.1:6381 127.0.0.1:6382 127.0.0.1:6383 127.0.0.1:6384 127.0.0.1:6385 --cluster-replicas 1</span><br></pre></td></tr></table></figure>

<p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210720111900909.png" alt="image-20210720111900909"></p>
<p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210720112151755.png" alt="image-20210720112151755"></p>
<h4 id="4-4-9、移动slot（Hash槽）"><a href="#4-4-9、移动slot（Hash槽）" class="headerlink" title="4.4.9、移动slot（Hash槽）"></a>4.4.9、移动slot（Hash槽）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#实行重新分片命令，可任意连接一个redis实例进行操作</span></span><br><span class="line">redis-cli --cluster reshard 127.0.0.1:6380</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:30001)</span><br><span class="line">M: 1ba79d08eacd99fa3791d1824907a3e3e136cf06 127.0.0.1:30001</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: d23ba04b97a59fa4bf3400510feb128ef0694520 127.0.0.1:30004</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 1ba79d08eacd99fa3791d1824907a3e3e136cf06</span><br><span class="line">S: 40b2868d28ac09031df1caa9847066eadebfa4f7 127.0.0.1:30006</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates e5bb13b4ea84f4fd5f23a944ae59a6768a34be28</span><br><span class="line">S: ddeb75d4235f26ce86fe30d3aa9edffde92d5a31 127.0.0.1:30005</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates e3e285582cabc5360d74e99c778867526cecb2a1</span><br><span class="line">M: e3e285582cabc5360d74e99c778867526cecb2a1 127.0.0.1:30002</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: e5bb13b4ea84f4fd5f23a944ae59a6768a34be28 127.0.0.1:30003</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br><span class="line"><span class="comment">#想要移动多少槽位？这里指定了2000</span></span><br><span class="line">How many slots <span class="keyword">do</span> you want to move (from 1 to 16384)? 2000</span><br><span class="line"><span class="comment"># 想要移动到哪个节点？这里指定了30002的节点id</span></span><br><span class="line">What is the receiving node ID? e3e285582cabc5360d74e99c778867526cecb2a1</span><br><span class="line">Please enter all the <span class="built_in">source</span> node IDs.</span><br><span class="line">  Type <span class="string">&#x27;all&#x27;</span> to use all the nodes as <span class="built_in">source</span> nodes <span class="keyword">for</span> the <span class="built_in">hash</span> slots.</span><br><span class="line">  Type <span class="string">&#x27;done&#x27;</span> once you entered all the <span class="built_in">source</span> nodes IDs.</span><br><span class="line">Source node <span class="comment">#1: 1ba79d08eacd99fa3791d1824907a3e3e136cf06</span></span><br><span class="line">Source node <span class="comment">#2: done</span></span><br><span class="line"><span class="comment">#略</span></span><br><span class="line">    Moving slot 1998 from 1ba79d08eacd99fa3791d1824907a3e3e136cf06</span><br><span class="line">    Moving slot 1999 from 1ba79d08eacd99fa3791d1824907a3e3e136cf06</span><br><span class="line"><span class="comment"># 是否执行表重新分片计划？yes</span></span><br><span class="line">Do you want to proceed with the proposed reshard plan (yes/no)? yes</span><br><span class="line"><span class="comment">#略</span></span><br><span class="line">Moving slot 1997 from 127.0.0.1:30001 to 127.0.0.1:30002: </span><br><span class="line">Moving slot 1998 from 127.0.0.1:30001 to 127.0.0.1:30002: </span><br><span class="line">Moving slot 1999 from 127.0.0.1:30001 to 127.0.0.1:30002:</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分配完成后可以使用一下命令查询分配情况</span></span><br><span class="line">redis-cli --cluster check 127.0.0.1:6380</span><br></pre></td></tr></table></figure>

<p><img src="http://cheng_qiwei.gitee.io/blog/img/image-20210720113627150.png" alt="image-20210720113627150"></p>
<h4 id="4-4-10、集群客户端-帮助"><a href="#4-4-10、集群客户端-帮助" class="headerlink" title="4.4.10、集群客户端-帮助"></a>4.4.10、集群客户端-帮助</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">[root@centos-3 create-cluster]<span class="comment"># redis-cli --cluster help</span></span><br><span class="line">Cluster Manager Commands:</span><br><span class="line">  create         host1:port1 ... hostN:portN</span><br><span class="line">                 --cluster-replicas &lt;arg&gt;</span><br><span class="line">  check          host:port</span><br><span class="line">                 --cluster-search-multiple-owners</span><br><span class="line">  info           host:port</span><br><span class="line">  fix            host:port</span><br><span class="line">                 --cluster-search-multiple-owners</span><br><span class="line">                 --cluster-fix-with-unreachable-masters</span><br><span class="line">  reshard        host:port</span><br><span class="line">                 --cluster-from &lt;arg&gt;</span><br><span class="line">                 --cluster-to &lt;arg&gt;</span><br><span class="line">                 --cluster-slots &lt;arg&gt;</span><br><span class="line">                 --cluster-yes</span><br><span class="line">                 --cluster-timeout &lt;arg&gt;</span><br><span class="line">                 --cluster-pipeline &lt;arg&gt;</span><br><span class="line">                 --cluster-replace</span><br><span class="line">  rebalance      host:port</span><br><span class="line">                 --cluster-weight &lt;node1=w1...nodeN=wN&gt;</span><br><span class="line">                 --cluster-use-empty-masters</span><br><span class="line">                 --cluster-timeout &lt;arg&gt;</span><br><span class="line">                 --cluster-simulate</span><br><span class="line">                 --cluster-pipeline &lt;arg&gt;</span><br><span class="line">                 --cluster-threshold &lt;arg&gt;</span><br><span class="line">                 --cluster-replace</span><br><span class="line">  add-node       new_host:new_port existing_host:existing_port</span><br><span class="line">                 --cluster-slave</span><br><span class="line">                 --cluster-master-id &lt;arg&gt;</span><br><span class="line">  del-node       host:port node_id</span><br><span class="line">  call           host:port <span class="built_in">command</span> arg arg .. arg</span><br><span class="line">                 --cluster-only-masters</span><br><span class="line">                 --cluster-only-replicas</span><br><span class="line">  set-timeout    host:port milliseconds</span><br><span class="line">  import         host:port</span><br><span class="line">                 --cluster-from &lt;arg&gt;</span><br><span class="line">                 --cluster-copy</span><br><span class="line">                 --cluster-replace</span><br><span class="line">  backup         host:port backup_directory</span><br><span class="line">  <span class="built_in">help</span>           </span><br><span class="line"></span><br><span class="line">For check, fix, reshard, del-node, set-timeout you can specify the host and port of any working node <span class="keyword">in</span> the cluster.</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">WinKing</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://cheng_qiwei.gitee.io/blog/2021/06/30/Redis%E9%9B%86%E7%BE%A4%E5%92%8C%E5%88%86%E5%8C%BA/">http://cheng_qiwei.gitee.io/blog/2021/06/30/Redis%E9%9B%86%E7%BE%A4%E5%92%8C%E5%88%86%E5%8C%BA/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://cheng_qiwei.gitee.io/blog" target="_blank">WinKings Blogs</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/blog/tags/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/">主从复制</a><a class="post-meta__tags" href="/blog/tags/Redis/">Redis</a><a class="post-meta__tags" href="/blog/tags/%E5%93%A8%E5%85%B5/">哨兵</a><a class="post-meta__tags" href="/blog/tags/%E5%88%86%E5%8C%BA/">分区</a><a class="post-meta__tags" href="/blog/tags/%E9%9B%86%E7%BE%A4/">集群</a></div><div class="post_share"><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=null" async="async"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/blog/2021/07/10/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E5%88%86%E5%8C%BA%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94Hash%E4%B8%8E%E4%B8%80%E8%87%B4%E6%80%A7Hash/"><img class="prev-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/blog/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">分布式缓存分区算法——Hash与一致性Hash</div></div></a></div><div class="next-post pull-right"><a href="/blog/2021/06/14/Redis%E7%9A%84%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/blog/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Redis的进阶使用</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/blog/2021/05/21/MySQL主从复制/" title="MySQL主从复制"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-21</div><div class="title">MySQL主从复制</div></div></a></div><div><a href="/blog/2021/06/14/Redis的进阶使用/" title="Redis的进阶使用"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-14</div><div class="title">Redis的进阶使用</div></div></a></div><div><a href="/blog/2021/06/07/Redis介绍与命令/" title="Redis介绍与命令"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-07</div><div class="title">Redis介绍与命令</div></div></a></div></div></div></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" src="/blog/img/touxiang.jpg" onerror="this.onerror=null;this.src='/blog/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">WinKing</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/blog/archives/"><div class="headline">文章</div><div class="length-num">25</div></a></div><div class="card-info-data-item is-center"><a href="/blog/tags/"><div class="headline">标签</div><div class="length-num">48</div></a></div><div class="card-info-data-item is-center"><a href="/blog/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://gitee.com/cheng_qiwei"><i class="fab fa-gitee"></i><span>Follow Me</span></a></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%8C%BA"><span class="toc-text">Redis集群与分区</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%BC%95%E5%85%A5Redis%E9%9B%86%E7%BE%A4%E4%B8%8E%E5%88%86%E5%8C%BA"><span class="toc-text">一、为什么需要引入Redis集群与分区</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Redis%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-text">二、Redis的主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">1、主从复制的优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1%E3%80%81%E4%BC%98%E7%82%B9"><span class="toc-text">1.1、优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2%E3%80%81%E7%BC%BA%E7%82%B9"><span class="toc-text">1.2、缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-text">2、主从复制相关概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86"><span class="toc-text">3、主从复制原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">4、主从复制的操作流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1%E3%80%81%E5%87%86%E5%A4%87%E6%93%8D%E4%BD%9C"><span class="toc-text">4.1、准备操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2%E3%80%81%E6%89%A7%E8%A1%8C%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-text">4.2、执行主从复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3%E3%80%81slave%E5%8D%87%E7%BA%A7%E4%B8%BAmaster"><span class="toc-text">4.3、slave升级为master</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">4.4、总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F"><span class="toc-text">三、哨兵模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F"><span class="toc-text">1、为什么需要哨兵模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFRedis-%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F"><span class="toc-text">2、什么是Redis 哨兵模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81Sentinel%E9%9B%86%E7%BE%A4%E4%B8%8E%E7%9B%B8%E4%BA%92%E5%8F%91%E7%8E%B0"><span class="toc-text">3、Sentinel集群与相互发现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81Sentinel%E5%AF%B9master%E7%9A%84%E6%95%85%E9%9A%9C%E5%88%A4%E5%AE%9A%E4%B8%8Emaster%E7%9A%84%E9%80%89%E4%B8%BE"><span class="toc-text">4、Sentinel对master的故障判定与master的选举</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81Sentinel%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">5、Sentinel哨兵模式的操作流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1%E3%80%81%E9%85%8D%E7%BD%AESentinel%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-text">5.1、配置Sentinel相关配置文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2%E3%80%81%E5%90%AF%E5%8A%A8Redis-Master%E5%92%8CSlave"><span class="toc-text">5.2、启动Redis-Master和Slave</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3%E3%80%81%E5%90%AF%E5%8A%A8Redis-Sentinel%E9%9B%86%E7%BE%A4"><span class="toc-text">5.3、启动Redis-Sentinel集群</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E6%B5%8B%E8%AF%95%E9%87%8D%E6%96%B0%E9%80%89%E4%B8%BEMaster"><span class="toc-text">6、测试重新选举Master</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E9%97%AE%E9%A2%98"><span class="toc-text">7、问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Redis%E7%9A%84%E5%88%86%E5%8C%BA"><span class="toc-text">四、Redis的分区</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81Redis%E5%88%86%E5%8C%BA%E7%9A%84%E4%BC%98%E7%82%B9%E4%B8%8E%E7%BC%BA%E7%82%B9"><span class="toc-text">1、Redis分区的优点与缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1%E3%80%81%E4%BC%98%E7%82%B9-1"><span class="toc-text">1.1、优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2%E3%80%81%E7%BC%BA%E7%82%B9-1"><span class="toc-text">1.2、缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81Redis%E5%88%86%E5%8C%BA%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-text">2、Redis分区的相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%E3%80%81%E4%B8%89%E7%A7%8D%E5%88%86%E5%8C%BA%E6%96%B9%E6%A1%88"><span class="toc-text">2.1、三种分区方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%88%86%E5%8C%BA"><span class="toc-text">2.1.1、客户端分区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2%E3%80%81%E4%BB%A3%E7%90%86%E5%88%86%E5%8C%BA"><span class="toc-text">2.1.2、代理分区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-3%E3%80%81%E6%9F%A5%E8%AF%A2%E8%B7%AF%E7%94%B1-Query-routing"><span class="toc-text">2.1.3、查询路由(Query routing)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%E3%80%81%E9%A2%84%E5%88%86%E5%8C%BA"><span class="toc-text">2.2、预分区</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E6%95%B0%E6%8D%AE%E5%88%86%E6%B2%BB"><span class="toc-text">3、数据分治</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E3%80%81Client%E7%AB%AF%E5%A4%84%E7%90%86"><span class="toc-text">3.1、Client端处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1%E3%80%81%E9%80%BB%E8%BE%91%E5%A4%84%E7%90%86"><span class="toc-text">3.1.1、逻辑处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-2%E3%80%81Hash%E7%AE%97%E6%B3%95%E4%B8%8E%E4%B8%80%E8%87%B4%E6%80%A7Hash"><span class="toc-text">3.1.2、Hash算法与一致性Hash</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2%E3%80%81Server%E7%AB%AF%E5%A4%84%E7%90%86"><span class="toc-text">3.2、Server端处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1%E3%80%81%E4%BB%A3%E7%90%86%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-text">3.2.1、代理与负载均衡</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3%E3%80%81%E5%93%88%E5%B8%8C%E6%A7%BD"><span class="toc-text">3.3、哈希槽</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%88%86%E5%8C%BA%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-text">4、分区的实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1%E3%80%81%E4%BB%A3%E7%90%86%E5%88%86%E5%8C%BA%E2%80%94%E2%80%94TwemProxy"><span class="toc-text">4.1、代理分区——TwemProxy</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1%E3%80%81%E5%AE%89%E8%A3%85"><span class="toc-text">4.1.1、安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2%E3%80%81%E9%85%8D%E7%BD%AETwemProxy"><span class="toc-text">4.1.2、配置TwemProxy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-3%E3%80%81%E4%BD%BF%E7%94%A8TwemProxy"><span class="toc-text">4.1.3、使用TwemProxy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-4%E3%80%81%E9%80%9A%E8%BF%87%E4%BB%A3%E7%90%86TwemProxy%E8%BF%9E%E6%8E%A5Redis"><span class="toc-text">4.1.4、通过代理TwemProxy连接Redis</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2%E3%80%81%E4%BB%A3%E7%90%86%E5%88%86%E5%8C%BA%E2%80%94%E2%80%94Predixy"><span class="toc-text">4.2、代理分区——Predixy</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1%E3%80%81%E5%AE%89%E8%A3%85Predixy"><span class="toc-text">4.2.1、安装Predixy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2%E3%80%81%E9%85%8D%E7%BD%AEPredixy"><span class="toc-text">4.2.2、配置Predixy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3%E3%80%81%E9%85%8D%E7%BD%AEsentinel"><span class="toc-text">4.2.3、配置sentinel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-4%E3%80%81%E5%90%AF%E5%8A%A8Redis%E4%B8%BB%E4%BB%8E"><span class="toc-text">4.2.4、启动Redis主从</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-5%E3%80%81%E5%90%AF%E5%8A%A8Predixy"><span class="toc-text">4.2.5、启动Predixy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-6%E3%80%81%E8%BF%9E%E6%8E%A5%E6%B5%8B%E8%AF%95Predixy"><span class="toc-text">4.2.6、连接测试Predixy</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3%E3%80%81%E6%9F%A5%E8%AF%A2%E8%B7%AF%E7%94%B1%E5%88%86%E5%8C%BA%E2%80%94%E2%80%94Redis-Cluster%EF%BC%88%E7%90%86%E8%AE%BA%EF%BC%89"><span class="toc-text">4.3、查询路由分区——Redis-Cluster（理论）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-1%E3%80%81slot%E5%88%86%E9%85%8D"><span class="toc-text">4.3.1、slot分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-2%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">4.3.2、数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-3%E3%80%81%E8%8A%82%E7%82%B9%E9%80%9A%E4%BF%A1"><span class="toc-text">4.3.3、节点通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-4%E3%80%81%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-text">4.3.4、一致性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-5%E3%80%81%E5%9D%87%E8%A1%A1%E9%9B%86%E7%BE%A4"><span class="toc-text">4.3.5、均衡集群</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4%E3%80%81%E6%9F%A5%E8%AF%A2%E8%B7%AF%E7%94%B1%E5%88%86%E5%8C%BA%E2%80%94%E2%80%94Redis-Cluster%EF%BC%88%E6%93%8D%E4%BD%9C%EF%BC%89"><span class="toc-text">4.4、查询路由分区——Redis-Cluster（操作）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-1%E3%80%81%E9%85%8D%E7%BD%AE%E8%84%9A%E6%9C%AC"><span class="toc-text">4.4.1、配置脚本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-2%E3%80%81%E5%90%AF%E5%8A%A8%E9%9B%86%E7%BE%A4%E5%AE%9E%E4%BE%8B"><span class="toc-text">4.4.2、启动集群实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-3%E3%80%81%E8%84%9A%E6%9C%AC%E8%87%AA%E5%8A%A8%E5%88%86%E9%85%8Dslot%EF%BC%88Hash%E6%A7%BD%E4%BD%8D%EF%BC%89"><span class="toc-text">4.4.3、脚本自动分配slot（Hash槽位）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-4%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5%E9%9B%86%E7%BE%A4"><span class="toc-text">4.4.4、客户端连接集群</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-5%E3%80%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">4.4.5、注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-6%E3%80%81%E5%81%9C%E6%AD%A2%E4%B8%8E%E8%BF%98%E5%8E%9F"><span class="toc-text">4.4.6、停止与还原</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-7%E3%80%81%E4%BF%AE%E6%94%B9Redis%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-text">4.4.7、修改Redis启动配置文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-8%E3%80%81%E5%90%AF%E5%8A%A8%E5%B9%B6%E6%89%8B%E5%8A%A8%E5%88%86%E9%85%8Dslot%EF%BC%88Hash%E6%A7%BD%EF%BC%89"><span class="toc-text">4.4.8、启动并手动分配slot（Hash槽）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-9%E3%80%81%E7%A7%BB%E5%8A%A8slot%EF%BC%88Hash%E6%A7%BD%EF%BC%89"><span class="toc-text">4.4.9、移动slot（Hash槽）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-10%E3%80%81%E9%9B%86%E7%BE%A4%E5%AE%A2%E6%88%B7%E7%AB%AF-%E5%B8%AE%E5%8A%A9"><span class="toc-text">4.4.10、集群客户端-帮助</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/blog/2021/07/25/zookeeper%E4%BB%8B%E7%BB%8D/" title="zookeeper详解"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="zookeeper详解"/></a><div class="content"><a class="title" href="/blog/2021/07/25/zookeeper%E4%BB%8B%E7%BB%8D/" title="zookeeper详解">zookeeper详解</a><time datetime="2021-07-25T14:00:00.000Z" title="发表于 2021-07-25 22:00:00">2021-07-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2021/07/10/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E5%88%86%E5%8C%BA%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94Hash%E4%B8%8E%E4%B8%80%E8%87%B4%E6%80%A7Hash/" title="分布式缓存分区算法——Hash与一致性Hash"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="分布式缓存分区算法——Hash与一致性Hash"/></a><div class="content"><a class="title" href="/blog/2021/07/10/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E5%88%86%E5%8C%BA%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94Hash%E4%B8%8E%E4%B8%80%E8%87%B4%E6%80%A7Hash/" title="分布式缓存分区算法——Hash与一致性Hash">分布式缓存分区算法——Hash与一致性Hash</a><time datetime="2021-07-10T14:00:00.000Z" title="发表于 2021-07-10 22:00:00">2021-07-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2021/06/30/Redis%E9%9B%86%E7%BE%A4%E5%92%8C%E5%88%86%E5%8C%BA/" title="Redis集群与分区"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="Redis集群与分区"/></a><div class="content"><a class="title" href="/blog/2021/06/30/Redis%E9%9B%86%E7%BE%A4%E5%92%8C%E5%88%86%E5%8C%BA/" title="Redis集群与分区">Redis集群与分区</a><time datetime="2021-06-30T14:00:00.000Z" title="发表于 2021-06-30 22:00:00">2021-06-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2021/06/14/Redis%E7%9A%84%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8/" title="Redis的进阶使用"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="Redis的进阶使用"/></a><div class="content"><a class="title" href="/blog/2021/06/14/Redis%E7%9A%84%E8%BF%9B%E9%98%B6%E4%BD%BF%E7%94%A8/" title="Redis的进阶使用">Redis的进阶使用</a><time datetime="2021-06-14T14:00:00.000Z" title="发表于 2021-06-14 22:00:00">2021-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2021/06/07/Redis%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%91%BD%E4%BB%A4/" title="Redis介绍与命令"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="Redis介绍与命令"/></a><div class="content"><a class="title" href="/blog/2021/06/07/Redis%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%91%BD%E4%BB%A4/" title="Redis介绍与命令">Redis介绍与命令</a><time datetime="2021-06-07T14:00:00.000Z" title="发表于 2021-06-07 22:00:00">2021-06-07</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By WinKing</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/blog/js/utils.js"></script><script src="/blog/js/main.js"></script><script src="/blog/js/tw_cn.js"></script><script src="/blog/js/search/local-search.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script></div></body></html>